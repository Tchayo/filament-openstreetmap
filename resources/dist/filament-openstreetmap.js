var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/ol/events/Event.js
function stopPropagation(evt) {
  evt.stopPropagation();
}
function preventDefault(evt) {
  evt.preventDefault();
}
var BaseEvent, Event_default;
var init_Event = __esm({
  "node_modules/ol/events/Event.js"() {
    BaseEvent = class {
      /**
       * @param {string} type Type.
       */
      constructor(type) {
        this.propagationStopped;
        this.defaultPrevented;
        this.type = type;
        this.target = null;
      }
      /**
       * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
       * will be fired.
       * @api
       */
      preventDefault() {
        this.defaultPrevented = true;
      }
      /**
       * Stop event propagation.
       * @api
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    Event_default = BaseEvent;
  }
});

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default;
var init_ObjectEventType = __esm({
  "node_modules/ol/ObjectEventType.js"() {
    ObjectEventType_default = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: "propertychange"
    };
  }
});

// node_modules/ol/Disposable.js
var Disposable, Disposable_default;
var init_Disposable = __esm({
  "node_modules/ol/Disposable.js"() {
    Disposable = class {
      constructor() {
        this.disposed = false;
      }
      /**
       * Clean up.
       */
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      /**
       * Extension point for disposable objects.
       * @protected
       */
      disposeInternal() {
      }
    };
    Disposable_default = Disposable;
  }
});

// node_modules/ol/array.js
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function descending(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function remove(arr, obj) {
  const i = arr.indexOf(obj);
  const found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function stableSort(arr, compareFnc) {
  const length = arr.length;
  const tmp = Array(arr.length);
  let i;
  for (i = 0; i < length; i++) {
    tmp[i] = { index: i, value: arr[i] };
  }
  tmp.sort(function(a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
var init_array = __esm({
  "node_modules/ol/array.js"() {
  }
});

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let called = false;
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}
var init_functions = __esm({
  "node_modules/ol/functions.js"() {
    init_array();
  }
});

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}
var init_obj = __esm({
  "node_modules/ol/obj.js"() {
  }
});

// node_modules/ol/events/Target.js
var Target, Target_default;
var init_Target = __esm({
  "node_modules/ol/events/Target.js"() {
    init_Disposable();
    init_Event();
    init_functions();
    init_obj();
    Target = class extends Disposable_default {
      /**
       * @param {*} [target] Default event target for dispatched events.
       */
      constructor(target) {
        super();
        this.eventTarget_ = target;
        this.pendingRemovals_ = null;
        this.dispatching_ = null;
        this.listeners_ = null;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
          return;
        }
        const evt = isString ? new Event_default(event) : (
          /** @type {Event} */
          event
        );
        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for (let i = 0, ii = listeners.length; i < ii; ++i) {
          if ("handleEvent" in listeners[i]) {
            propagate = /** @type {import("../events.js").ListenerObject} */
            listeners[i].handleEvent(evt);
          } else {
            propagate = /** @type {import("../events.js").ListenerFunction} */
            listeners[i].call(this, evt);
          }
          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }
        if (--dispatching[type] === 0) {
          let pr = pendingRemovals[type];
          delete pendingRemovals[type];
          while (pr--) {
            this.removeEventListener(type, VOID);
          }
          delete dispatching[type];
        }
        return propagate;
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      getListeners(type) {
        return this.listeners_ && this.listeners_[type] || void 0;
      }
      /**
       * @param {string} [type] Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      hasListener(type) {
        if (!this.listeners_) {
          return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      removeEventListener(type, listener) {
        if (!this.listeners_) {
          return;
        }
        const listeners = this.listeners_[type];
        if (!listeners) {
          return;
        }
        const index = listeners.indexOf(listener);
        if (index !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    };
    Target_default = Target;
  }
});

// node_modules/ol/events/EventType.js
var EventType_default;
var init_EventType = __esm({
  "node_modules/ol/events/EventType.js"() {
    EventType_default = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: "change",
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: "error",
      BLUR: "blur",
      CLEAR: "clear",
      CONTEXTMENU: "contextmenu",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGENTER: "dragenter",
      DRAGOVER: "dragover",
      DROP: "drop",
      FOCUS: "focus",
      KEYDOWN: "keydown",
      KEYPRESS: "keypress",
      LOAD: "load",
      RESIZE: "resize",
      TOUCHMOVE: "touchmove",
      WHEEL: "wheel"
    };
  }
});

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
var init_events = __esm({
  "node_modules/ol/events.js"() {
    init_obj();
  }
});

// node_modules/ol/Observable.js
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
var Observable, Observable_default;
var init_Observable = __esm({
  "node_modules/ol/Observable.js"() {
    init_Target();
    init_EventType();
    init_events();
    Observable = class extends Target_default {
      constructor() {
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */
        this.unInternal;
        this.revision_ = 0;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      changed() {
        ++this.revision_;
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      getRevision() {
        return this.revision_;
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onInternal(type, listener) {
        if (Array.isArray(type)) {
          const len = type.length;
          const keys = new Array(len);
          for (let i = 0; i < len; ++i) {
            keys[i] = listen(this, type[i], listener);
          }
          return keys;
        }
        return listen(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
          const len = type.length;
          key = new Array(len);
          for (let i = 0; i < len; ++i) {
            key[i] = listenOnce(this, type[i], listener);
          }
        } else {
          key = listenOnce(
            this,
            /** @type {string} */
            type,
            listener
          );
        }
        listener.ol_key = key;
        return key;
      }
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @protected
       */
      unInternal(type, listener) {
        const key = (
          /** @type {Object} */
          listener.ol_key
        );
        if (key) {
          unByKey(key);
        } else if (Array.isArray(type)) {
          for (let i = 0, ii = type.length; i < ii; ++i) {
            this.removeEventListener(type[i], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    };
    Observable.prototype.on;
    Observable.prototype.once;
    Observable.prototype.un;
    Observable_default = Observable;
  }
});

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var uidCounter_, VERSION;
var init_util = __esm({
  "node_modules/ol/util.js"() {
    uidCounter_ = 0;
    VERSION = "9.2.4";
  }
});

// node_modules/ol/Object.js
var ObjectEvent, BaseObject, Object_default;
var init_Object = __esm({
  "node_modules/ol/Object.js"() {
    init_Event();
    init_ObjectEventType();
    init_Observable();
    init_util();
    init_obj();
    ObjectEvent = class extends Event_default {
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      constructor(type, key, oldValue) {
        super(type);
        this.key = key;
        this.oldValue = oldValue;
      }
    };
    BaseObject = class extends Observable_default {
      /**
       * @param {Object<string, *>} [values] An object with key-value pairs.
       */
      constructor(values) {
        super();
        this.on;
        this.once;
        this.un;
        getUid(this);
        this.values_ = null;
        if (values !== void 0) {
          this.setProperties(values);
        }
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) {
          value = this.values_[key];
        }
        return value;
      }
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.values_;
      }
      /**
       * @return {boolean} The object has properties.
       */
      hasProperties() {
        return !!this.values_;
      }
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
        eventType = ObjectEventType_default.PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
      }
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) {
          values[key] = value;
        } else {
          const oldValue = values[key];
          values[key] = value;
          if (oldValue !== value) {
            this.notify(key, oldValue);
          }
        }
      }
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      setProperties(values, silent) {
        for (const key in values) {
          this.set(key, values[key], silent);
        }
      }
      /**
       * Apply any properties from another object without triggering events.
       * @param {BaseObject} source The source object.
       * @protected
       */
      applyProperties(source) {
        if (!source.values_) {
          return;
        }
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
      }
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean} [silent] Unset without triggering an event.
       * @api
       */
      unset(key, silent) {
        if (this.values_ && key in this.values_) {
          const oldValue = this.values_[key];
          delete this.values_[key];
          if (isEmpty(this.values_)) {
            this.values_ = null;
          }
          if (!silent) {
            this.notify(key, oldValue);
          }
        }
      }
    };
    Object_default = BaseObject;
  }
});

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default;
var init_CollectionEventType = __esm({
  "node_modules/ol/CollectionEventType.js"() {
    CollectionEventType_default = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: "add",
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: "remove"
    };
  }
});

// node_modules/ol/Collection.js
var Property, CollectionEvent, Collection, Collection_default;
var init_Collection = __esm({
  "node_modules/ol/Collection.js"() {
    init_Object();
    init_CollectionEventType();
    init_Event();
    Property = {
      LENGTH: "length"
    };
    CollectionEvent = class extends Event_default {
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {T} element Element.
       * @param {number} index The index of the added or removed element.
       */
      constructor(type, element, index) {
        super(type);
        this.element = element;
        this.index = index;
      }
    };
    Collection = class extends Object_default {
      /**
       * @param {Array<T>} [array] Array.
       * @param {Options} [options] Collection options.
       */
      constructor(array, options) {
        super();
        this.on;
        this.once;
        this.un;
        options = options || {};
        this.unique_ = !!options.unique;
        this.array_ = array ? array : [];
        if (this.unique_) {
          for (let i = 0, ii = this.array_.length; i < ii; ++i) {
            this.assertUnique_(this.array_[i], i);
          }
        }
        this.updateLength_();
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      clear() {
        while (this.getLength() > 0) {
          this.pop();
        }
      }
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      extend(arr) {
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          this.push(arr[i]);
        }
        return this;
      }
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      forEach(f) {
        const array = this.array_;
        for (let i = 0, ii = array.length; i < ii; ++i) {
          f(array[i], i, array);
        }
      }
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      getArray() {
        return this.array_;
      }
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      item(index) {
        return this.array_[index];
      }
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      getLength() {
        return this.get(Property.LENGTH);
      }
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      pop() {
        return this.removeAt(this.getLength() - 1);
      }
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      push(elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
      }
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      remove(elem) {
        const arr = this.array_;
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          if (arr[i] === elem) {
            return this.removeAt(i);
          }
        }
        return void 0;
      }
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      removeAt(index) {
        if (index < 0 || index >= this.getLength()) {
          return void 0;
        }
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        return prev;
      }
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
          this.insertAt(index, elem);
          return;
        }
        if (index < 0) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem, index);
        }
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      /**
       * @private
       */
      updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
      }
      /**
       * @private
       * @param {T} elem Element.
       * @param {number} [except] Optional index to ignore.
       */
      assertUnique_(elem, except) {
        for (let i = 0, ii = this.array_.length; i < ii; ++i) {
          if (this.array_[i] === elem && i !== except) {
            throw new Error("Duplicate item added to a unique collection");
          }
        }
      }
    };
    Collection_default = Collection;
  }
});

// node_modules/ol/layer/Property.js
var Property_default;
var init_Property = __esm({
  "node_modules/ol/layer/Property.js"() {
    Property_default = {
      OPACITY: "opacity",
      VISIBLE: "visible",
      EXTENT: "extent",
      Z_INDEX: "zIndex",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution",
      MAX_ZOOM: "maxZoom",
      MIN_ZOOM: "minZoom",
      SOURCE: "source",
      MAP: "map"
    };
  }
});

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
var init_asserts = __esm({
  "node_modules/ol/asserts.js"() {
  }
});

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n = mat.length;
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
function round(n, decimals) {
  return Math.round(toFixed(n, decimals));
}
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}
var init_math = __esm({
  "node_modules/ol/math.js"() {
  }
});

// node_modules/ol/layer/Base.js
var BaseLayer, Base_default;
var init_Base = __esm({
  "node_modules/ol/layer/Base.js"() {
    init_Object();
    init_Property();
    init_util();
    init_asserts();
    init_math();
    BaseLayer = class extends Object_default {
      /**
       * @param {Options} options Layer options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        this.background_ = options.background;
        const properties = Object.assign({}, options);
        if (typeof options.properties === "object") {
          delete properties.properties;
          Object.assign(properties, options.properties);
        }
        properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
        assert(
          typeof properties[Property_default.OPACITY] === "number",
          "Layer opacity must be a number"
        );
        properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
        properties[Property_default.Z_INDEX] = options.zIndex;
        properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
        properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
        properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
        properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
        this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        this.state_ = null;
      }
      /**
       * Get the background for this layer.
       * @return {BackgroundColor|false} Layer background.
       */
      getBackground() {
        return this.background_;
      }
      /**
       * @return {string} CSS class name.
       */
      getClassName() {
        return this.className_;
      }
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean} [managed] Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      getLayerState(managed) {
        const state = this.state_ || /** @type {?} */
        {
          layer: this,
          managed: managed === void 0 ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        return abstract();
      }
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      getExtent() {
        return (
          /** @type {import("../extent.js").Extent|undefined} */
          this.get(Property_default.EXTENT)
        );
      }
      /**
       * Return the maximum resolution of the layer. Returns Infinity if
       * the layer has no maximum resolution set.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      getMaxResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_RESOLUTION)
        );
      }
      /**
       * Return the minimum resolution of the layer. Returns 0 if
       * the layer has no minimum resolution set.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      getMinResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_RESOLUTION)
        );
      }
      /**
       * Return the minimum zoom level of the layer. Returns -Infinity if
       * the layer has no minimum zoom set.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_ZOOM)
        );
      }
      /**
       * Return the maximum zoom level of the layer. Returns Infinity if
       * the layer has no maximum zoom set.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_ZOOM)
        );
      }
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      getOpacity() {
        return (
          /** @type {number} */
          this.get(Property_default.OPACITY)
        );
      }
      /**
       * @abstract
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        return abstract();
      }
      /**
       * Return the value of this layer's `visible` property. To find out whether the layer
       * is visible on a map, use `isVisible()` instead.
       * @return {boolean} The value of the `visible` property of the layer.
       * @observable
       * @api
       */
      getVisible() {
        return (
          /** @type {boolean} */
          this.get(Property_default.VISIBLE)
        );
      }
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. Returns undefined if the layer is unmanaged.
       * @return {number|undefined} The Z-index of the layer.
       * @observable
       * @api
       */
      getZIndex() {
        return (
          /** @type {number|undefined} */
          this.get(Property_default.Z_INDEX)
        );
      }
      /**
       * Sets the background color.
       * @param {BackgroundColor} [background] Background color.
       */
      setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      setExtent(extent) {
        this.set(Property_default.EXTENT, extent);
      }
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      setMaxResolution(maxResolution) {
        this.set(Property_default.MAX_RESOLUTION, maxResolution);
      }
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      setMinResolution(minResolution) {
        this.set(Property_default.MIN_RESOLUTION, minResolution);
      }
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      setMaxZoom(maxZoom) {
        this.set(Property_default.MAX_ZOOM, maxZoom);
      }
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      setMinZoom(minZoom) {
        this.set(Property_default.MIN_ZOOM, minZoom);
      }
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      setOpacity(opacity) {
        assert(typeof opacity === "number", "Layer opacity must be a number");
        this.set(Property_default.OPACITY, opacity);
      }
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      setVisible(visible) {
        this.set(Property_default.VISIBLE, visible);
      }
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      setZIndex(zindex) {
        this.set(Property_default.Z_INDEX, zindex);
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }
        super.disposeInternal();
      }
    };
    Base_default = BaseLayer;
  }
});

// node_modules/ol/render/EventType.js
var EventType_default2;
var init_EventType2 = __esm({
  "node_modules/ol/render/EventType.js"() {
    EventType_default2 = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: "prerender",
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered before layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: "precompose",
      /**
       * Triggered after layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: "postcompose",
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: "rendercomplete"
    };
  }
});

// node_modules/ol/ViewHint.js
var ViewHint_default;
var init_ViewHint = __esm({
  "node_modules/ol/ViewHint.js"() {
    ViewHint_default = {
      ANIMATING: 0,
      INTERACTING: 1
    };
  }
});

// node_modules/ol/ViewProperty.js
var ViewProperty_default;
var init_ViewProperty = __esm({
  "node_modules/ol/ViewProperty.js"() {
    ViewProperty_default = {
      CENTER: "center",
      RESOLUTION: "resolution",
      ROTATION: "rotation"
    };
  }
});

// node_modules/ol/tilegrid/common.js
var DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE;
var init_common = __esm({
  "node_modules/ol/tilegrid/common.js"() {
    DEFAULT_MAX_ZOOM = 42;
    DEFAULT_TILE_SIZE = 256;
  }
});

// node_modules/ol/proj/Units.js
function fromCode(code) {
  return unitByCode[code];
}
var unitByCode, METERS_PER_UNIT;
var init_Units = __esm({
  "node_modules/ol/proj/Units.js"() {
    unitByCode = {
      "9001": "m",
      "9002": "ft",
      "9003": "us-ft",
      "9101": "radians",
      "9102": "degrees"
    };
    METERS_PER_UNIT = {
      // use the radius of the Normal sphere
      "radians": 6370997 / (2 * Math.PI),
      "degrees": 2 * Math.PI * 6370997 / 360,
      "ft": 0.3048,
      "m": 1,
      "us-ft": 1200 / 3937
    };
  }
});

// node_modules/ol/proj/Projection.js
var Projection, Projection_default;
var init_Projection = __esm({
  "node_modules/ol/proj/Projection.js"() {
    init_Units();
    Projection = class {
      /**
       * @param {Options} options Projection options.
       */
      constructor(options) {
        this.code_ = options.code;
        this.units_ = /** @type {import("./Units.js").Units} */
        options.units;
        this.extent_ = options.extent !== void 0 ? options.extent : null;
        this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
        this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
        this.global_ = options.global !== void 0 ? options.global : false;
        this.canWrapX_ = !!(this.global_ && this.extent_);
        this.getPointResolutionFunc_ = options.getPointResolution;
        this.defaultTileGrid_ = null;
        this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      canWrapX() {
        return this.canWrapX_;
      }
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      getCode() {
        return this.code_;
      }
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        return this.extent_;
      }
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").Units} Units.
       * @api
       */
      getUnits() {
        return this.units_;
      }
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      getMetersPerUnit() {
        return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      }
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getWorldExtent() {
        return this.worldExtent_;
      }
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      getAxisOrientation() {
        return this.axisOrientation_;
      }
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      isGlobal() {
        return this.global_;
      }
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
      }
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      getDefaultTileGrid() {
        return this.defaultTileGrid_;
      }
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
      }
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
      }
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
      }
      /**
       * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
      }
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
       * resolution function (if set).
       */
      getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
      }
    };
    Projection_default = Projection;
  }
});

// node_modules/ol/proj/epsg3857.js
function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}
var RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, MAX_SAFE_Y, EPSG3857Projection, PROJECTIONS;
var init_epsg3857 = __esm({
  "node_modules/ol/proj/epsg3857.js"() {
    init_Projection();
    RADIUS = 6378137;
    HALF_SIZE = Math.PI * RADIUS;
    EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
    WORLD_EXTENT = [-180, -85, 180, 85];
    MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
    EPSG3857Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       */
      constructor(code) {
        super({
          code,
          units: "m",
          extent: EXTENT,
          global: true,
          worldExtent: WORLD_EXTENT,
          getPointResolution: function(resolution, point) {
            return resolution / Math.cosh(point[1] / RADIUS);
          }
        });
      }
    };
    PROJECTIONS = [
      new EPSG3857Projection("EPSG:3857"),
      new EPSG3857Projection("EPSG:102100"),
      new EPSG3857Projection("EPSG:102113"),
      new EPSG3857Projection("EPSG:900913"),
      new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
      new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
    ];
  }
});

// node_modules/ol/proj/epsg4326.js
var RADIUS2, EXTENT2, METERS_PER_UNIT2, EPSG4326Projection, PROJECTIONS2;
var init_epsg4326 = __esm({
  "node_modules/ol/proj/epsg4326.js"() {
    init_Projection();
    RADIUS2 = 6378137;
    EXTENT2 = [-180, -90, 180, 90];
    METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
    EPSG4326Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       * @param {string} [axisOrientation] Axis orientation.
       */
      constructor(code, axisOrientation) {
        super({
          code,
          units: "degrees",
          extent: EXTENT2,
          axisOrientation,
          global: true,
          metersPerUnit: METERS_PER_UNIT2,
          worldExtent: EXTENT2
        });
      }
    };
    PROJECTIONS2 = [
      new EPSG4326Projection("CRS:84"),
      new EPSG4326Projection("EPSG:4326", "neu"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
      new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
    ];
  }
});

// node_modules/ol/proj/projections.js
function clear2() {
  cache = {};
}
function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add(code, projection) {
  cache[code] = projection;
}
var cache;
var init_projections = __esm({
  "node_modules/ol/proj/projections.js"() {
    cache = {};
  }
});

// node_modules/ol/proj/transforms.js
function clear3() {
  transforms = {};
}
function add2(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function remove2(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  const transform2 = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (isEmpty(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform2;
}
function get2(sourceCode, destinationCode) {
  let transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}
var transforms;
var init_transforms = __esm({
  "node_modules/ol/proj/transforms.js"() {
    init_obj();
    transforms = {};
  }
});

// node_modules/ol/extent/Relationship.js
var Relationship_default;
var init_Relationship = __esm({
  "node_modules/ol/extent/Relationship.js"() {
    Relationship_default = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16
    };
  }
});

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value
  ];
}
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromCoordinates(coordinates2, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendCoordinates(extent, coordinates2);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset2, end, stride);
}
function createOrUpdateFromRings(rings, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendRings(extent, rings);
}
function equals2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendCoordinates(extent, coordinates2) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function extendFlatCoordinates(extent, flatCoordinates, offset2, end, stride) {
  for (; offset2 < end; offset2 += stride) {
    extendXY(extent, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
  }
  return extent;
}
function extendRings(extent, rings) {
  for (let i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty2(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    throw new Error("Invalid corner");
  }
  return coordinate;
}
function getEnlargedArea(extent1, extent2) {
  const minX = Math.min(extent1[0], extent2[0]);
  const minY = Math.min(extent1[1], extent2[1]);
  const maxX = Math.max(extent1[2], extent2[2]);
  const maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersectionArea(extent1, extent2) {
  const intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty2(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function scaleFromCenter(extent, value) {
  const deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  const deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}
function intersectsSegment(extent, start, end) {
  let intersects3 = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects3 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
    if (!intersects3 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
  }
  return intersects3;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty2(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates2.push(
        extent[0] + width * i / stops,
        extent[1],
        extent[2],
        extent[1] + height * i / stops,
        extent[2] - width * i / stops,
        extent[3],
        extent[0],
        extent[3] - height * i / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates2.length; i < l; i += 2) {
    xs.push(coordinates2[i]);
    ys.push(coordinates2[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset2 = worldsAway * worldWidth;
    extent[0] -= offset2;
    extent[2] -= offset2;
  }
  return extent;
}
function wrapAndSliceX(extent, projection, multiWorld) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth && !multiWorld) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}
var init_extent = __esm({
  "node_modules/ol/extent.js"() {
    init_Relationship();
  }
});

// node_modules/ol/string.js
function padNumber(number, width, precision) {
  const numberString = precision !== void 0 ? number.toFixed(precision) : "" + number;
  let decimal = numberString.indexOf(".");
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join("0") + numberString;
}
function compareVersions(v1, v2) {
  const s1 = ("" + v1).split(".");
  const s2 = ("" + v2).split(".");
  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {
    const n1 = parseInt(s1[i] || "0", 10);
    const n2 = parseInt(s2[i] || "0", 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
}
var init_string = __esm({
  "node_modules/ol/string.js"() {
  }
});

// node_modules/ol/coordinate.js
function add3(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function closestOnCircle(coordinate, circle) {
  const r = circle.getRadius();
  const center = circle.getCenter();
  const x0 = center[0];
  const y0 = center[1];
  const x1 = coordinate[0];
  const y1 = coordinate[1];
  let dx = x1 - x0;
  const dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  const d = Math.sqrt(dx * dx + dy * dy);
  const x = x0 + r * dx / d;
  const y = y0 + r * dy / d;
  return [x, y];
}
function closestOnSegment(coordinate, segment) {
  const x0 = coordinate[0];
  const y0 = coordinate[1];
  const start = segment[0];
  const end = segment[1];
  const x1 = start[0];
  const y1 = start[1];
  const x2 = end[0];
  const y2 = end[1];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  let x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}
function createStringXY(fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function(coordinate) {
      return toStringXY(coordinate, fractionDigits);
    }
  );
}
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
  const normalizedDegrees = modulo(degrees + 180, 360) - 180;
  const x = Math.abs(3600 * normalizedDegrees);
  const decimals = fractionDigits || 0;
  let deg = Math.floor(x / 3600);
  let min = Math.floor((x - deg * 3600) / 60);
  let sec = toFixed(x - deg * 3600 - min * 60, decimals);
  if (sec >= 60) {
    sec = 0;
    min += 1;
  }
  if (min >= 60) {
    min = 0;
    deg += 1;
  }
  let hdms = deg + "\xB0";
  if (min !== 0 || sec !== 0) {
    hdms += " " + padNumber(min, 2) + "\u2032";
  }
  if (sec !== 0) {
    hdms += " " + padNumber(sec, 2, decimals) + "\u2033";
  }
  if (normalizedDegrees !== 0) {
    hdms += " " + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
  }
  return hdms;
}
function format(coordinate, template, fractionDigits) {
  if (coordinate) {
    return template.replace("{x}", coordinate[0].toFixed(fractionDigits)).replace("{y}", coordinate[1].toFixed(fractionDigits));
  }
  return "";
}
function equals3(coordinate1, coordinate2) {
  let equals4 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals4 = false;
      break;
    }
  }
  return equals4;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
function scale(coordinate, scale5) {
  coordinate[0] *= scale5;
  coordinate[1] *= scale5;
  return coordinate;
}
function squaredDistance2(coord1, coord2) {
  const dx = coord1[0] - coord2[0];
  const dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance2(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance2(coordinate, closestOnSegment(coordinate, segment));
}
function toStringHDMS(coordinate, fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS("NS", coordinate[1], fractionDigits) + " " + degreesToStringHDMS("EW", coordinate[0], fractionDigits);
  }
  return "";
}
function toStringXY(coordinate, fractionDigits) {
  return format(coordinate, "{x}, {y}", fractionDigits);
}
function wrapX2(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}
var init_coordinate = __esm({
  "node_modules/ol/coordinate.js"() {
    init_extent();
    init_math();
    init_string();
  }
});

// node_modules/ol/sphere.js
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function getLengthInternal(coordinates2, radius) {
  let length = 0;
  for (let i = 0, ii = coordinates2.length; i < ii - 1; ++i) {
    length += getDistance(coordinates2[i], coordinates2[i + 1], radius);
  }
  return length;
}
function getLength(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || "EPSG:3857";
  const type = geometry.getType();
  if (type !== "GeometryCollection") {
    geometry = geometry.clone().transform(projection, "EPSG:4326");
  }
  let length = 0;
  let coordinates2, coords, i, ii, j, jj;
  switch (type) {
    case "Point":
    case "MultiPoint": {
      break;
    }
    case "LineString":
    case "LinearRing": {
      coordinates2 = /** @type {import("./geom/SimpleGeometry.js").default} */
      geometry.getCoordinates();
      length = getLengthInternal(coordinates2, radius);
      break;
    }
    case "MultiLineString":
    case "Polygon": {
      coordinates2 = /** @type {import("./geom/SimpleGeometry.js").default} */
      geometry.getCoordinates();
      for (i = 0, ii = coordinates2.length; i < ii; ++i) {
        length += getLengthInternal(coordinates2[i], radius);
      }
      break;
    }
    case "MultiPolygon": {
      coordinates2 = /** @type {import("./geom/SimpleGeometry.js").default} */
      geometry.getCoordinates();
      for (i = 0, ii = coordinates2.length; i < ii; ++i) {
        coords = coordinates2[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case "GeometryCollection": {
      const geometries = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries()
      );
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return length;
}
function getAreaInternal(coordinates2, radius) {
  let area = 0;
  const len = coordinates2.length;
  let x1 = coordinates2[len - 1][0];
  let y1 = coordinates2[len - 1][1];
  for (let i = 0; i < len; i++) {
    const x2 = coordinates2[i][0];
    const y2 = coordinates2[i][1];
    area += toRadians(x2 - x1) * (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2;
}
function getArea2(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || "EPSG:3857";
  const type = geometry.getType();
  if (type !== "GeometryCollection") {
    geometry = geometry.clone().transform(projection, "EPSG:4326");
  }
  let area = 0;
  let coordinates2, coords, i, ii, j, jj;
  switch (type) {
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
    case "LinearRing": {
      break;
    }
    case "Polygon": {
      coordinates2 = /** @type {import("./geom/Polygon.js").default} */
      geometry.getCoordinates();
      area = Math.abs(getAreaInternal(coordinates2[0], radius));
      for (i = 1, ii = coordinates2.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates2[i], radius));
      }
      break;
    }
    case "MultiPolygon": {
      coordinates2 = /** @type {import("./geom/SimpleGeometry.js").default} */
      geometry.getCoordinates();
      for (i = 0, ii = coordinates2.length; i < ii; ++i) {
        coords = coordinates2[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case "GeometryCollection": {
      const geometries = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries()
      );
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea2(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return area;
}
function offset(c1, distance2, bearing, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lon1 = toRadians(c1[0]);
  const dByR = distance2 / radius;
  const lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)
  );
  const lon = lon1 + Math.atan2(
    Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
    Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)
  );
  return [toDegrees(lon), toDegrees(lat)];
}
var DEFAULT_RADIUS;
var init_sphere = __esm({
  "node_modules/ol/sphere.js"() {
    init_math();
    DEFAULT_RADIUS = 63710088e-1;
  }
});

// node_modules/ol/console.js
function setLevel(l) {
  level = levels[l];
}
function log(...args) {
  if (level > levels.info) {
    return;
  }
  console.log(...args);
}
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}
function error(...args) {
  if (level > levels.error) {
    return;
  }
  console.error(...args);
}
var levels, level;
var init_console = __esm({
  "node_modules/ol/console.js"() {
    levels = {
      info: 1,
      warn: 2,
      error: 3,
      none: 4
    };
    level = levels.info;
  }
});

// node_modules/ol/proj.js
var proj_exports = {};
__export(proj_exports, {
  METERS_PER_UNIT: () => METERS_PER_UNIT,
  Projection: () => Projection_default,
  addCommon: () => addCommon,
  addCoordinateTransforms: () => addCoordinateTransforms,
  addEquivalentProjections: () => addEquivalentProjections,
  addEquivalentTransforms: () => addEquivalentTransforms,
  addProjection: () => addProjection,
  addProjections: () => addProjections,
  clearAllProjections: () => clearAllProjections,
  clearUserProjection: () => clearUserProjection,
  cloneTransform: () => cloneTransform,
  createProjection: () => createProjection,
  createSafeCoordinateTransform: () => createSafeCoordinateTransform,
  createTransformFromCoordinateTransform: () => createTransformFromCoordinateTransform,
  disableCoordinateWarning: () => disableCoordinateWarning,
  equivalent: () => equivalent,
  fromLonLat: () => fromLonLat,
  fromUserCoordinate: () => fromUserCoordinate,
  fromUserExtent: () => fromUserExtent,
  fromUserResolution: () => fromUserResolution,
  get: () => get3,
  getPointResolution: () => getPointResolution,
  getTransform: () => getTransform,
  getTransformFromProjections: () => getTransformFromProjections,
  getUserProjection: () => getUserProjection,
  identityTransform: () => identityTransform,
  setUserProjection: () => setUserProjection,
  toLonLat: () => toLonLat,
  toUserCoordinate: () => toUserCoordinate,
  toUserExtent: () => toUserExtent,
  toUserResolution: () => toUserResolution,
  transform: () => transform,
  transformExtent: () => transformExtent,
  transformWithProjections: () => transformWithProjections,
  useGeographic: () => useGeographic
});
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, output) {
  if (output !== void 0 && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}
function addProjection(projection) {
  add(projection.getCode(), projection);
  add2(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get3(projectionLike) {
  return typeof projectionLike === "string" ? get(
    /** @type {string} */
    projectionLike
  ) : (
    /** @type {Projection} */
    projectionLike || null
  );
}
function getPointResolution(projection, resolution, point, units) {
  projection = get3(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get3("EPSG:4326")
      );
      if (toEPSG43262 === identityTransform && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add2(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add2(projection1, projection2, forwardTransform);
      add2(projection2, projection1, inverseTransform);
    });
  });
}
function clearAllProjections() {
  clear2();
  clear3();
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get3(defaultCode);
  }
  if (typeof projection === "string") {
    return get3(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(input, output, dimension) {
      const length = input.length;
      dimension = dimension !== void 0 ? dimension : 2;
      output = output !== void 0 ? output : new Array(length);
      for (let i = 0; i < length; i += dimension) {
        const point = coordTransform(input.slice(i, i + dimension));
        const pointLength = point.length;
        for (let j = 0, jj = dimension; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}
function addCoordinateTransforms(source, destination, forward, inverse) {
  const sourceProj = get3(source);
  const destProj = get3(destination);
  add2(
    sourceProj,
    destProj,
    createTransformFromCoordinateTransform(forward)
  );
  add2(
    destProj,
    sourceProj,
    createTransformFromCoordinateTransform(inverse)
  );
}
function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    "EPSG:4326",
    projection !== void 0 ? projection : "EPSG:3857"
  );
}
function toLonLat(coordinate, projection) {
  const lonLat = transform(
    coordinate,
    projection !== void 0 ? projection : "EPSG:3857",
    "EPSG:4326"
  );
  const lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = modulo(lon + 180, 360) - 180;
  }
  return lonLat;
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = get2(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  const sourceProjection = get3(source);
  const destinationProjection = get3(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
function transformWithProjections(point, sourceProjection, destinationProjection) {
  const transformFunc = getTransformFromProjections(
    sourceProjection,
    destinationProjection
  );
  return transformFunc(point);
}
function setUserProjection(projection) {
  userProjection = get3(projection);
}
function clearUserProjection() {
  userProjection = null;
}
function getUserProjection() {
  return userProjection;
}
function useGeographic() {
  setUserProjection("EPSG:4326");
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceMetersPerUnit = get3(sourceProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}
function fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }
  const destMetersPerUnit = get3(destProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return destMetersPerUnit && userMetersPerUnit ? resolution * userMetersPerUnit / destMetersPerUnit : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
  return function(coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = getWidth(sourceExtent);
      coord = coord.slice(0);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform2(coord);
    } else {
      transformed = transform2(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }
    return transformed;
  };
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
var showCoordinateWarning, userProjection;
var init_proj = __esm({
  "node_modules/ol/proj.js"() {
    init_Projection();
    init_epsg3857();
    init_epsg4326();
    init_Units();
    init_projections();
    init_transforms();
    init_extent();
    init_math();
    init_coordinate();
    init_sphere();
    init_console();
    showCoordinateWarning = true;
    userProjection = null;
    addCommon();
  }
});

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x = clamp(center[0], minX, maxX);
      let y = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}
function none(center) {
  return center;
}
var init_centerconstraint = __esm({
  "node_modules/ol/centerconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset2 = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset2
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}
var init_resolutionconstraint = __esm({
  "node_modules/ol/resolutionconstraint.js"() {
    init_math();
    init_extent();
    init_array();
  }
});

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n) {
  const theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    }
  );
}
var init_rotationconstraint = __esm({
  "node_modules/ol/rotationconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/easing.js
function easeIn(t) {
  return Math.pow(t, 3);
}
function easeOut(t) {
  return 1 - easeIn(1 - t);
}
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
  return t;
}
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  }
  return 1 - inAndOut(2 * (t - 0.5));
}
var init_easing = __esm({
  "node_modules/ol/easing.js"() {
  }
});

// node_modules/ol/transform.js
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function reset(transform2) {
  return set(transform2, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
  const a1 = transform1[0];
  const b1 = transform1[1];
  const c1 = transform1[2];
  const d1 = transform1[3];
  const e1 = transform1[4];
  const f1 = transform1[5];
  const a2 = transform2[0];
  const b2 = transform2[1];
  const c2 = transform2[2];
  const d2 = transform2[3];
  const e2 = transform2[4];
  const f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
function set(transform2, a, b, c, d, e, f) {
  transform2[0] = a;
  transform2[1] = b;
  transform2[2] = c;
  transform2[3] = d;
  transform2[4] = e;
  transform2[5] = f;
  return transform2;
}
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
function apply(transform2, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
  coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
  return coordinate;
}
function rotate2(transform2, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return multiply(transform2, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale2(transform2, x, y) {
  return multiply(transform2, set(tmp_, x, 0, 0, y, 0, 0));
}
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
function translate(transform2, dx, dy) {
  return multiply(transform2, set(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
function invert(source) {
  return makeInverse(source, source);
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
function toString(mat) {
  const transformString = "matrix(" + mat.map(
    (value, i) => Math.round(value * matrixPrecision[i]) / matrixPrecision[i]
  ).join(", ") + ")";
  return transformString;
}
var tmp_, matrixPrecision;
var init_transform = __esm({
  "node_modules/ol/transform.js"() {
    init_asserts();
    tmp_ = new Array(6);
    matrixPrecision = [1e6, 1e6, 1e6, 1e6, 2, 2];
  }
});

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset2, end, stride, transform2, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate3(flatCoordinates, offset2, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale3(flatCoordinates, offset2, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate2(flatCoordinates, offset2, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
var init_transform2 = __esm({
  "node_modules/ol/geom/flat/transform.js"() {
  }
});

// node_modules/ol/geom/Geometry.js
var tmpTransform, Geometry, Geometry_default;
var init_Geometry = __esm({
  "node_modules/ol/geom/Geometry.js"() {
    init_Object();
    init_util();
    init_transform();
    init_extent();
    init_proj();
    init_functions();
    init_transform2();
    tmpTransform = create();
    Geometry = class extends Object_default {
      constructor() {
        super();
        this.extent_ = createEmpty();
        this.extentRevision_ = -1;
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = 0;
        this.simplifyTransformedInternal = memoizeOne(
          (revision, squaredTolerance, transform2) => {
            if (!transform2) {
              return this.getSimplifiedGeometry(squaredTolerance);
            }
            const clone2 = this.clone();
            clone2.applyTransform(transform2);
            return clone2.getSimplifiedGeometry(squaredTolerance);
          }
        );
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform2) {
        return this.simplifyTransformedInternal(
          this.getRevision(),
          squaredTolerance,
          transform2
        );
      }
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      clone() {
        return abstract();
      }
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        return abstract();
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        const coord = this.getClosestPoint([x, y]);
        return coord[0] === x && coord[1] === y;
      }
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
      }
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
      }
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return abstract();
      }
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
          const extent2 = this.computeExtent(this.extent_);
          if (isNaN(extent2[0]) || isNaN(extent2[1])) {
            createOrUpdateEmpty(extent2);
          }
          this.extentRevision_ = this.getRevision();
        }
        return returnOrUpdate(this.extent_, extent);
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        abstract();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        abstract();
      }
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return abstract();
      }
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {Type} Geometry type.
       */
      getType() {
        return abstract();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      applyTransform(transformFn) {
        abstract();
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      intersectsExtent(extent) {
        return abstract();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        abstract();
      }
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {this} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      transform(source, destination) {
        const sourceProj = get3(source);
        const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
          const pixelExtent = sourceProj.getExtent();
          const projectedExtent = sourceProj.getWorldExtent();
          const scale5 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform,
            projectedExtent[0],
            projectedExtent[3],
            scale5,
            -scale5,
            0,
            0,
            0
          );
          transform2D(
            inCoordinates,
            0,
            inCoordinates.length,
            stride,
            tmpTransform,
            outCoordinates
          );
          return getTransform(sourceProj, destination)(
            inCoordinates,
            outCoordinates,
            stride
          );
        } : getTransform(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
      }
    };
    Geometry_default = Geometry;
  }
});

// node_modules/ol/geom/SimpleGeometry.js
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
function transformGeom2D(simpleGeometry, transform2, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return transform2D(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform2,
    dest
  );
}
var SimpleGeometry, SimpleGeometry_default;
var init_SimpleGeometry = __esm({
  "node_modules/ol/geom/SimpleGeometry.js"() {
    init_Geometry();
    init_util();
    init_extent();
    init_transform2();
    SimpleGeometry = class extends Geometry_default {
      constructor() {
        super();
        this.layout = "XY";
        this.stride = 2;
        this.flatCoordinates;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return createOrUpdateFromFlatCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent
        );
      }
      /**
       * @abstract
       * @return {Array<*> | null} Coordinates.
       */
      getCoordinates() {
        return abstract();
      }
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getFlatCoordinates() {
        return this.flatCoordinates;
      }
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      getLastCoordinate() {
        return this.flatCoordinates.slice(
          this.flatCoordinates.length - this.stride
        );
      }
      /**
       * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
       * @return {import("./Geometry.js").GeometryLayout} Layout.
       * @api
       */
      getLayout() {
        return this.layout;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
          return simplifiedGeometry;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride;
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
      }
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      setCoordinates(coordinates2, layout) {
        abstract();
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      setLayout(layout, coordinates2, nesting) {
        let stride;
        if (layout) {
          stride = getStrideForLayout(layout);
        } else {
          for (let i = 0; i < nesting; ++i) {
            if (coordinates2.length === 0) {
              this.layout = "XY";
              this.stride = 2;
              return;
            }
            coordinates2 = /** @type {Array<unknown>} */
            coordinates2[0];
          }
          stride = coordinates2.length;
          layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */
      applyTransform(transformFn) {
        if (this.flatCoordinates) {
          transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
          this.changed();
        }
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          rotate3(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            angle,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        if (sy === void 0) {
          sy = sx;
        }
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          scale3(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            sx,
            sy,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          translate2(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            deltaX,
            deltaY,
            flatCoordinates
          );
          this.changed();
        }
      }
    };
    SimpleGeometry_default = SimpleGeometry;
  }
});

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset3;
  if (dx === 0 && dy === 0) {
    offset3 = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset3 = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset3 = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset3 + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset2, end, stride, max) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset2, end, stride, max);
    offset2 = end;
  }
  return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset2, endss, stride, max) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max);
    offset2 = ends[ends.length - 1];
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset2 == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance3;
  if (maxDelta === 0) {
    squaredDistance3 = squaredDistance(
      x,
      y,
      flatCoordinates[offset2],
      flatCoordinates[offset2 + 1]
    );
    if (squaredDistance3 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset2 + i];
      }
      closestPoint.length = stride;
      return squaredDistance3;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset2 + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance3 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance3) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset2,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance3 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset2,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset2 = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset2, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset2,
      ends,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset2 = ends[ends.length - 1];
  }
  return minSquaredDistance;
}
var init_closest = __esm({
  "node_modules/ol/geom/flat/closest.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset2, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset2++] = coordinate[i];
  }
  return offset2;
}
function deflateCoordinates(flatCoordinates, offset2, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset2++] = coordinate[j];
    }
  }
  return offset2;
}
function deflateCoordinatesArray(flatCoordinates, offset2, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset2,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset2 = end;
  }
  ends.length = i;
  return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset2, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  let i = 0;
  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset2,
      coordinatesss[j],
      stride,
      endss[i]
    );
    if (ends.length === 0) {
      ends[0] = offset2;
    }
    endss[i++] = ends;
    offset2 = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}
var init_deflate = __esm({
  "node_modules/ol/geom/flat/deflate.js"() {
  }
});

// node_modules/ol/geom/flat/simplify.js
function simplifyLineString(flatCoordinates, offset2, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {
  simplifiedFlatCoordinates = simplifiedFlatCoordinates !== void 0 ? simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(
      flatCoordinates,
      offset2,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    flatCoordinates = simplifiedFlatCoordinates;
    offset2 = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(
    flatCoordinates,
    offset2,
    end,
    stride,
    squaredTolerance,
    simplifiedFlatCoordinates,
    0
  );
  return simplifiedFlatCoordinates;
}
function douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset2) / stride;
  if (n < 3) {
    for (; offset2 < end; offset2 += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset2, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance3 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance3 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance3;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset2) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset2, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset2,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function douglasPeuckerMultiArray(flatCoordinates, offset2, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    const simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset2 = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
function radialDistance(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset2 + stride) {
    for (; offset2 < end; offset2 += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
    }
    return simplifiedOffset;
  }
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2 = x1;
  let y2 = y1;
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    x2 = flatCoordinates[offset2];
    y2 = flatCoordinates[offset2 + 1];
    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset2 == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset2], tolerance);
  let y1 = snap(flatCoordinates[offset2 + 1], tolerance);
  offset2 += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset2], tolerance);
    y2 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (offset2 == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset2 < end) {
    const x3 = snap(flatCoordinates[offset2], tolerance);
    const y3 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset2,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset2, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset2 = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
var init_simplify = __esm({
  "node_modules/ol/geom/flat/simplify.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset2, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset2,
      end,
      stride,
      coordinatess[i]
    );
    offset2 = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset2, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset2 ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      coordinatesss[i]
    );
    offset2 = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}
var init_inflate = __esm({
  "node_modules/ol/geom/flat/inflate.js"() {
  }
});

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset2, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset2, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset2, end, stride);
    offset2 = end;
  }
  return area;
}
function linearRingss(flatCoordinates, offset2, endss, stride) {
  let area = 0;
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    area += linearRings(flatCoordinates, offset2, ends, stride);
    offset2 = ends[ends.length - 1];
  }
  return area;
}
var init_area = __esm({
  "node_modules/ol/geom/flat/area.js"() {
  }
});

// node_modules/ol/geom/LinearRing.js
var LinearRing, LinearRing_default;
var init_LinearRing = __esm({
  "node_modules/ol/geom/LinearRing.js"() {
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_simplify();
    init_inflate();
    init_area();
    LinearRing = class _LinearRing extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       */
      clone() {
        return new _LinearRing(this.flatCoordinates.slice(), this.layout);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRing(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LinearRing(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "LinearRing";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return false;
      }
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LinearRing_default = LinearRing;
  }
});

// node_modules/ol/geom/Point.js
var Point_exports = {};
__export(Point_exports, {
  default: () => Point_default
});
var Point, Point_default;
var init_Point = __esm({
  "node_modules/ol/geom/Point.js"() {
    init_SimpleGeometry();
    init_extent();
    init_deflate();
    init_math();
    Point = class _Point extends SimpleGeometry_default {
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.setCoordinates(coordinates2, layout);
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       */
      clone() {
        const point = new _Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance3 = squaredDistance(
          x,
          y,
          flatCoordinates[0],
          flatCoordinates[1]
        );
        if (squaredDistance3 < minSquaredDistance) {
          const stride = this.stride;
          for (let i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[i];
          }
          closestPoint.length = stride;
          return squaredDistance3;
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       */
      getCoordinates() {
        return this.flatCoordinates.slice();
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "Point";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      }
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinate(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    Point_default = Point;
  }
});

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset2, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset2,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset2, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset2, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}
function linearRingssContainsXY(flatCoordinates, offset2, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}
var init_contains = __esm({
  "node_modules/ol/geom/flat/contains.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset2; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset2, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints
    );
    offset2 = ends[ends.length - 1];
  }
  return interiorPoints;
}
var init_interiorpoint = __esm({
  "node_modules/ol/geom/flat/interiorpoint.js"() {
    init_array();
    init_contains();
  }
});

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset2, end, stride, callback) {
  let ret;
  offset2 += stride;
  for (; offset2 < end; offset2 += stride) {
    ret = callback(
      flatCoordinates.slice(offset2 - stride, offset2),
      flatCoordinates.slice(offset2, offset2 + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}
var init_segments = __esm({
  "node_modules/ol/geom/flat/segments.js"() {
  }
});

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset2, end, stride, extent) {
  const coordinatesExtent = extendFlatCoordinates(
    createEmpty(),
    flatCoordinates,
    offset2,
    end,
    stride
  );
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset2,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLineStringArray(flatCoordinates, offset2, ends, stride, extent) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset2, ends[i], stride, extent)) {
      return true;
    }
    offset2 = ends[i];
  }
  return false;
}
function intersectsLinearRing(flatCoordinates, offset2, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset2, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset2, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset2, endss, stride, extent) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}
var init_intersectsextent = __esm({
  "node_modules/ol/geom/flat/intersectsextent.js"() {
    init_extent();
    init_segments();
    init_contains();
  }
});

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset2, end, stride) {
  while (offset2 < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset2 + i];
      flatCoordinates[offset2 + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset2 += stride;
    end -= stride;
  }
}
var init_reverse = __esm({
  "node_modules/ol/geom/flat/reverse.js"() {
  }
});

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset2, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset2,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset2 = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset2, endss, stride, right) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset2 = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset2,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset2, end, stride);
    }
    offset2 = end;
  }
  return offset2;
}
function orientLinearRingsArray(flatCoordinates, offset2, endss, stride, right) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    offset2 = orientLinearRings(
      flatCoordinates,
      offset2,
      endss[i],
      stride,
      right
    );
  }
  return offset2;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset2 = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const orientation = linearRingIsClockwise(flatCoordinates, offset2, end, 2);
    if (startOrientation === void 0) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset2 = end;
  }
  return endss;
}
var init_orient = __esm({
  "node_modules/ol/geom/flat/orient.js"() {
    init_reverse();
  }
});

// node_modules/ol/geom/Polygon.js
function circular(center, radius, n, sphereRadius) {
  n = n ? n : 32;
  const flatCoordinates = [];
  for (let i = 0; i < n; ++i) {
    extend(
      flatCoordinates,
      offset(center, radius, 2 * Math.PI * i / n, sphereRadius)
    );
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
function fromExtent(extent) {
  if (isEmpty2(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
function fromCircle(circle, sides, angle) {
  sides = sides ? sides : 32;
  const stride = circle.getStride();
  const layout = circle.getLayout();
  const center = circle.getCenter();
  const arrayLength = stride * (sides + 1);
  const flatCoordinates = new Array(arrayLength);
  for (let i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (let j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  const ends = [flatCoordinates.length];
  const polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), angle);
  return polygon;
}
function makeRegular(polygon, center, radius, angle) {
  const flatCoordinates = polygon.getFlatCoordinates();
  const stride = polygon.getStride();
  const sides = flatCoordinates.length / stride - 1;
  const startAngle = angle ? angle : 0;
  for (let i = 0; i <= sides; ++i) {
    const offset2 = i * stride;
    const angle2 = startAngle + modulo(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset2] = center[0] + radius * Math.cos(angle2);
    flatCoordinates[offset2 + 1] = center[1] + radius * Math.sin(angle2);
  }
  polygon.changed();
}
var Polygon, Polygon_default;
var init_Polygon = __esm({
  "node_modules/ol/geom/Polygon.js"() {
    init_LinearRing();
    init_Point();
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_array();
    init_interiorpoint();
    init_inflate();
    init_intersectsextent();
    init_orient();
    init_area();
    init_contains();
    init_math();
    init_simplify();
    init_sphere();
    Polygon = class _Polygon extends SimpleGeometry_default {
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.flatInteriorPointRevision_ = -1;
        this.flatInteriorPoint_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      appendLinearRing(linearRing2) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
        } else {
          extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       */
      clone() {
        const polygon = new _Polygon(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        polygon.applyProperties(this);
        return polygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        return linearRingsContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          x,
          y
        );
      }
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRings(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * @return {Array<number>} Interior point.
       */
      getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoint_ = getInteriorPointOfArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride,
            flatCenter,
            0
          );
          this.flatInteriorPointRevision_ = this.getRevision();
        }
        return (
          /** @type {import("../coordinate.js").Coordinate} */
          this.flatInteriorPoint_
        );
      }
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoint() {
        return new Point_default(this.getFlatInteriorPoint(), "XYM");
      }
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      getLinearRingCount() {
        return this.ends_.length;
      }
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing|null} Linear ring.
       * @api
       */
      getLinearRing(index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }
        return new LinearRing_default(
          this.flatCoordinates.slice(
            index === 0 ? 0 : this.ends_[index - 1],
            this.ends_[index]
          ),
          this.layout
        );
      }
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings2 = [];
        let offset2 = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const linearRing2 = new LinearRing_default(
            flatCoordinates.slice(offset2, end),
            layout
          );
          linearRings2.push(linearRing2);
          offset2 = end;
        }
        return linearRings2;
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRings(
              this.orientedFlatCoordinates_,
              0,
              this.ends_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = quantizeArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "Polygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLinearRingArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    Polygon_default = Polygon;
  }
});

// node_modules/ol/View.js
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var DEFAULT_MIN_ZOOM, View, View_default;
var init_View = __esm({
  "node_modules/ol/View.js"() {
    init_Object();
    init_ViewHint();
    init_ViewProperty();
    init_common();
    init_proj();
    init_functions();
    init_coordinate();
    init_asserts();
    init_centerconstraint();
    init_math();
    init_resolutionconstraint();
    init_rotationconstraint();
    init_easing();
    init_extent();
    init_array();
    init_Polygon();
    DEFAULT_MIN_ZOOM = 0;
    View = class extends Object_default {
      /**
       * @param {ViewOptions} [options] View options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        options = Object.assign({}, options);
        this.hints_ = [0, 0];
        this.animations_ = [];
        this.updateAnimationKey_;
        this.projection_ = createProjection(options.projection, "EPSG:3857");
        this.viewportSize_ = [100, 100];
        this.targetCenter_ = null;
        this.targetResolution_;
        this.targetRotation_;
        this.nextCenter_ = null;
        this.nextResolution_;
        this.nextRotation_;
        this.cancelAnchor_ = void 0;
        if (options.projection) {
          disableCoordinateWarning();
        }
        if (options.center) {
          options.center = fromUserCoordinate(options.center, this.projection_);
        }
        if (options.extent) {
          options.extent = fromUserExtent(options.extent, this.projection_);
        }
        this.applyOptions_(options);
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      applyOptions_(options) {
        const properties = Object.assign({}, options);
        for (const key in ViewProperty_default) {
          delete properties[key];
        }
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        this.minResolution_ = resolutionConstraintInfo.minResolution;
        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        this.resolutions_ = options.resolutions;
        this.padding_ = options.padding;
        this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        this.constraints_ = {
          center: centerConstraint,
          resolution: resolutionConstraint,
          rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
        this.setCenterInternal(
          options.center !== void 0 ? options.center : null
        );
        if (options.resolution !== void 0) {
          this.setResolution(options.resolution);
        } else if (options.zoom !== void 0) {
          this.setZoom(options.zoom);
        }
      }
      /**
       * Padding (in css pixels).
       * If the map viewport is partially covered with other content (overlays) along
       * its edges, this setting allows to shift the center of the viewport away from that
       * content. The order of the values in the array is top, right, bottom, left.
       * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
       * @type {Array<number>|undefined}
       * @api
       */
      get padding() {
        return this.padding_;
      }
      set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
          const newPadding = padding || [0, 0, 0, 0];
          oldPadding = oldPadding || [0, 0, 0, 0];
          const resolution = this.getResolution();
          const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
          const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
          this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
        }
      }
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        if (options.resolution !== void 0) {
          options.resolution = this.getResolution();
        } else {
          options.zoom = this.getZoom();
        }
        options.center = this.getCenterInternal();
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
      }
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      animate(var_args) {
        if (this.isDef() && !this.getAnimating()) {
          this.resolveConstraints(0);
        }
        const args = new Array(arguments.length);
        for (let i = 0; i < args.length; ++i) {
          let options = arguments[i];
          if (options.center) {
            options = Object.assign({}, options);
            options.center = fromUserCoordinate(
              options.center,
              this.getProjection()
            );
          }
          if (options.anchor) {
            options = Object.assign({}, options);
            options.anchor = fromUserCoordinate(
              options.anchor,
              this.getProjection()
            );
          }
          args[i] = options;
        }
        this.animateInternal.apply(this, args);
      }
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
          callback = arguments[animationCount - 1];
          --animationCount;
        }
        let i = 0;
        for (; i < animationCount && !this.isDef(); ++i) {
          const state = arguments[i];
          if (state.center) {
            this.setCenterInternal(state.center);
          }
          if (state.zoom !== void 0) {
            this.setZoom(state.zoom);
          } else if (state.resolution) {
            this.setResolution(state.resolution);
          }
          if (state.rotation !== void 0) {
            this.setRotation(state.rotation);
          }
        }
        if (i === animationCount) {
          if (callback) {
            animationCallback(callback, true);
          }
          return;
        }
        let start = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for (; i < animationCount; ++i) {
          const options = (
            /** @type {AnimationOptions} */
            arguments[i]
          );
          const animation = {
            start,
            complete: false,
            anchor: options.anchor,
            duration: options.duration !== void 0 ? options.duration : 1e3,
            easing: options.easing || inAndOut,
            callback
          };
          if (options.center) {
            animation.sourceCenter = center;
            animation.targetCenter = options.center.slice();
            center = animation.targetCenter;
          }
          if (options.zoom !== void 0) {
            animation.sourceResolution = resolution;
            animation.targetResolution = this.getResolutionForZoom(options.zoom);
            resolution = animation.targetResolution;
          } else if (options.resolution) {
            animation.sourceResolution = resolution;
            animation.targetResolution = options.resolution;
            resolution = animation.targetResolution;
          }
          if (options.rotation !== void 0) {
            animation.sourceRotation = rotation;
            const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
            animation.targetRotation = rotation + delta;
            rotation = animation.targetRotation;
          }
          if (isNoopAnimation(animation)) {
            animation.complete = true;
          } else {
            start += animation.duration;
          }
          series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(ViewHint_default.ANIMATING, 1);
        this.updateAnimations_();
      }
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      getAnimating() {
        return this.hints_[ViewHint_default.ANIMATING] > 0;
      }
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      getInteracting() {
        return this.hints_[ViewHint_default.INTERACTING] > 0;
      }
      /**
       * Cancel any ongoing animations.
       * @api
       */
      cancelAnimations() {
        this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
        let anchor;
        for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
          const series = this.animations_[i];
          if (series[0].callback) {
            animationCallback(series[0].callback, false);
          }
          if (!anchor) {
            for (let j = 0, jj = series.length; j < jj; ++j) {
              const animation = series[j];
              if (!animation.complete) {
                anchor = animation.anchor;
                break;
              }
            }
          }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
      }
      /**
       * Update all animations.
       */
      updateAnimations_() {
        if (this.updateAnimationKey_ !== void 0) {
          cancelAnimationFrame(this.updateAnimationKey_);
          this.updateAnimationKey_ = void 0;
        }
        if (!this.getAnimating()) {
          return;
        }
        const now = Date.now();
        let more = false;
        for (let i = this.animations_.length - 1; i >= 0; --i) {
          const series = this.animations_[i];
          let seriesComplete = true;
          for (let j = 0, jj = series.length; j < jj; ++j) {
            const animation = series[j];
            if (animation.complete) {
              continue;
            }
            const elapsed = now - animation.start;
            let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
            if (fraction >= 1) {
              animation.complete = true;
              fraction = 1;
            } else {
              seriesComplete = false;
            }
            const progress = animation.easing(fraction);
            if (animation.sourceCenter) {
              const x0 = animation.sourceCenter[0];
              const y0 = animation.sourceCenter[1];
              const x1 = animation.targetCenter[0];
              const y1 = animation.targetCenter[1];
              this.nextCenter_ = animation.targetCenter;
              const x = x0 + progress * (x1 - x0);
              const y = y0 + progress * (y1 - y0);
              this.targetCenter_ = [x, y];
            }
            if (animation.sourceResolution && animation.targetResolution) {
              const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
              if (animation.anchor) {
                const size = this.getViewportSize_(this.getRotation());
                const constrainedResolution = this.constraints_.resolution(
                  resolution,
                  0,
                  size,
                  true
                );
                this.targetCenter_ = this.calculateCenterZoom(
                  constrainedResolution,
                  animation.anchor
                );
              }
              this.nextResolution_ = animation.targetResolution;
              this.targetResolution_ = resolution;
              this.applyTargetState_(true);
            }
            if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
              const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
              if (animation.anchor) {
                const constrainedRotation = this.constraints_.rotation(
                  rotation,
                  true
                );
                this.targetCenter_ = this.calculateCenterRotate(
                  constrainedRotation,
                  animation.anchor
                );
              }
              this.nextRotation_ = animation.targetRotation;
              this.targetRotation_ = rotation;
            }
            this.applyTargetState_(true);
            more = true;
            if (!animation.complete) {
              break;
            }
          }
          if (seriesComplete) {
            this.animations_[i] = null;
            this.setHint(ViewHint_default.ANIMATING, -1);
            this.nextCenter_ = null;
            this.nextResolution_ = NaN;
            this.nextRotation_ = NaN;
            const callback = series[0].callback;
            if (callback) {
              animationCallback(callback, true);
            }
          }
        }
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === void 0) {
          this.updateAnimationKey_ = requestAnimationFrame(
            this.updateAnimations_.bind(this)
          );
        }
      }
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== void 0) {
          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
          rotate(center, rotation - this.getRotation());
          add3(center, anchor);
        }
        return center;
      }
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== void 0 && currentResolution !== void 0) {
          const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
          const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
          center = [x, y];
        }
        return center;
      }
      /**
       * Returns the current viewport size.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
          const w = size[0];
          const h = size[1];
          return [
            Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
            Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
          ];
        }
        return size;
      }
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
       */
      setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
        if (!this.getAnimating()) {
          this.resolveConstraints(0);
        }
      }
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      getCenter() {
        const center = this.getCenterInternal();
        if (!center) {
          return center;
        }
        return toUserCoordinate(center, this.getProjection());
      }
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      getCenterInternal() {
        return (
          /** @type {import("./coordinate.js").Coordinate|undefined} */
          this.get(ViewProperty_default.CENTER)
        );
      }
      /**
       * @return {Constraints} Constraints.
       */
      getConstraints() {
        return this.constraints_;
      }
      /**
       * @return {boolean} Resolution constraint is set
       */
      getConstrainResolution() {
        return this.get("constrainResolution");
      }
      /**
       * @param {Array<number>} [hints] Destination array.
       * @return {Array<number>} Hint.
       */
      getHints(hints) {
        if (hints !== void 0) {
          hints[0] = this.hints_[0];
          hints[1] = this.hints_[1];
          return hints;
        }
        return this.hints_.slice();
      }
      /**
       * Calculate the extent for the current view state and the passed box size.
       * @param {import("./size.js").Size} [size] The pixel dimensions of the box
       * into which the calculated extent should fit. Defaults to the size of the
       * map the view is associated with.
       * If no map or multiple maps are connected to the view, provide the desired
       * box size (e.g. `map.getSize()`).
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return toUserExtent(extent, this.getProjection());
      }
      /**
       * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
       * the map's last known viewport size will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = (
          /** @type {!import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        assert(center, "The view center is not defined");
        const resolution = (
          /** @type {!number} */
          this.getResolution()
        );
        assert(resolution !== void 0, "The view resolution is not defined");
        const rotation = (
          /** @type {!number} */
          this.getRotation()
        );
        assert(rotation !== void 0, "The view rotation is not defined");
        return getForViewAndSize(center, resolution, rotation, size);
      }
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      getMaxResolution() {
        return this.maxResolution_;
      }
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      getMinResolution() {
        return this.minResolution_;
      }
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.minResolution_)
        );
      }
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      }
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.maxResolution_)
        );
      }
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      }
      /**
       * Set whether the view should allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      }
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      getProjection() {
        return this.projection_;
      }
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      getResolution() {
        return (
          /** @type {number|undefined} */
          this.get(ViewProperty_default.RESOLUTION)
        );
      }
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      getResolutions() {
        return this.resolutions_;
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal(
          fromUserExtent(extent, this.getProjection()),
          size
        );
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = getWidth(extent) / size[0];
        const yResolution = getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
      }
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Resolution for value function.
       */
      getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
          }
        );
      }
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      getRotation() {
        return (
          /** @type {number} */
          this.get(ViewProperty_default.ROTATION)
        );
      }
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Value for resolution function.
       */
      getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
          }
        );
      }
      /**
       * Returns the size of the viewport minus padding.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size reduced by the padding.
       */
      getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) {
          size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
          ];
        }
        return size;
      }
      /**
       * @return {State} View state.
       */
      getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = (
          /** @type {import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        const padding = this.padding_;
        if (padding) {
          const reducedSize = this.getViewportSizeMinusPadding_();
          center = calculateCenterOn(
            center,
            this.getViewportSize_(),
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
        }
        return {
          center: center.slice(0),
          projection: projection !== void 0 ? projection : null,
          resolution,
          nextCenter: this.nextCenter_,
          nextResolution: this.nextResolution_,
          nextRotation: this.nextRotation_,
          rotation,
          zoom: this.getZoom()
        };
      }
      /**
       * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
       */
      getViewStateAndExtent() {
        return {
          viewState: this.getState(),
          extent: this.calculateExtent()
        };
      }
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== void 0) {
          zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
      }
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      getZoomForResolution(resolution) {
        let offset2 = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
          const nearest = linearFindNearest(this.resolutions_, resolution, 1);
          offset2 = nearest;
          max = this.resolutions_[nearest];
          if (nearest == this.resolutions_.length - 1) {
            zoomFactor = 2;
          } else {
            zoomFactor = max / this.resolutions_[nearest + 1];
          }
        } else {
          max = this.maxResolution_;
          zoomFactor = this.zoomFactor_;
        }
        return offset2 + Math.log(max / resolution) / Math.log(zoomFactor);
      }
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      getResolutionForZoom(zoom) {
        if (this.resolutions_) {
          if (this.resolutions_.length <= 1) {
            return 0;
          }
          const baseLevel = clamp(
            Math.floor(zoom),
            0,
            this.resolutions_.length - 2
          );
          const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
          return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
      }
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions} [options] Options.
       * @api
       */
      fit(geometryOrExtent, options) {
        let geometry;
        assert(
          Array.isArray(geometryOrExtent) || typeof /** @type {?} */
          geometryOrExtent.getSimplifiedGeometry === "function",
          "Invalid extent or geometry provided as `geometry`"
        );
        if (Array.isArray(geometryOrExtent)) {
          assert(
            !isEmpty2(geometryOrExtent),
            "Cannot fit empty extent provided as `geometry`"
          );
          const extent = fromUserExtent(geometryOrExtent, this.getProjection());
          geometry = fromExtent(extent);
        } else if (geometryOrExtent.getType() === "Circle") {
          const extent = fromUserExtent(
            geometryOrExtent.getExtent(),
            this.getProjection()
          );
          geometry = fromExtent(extent);
          geometry.rotate(this.getRotation(), getCenter(extent));
        } else {
          const userProjection2 = getUserProjection();
          if (userProjection2) {
            geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
            geometryOrExtent.clone().transform(userProjection2, this.getProjection());
          } else {
            geometry = geometryOrExtent;
          }
        }
        this.fitInternal(geometry, options);
      }
      /**
       * Calculate rotated extent
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @return {import("./extent").Extent} The rotated extent for the geometry.
       */
      rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for (let i = 0, ii = coords.length; i < ii; i += stride) {
          const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
          const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
          minRotX = Math.min(minRotX, rotX);
          minRotY = Math.min(minRotY, rotY);
          maxRotX = Math.max(maxRotX, rotX);
          maxRotY = Math.max(maxRotY, rotY);
        }
        return [minRotX, minRotY, maxRotX, maxRotY];
      }
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions} [options] Options.
       */
      fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) {
          size = this.getViewportSizeMinusPadding_();
        }
        const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
        const nearest = options.nearest !== void 0 ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== void 0) {
          minResolution = options.minResolution;
        } else if (options.maxZoom !== void 0) {
          minResolution = this.getResolutionForZoom(options.maxZoom);
        } else {
          minResolution = 0;
        }
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
          size[0] - padding[1] - padding[3],
          size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = getCenter(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([centerX, centerY], resolution);
        const callback = options.callback ? options.callback : VOID;
        if (options.duration !== void 0) {
          this.animateInternal(
            {
              resolution,
              center,
              duration: options.duration,
              easing: options.easing
            },
            callback
          );
        } else {
          this.targetResolution_ = resolution;
          this.targetCenter_ = center;
          this.applyTargetState_(false, true);
          animationCallback(callback, true);
        }
      }
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      centerOn(coordinate, size, position) {
        this.centerOnInternal(
          fromUserCoordinate(coordinate, this.getProjection()),
          size,
          position
        );
      }
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(
          calculateCenterOn(
            coordinate,
            size,
            position,
            this.getResolution(),
            this.getRotation()
          )
        );
      }
      /**
       * Calculates the shift between map and viewport center.
       * @param {import("./coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {import("./size.js").Size} size Size.
       * @return {Array<number>|undefined} Center shift.
       */
      calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
          const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
          const shiftedCenter = calculateCenterOn(
            center,
            size,
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
          centerShift = [
            center[0] - shiftedCenter[0],
            center[1] - shiftedCenter[1]
          ];
        }
        return centerShift;
      }
      /**
       * @return {boolean} Is defined.
       */
      isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== void 0;
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      adjustCenter(deltaCoordinates) {
        const center = toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustResolution(ratio, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(
          this.targetResolution_ * ratio,
          0,
          size,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        }
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
      }
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
      }
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       * @api
       */
      adjustRotation(delta, anchor) {
        if (anchor) {
          anchor = fromUserCoordinate(anchor, this.getProjection());
        }
        this.adjustRotationInternal(delta, anchor);
      }
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       */
      adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(
          this.targetRotation_ + delta,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        }
        this.targetRotation_ += delta;
        this.applyTargetState_();
      }
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      setCenter(center) {
        this.setCenterInternal(
          center ? fromUserCoordinate(center, this.getProjection()) : center
        );
      }
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
      }
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
      }
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
      }
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
      }
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
      }
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean} [doNotCancelAnims] Do not cancel animations.
       * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
       * @private
       */
      applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        const newRotation = this.constraints_.rotation(
          this.targetRotation_,
          isMoving
        );
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          0,
          size,
          isMoving
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          isMoving,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
          this.set(ViewProperty_default.ROTATION, newRotation);
        }
        if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
          this.set(ViewProperty_default.RESOLUTION, newResolution);
          this.set("zoom", this.getZoom(), true);
        }
        if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
          this.set(ViewProperty_default.CENTER, newCenter);
        }
        if (this.getAnimating() && !doNotCancelAnims) {
          this.cancelAnimations();
        }
        this.cancelAnchor_ = void 0;
      }
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number} [duration] The animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== void 0 ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          direction,
          size
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          false,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (duration === 0 && !this.cancelAnchor_) {
          this.targetResolution_ = newResolution;
          this.targetRotation_ = newRotation;
          this.targetCenter_ = newCenter;
          this.applyTargetState_();
          return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
        this.cancelAnchor_ = void 0;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
          if (this.getAnimating()) {
            this.cancelAnimations();
          }
          this.animateInternal({
            rotation: newRotation,
            center: newCenter,
            resolution: newResolution,
            duration,
            easing: easeOut,
            anchor
          });
        }
      }
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      beginInteraction() {
        this.resolveConstraints(0);
        this.setHint(ViewHint_default.INTERACTING, 1);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) {
          return;
        }
        this.setHint(ViewHint_default.INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
      }
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(
          targetCenter,
          targetResolution || this.getResolution(),
          size
        );
      }
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number} [direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(
          this.getConstrainedResolution(targetRes, direction)
        );
      }
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number} [direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
      }
    };
    View_default = View;
  }
});

// node_modules/ol/layer/Layer.js
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer, Layer_default;
var init_Layer = __esm({
  "node_modules/ol/layer/Layer.js"() {
    init_Base();
    init_EventType();
    init_Property();
    init_EventType2();
    init_View();
    init_asserts();
    init_extent();
    init_events();
    Layer = class extends Base_default {
      /**
       * @param {Options<SourceType>} options Layer options.
       */
      constructor(options) {
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.mapPrecomposeKey_ = null;
        this.mapRenderKey_ = null;
        this.sourceChangeKey_ = null;
        this.renderer_ = null;
        this.sourceReady_ = false;
        this.rendered = false;
        if (options.render) {
          this.render = options.render;
        }
        if (options.map) {
          this.setMap(options.map);
        }
        this.addChangeListener(
          Property_default.SOURCE,
          this.handleSourcePropertyChange_
        );
        const source = options.source ? (
          /** @type {SourceType} */
          options.source
        ) : null;
        this.setSource(source);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
      }
      /**
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
      }
      /**
       * Get the layer source.
       * @return {SourceType|null} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      getSource() {
        return (
          /** @type {SourceType} */
          this.get(Property_default.SOURCE) || null
        );
      }
      /**
       * @return {SourceType|null} The source being rendered.
       */
      getRenderSource() {
        return this.getSource();
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        const source = this.getSource();
        return !source ? "undefined" : source.getState();
      }
      /**
       * @private
       */
      handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== "ready") {
          return;
        }
        this.sourceReady_ = true;
        this.dispatchEvent("sourceready");
      }
      /**
       * @private
       */
      handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
          unlistenByKey(this.sourceChangeKey_);
          this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source = this.getSource();
        if (source) {
          this.sourceChangeKey_ = listen(
            source,
            EventType_default.CHANGE,
            this.handleSourceChange_,
            this
          );
          if (source.getState() === "ready") {
            this.sourceReady_ = true;
            setTimeout(() => {
              this.dispatchEvent("sourceready");
            }, 0);
          }
        }
        this.changed();
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        if (!this.renderer_) {
          return Promise.resolve([]);
        }
        return this.renderer_.getFeatures(pixel);
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        if (!this.renderer_ || !this.rendered) {
          return null;
        }
        return this.renderer_.getData(pixel);
      }
      /**
       * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
       * extent, not set to `visible: false`, and not inside a layer group that is set
       * to `visible: false`.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {boolean} The layer is visible in the map view.
       * @api
       */
      isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) {
          view = map.getView();
        }
        if (view instanceof View_default) {
          frameState = {
            viewState: view.getState(),
            extent: view.calculateExtent()
          };
        } else {
          frameState = view;
        }
        if (!frameState.layerStatesArray && map) {
          frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        }
        let layerState;
        if (frameState.layerStatesArray) {
          layerState = frameState.layerStatesArray.find(
            (layerState2) => layerState2.layer === this
          );
        } else {
          layerState = this.getLayerState();
        }
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
      }
      /**
       * Get the attributions of the source of this layer for the given view.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {Array<string>} Attributions for this layer at the given view.
       * @api
       */
      getAttributions(view) {
        if (!this.isVisible(view)) {
          return [];
        }
        let getAttributions;
        const source = this.getSource();
        if (source) {
          getAttributions = source.getAttributions();
        }
        if (!getAttributions) {
          return [];
        }
        const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) {
          attributions = [attributions];
        }
        return attributions;
      }
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement|null} The rendered element.
       */
      render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
          this.rendered = true;
          return layerRenderer.renderFrame(frameState, target);
        }
        return null;
      }
      /**
       * Called when a layer is not visible during a map render.
       */
      unrender() {
        this.rendered = false;
      }
      /** @return {string} Declutter */
      getDeclutter() {
        return void 0;
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {import("../layer/Layer.js").State} layerState Layer state.
       */
      renderDeclutter(frameState, layerState) {
      }
      /**
       * When the renderer follows a layout -> render approach, do the final rendering here.
       * @param {import('../Map.js').FrameState} frameState Frame state
       */
      renderDeferred(frameState) {
        const layerRenderer = this.getRenderer();
        if (!layerRenderer) {
          return;
        }
        layerRenderer.renderDeferred(frameState);
      }
      /**
       * For use inside the library only.
       * @param {import("../Map.js").default|null} map Map.
       */
      setMapInternal(map) {
        if (!map) {
          this.unrender();
        }
        this.set(Property_default.MAP, map);
      }
      /**
       * For use inside the library only.
       * @return {import("../Map.js").default|null} Map.
       */
      getMapInternal() {
        return this.get(Property_default.MAP);
      }
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map~Map#addLayer} instead.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.mapPrecomposeKey_) {
          unlistenByKey(this.mapPrecomposeKey_);
          this.mapPrecomposeKey_ = null;
        }
        if (!map) {
          this.changed();
        }
        if (this.mapRenderKey_) {
          unlistenByKey(this.mapRenderKey_);
          this.mapRenderKey_ = null;
        }
        if (map) {
          this.mapPrecomposeKey_ = listen(
            map,
            EventType_default2.PRECOMPOSE,
            function(evt) {
              const renderEvent = (
                /** @type {import("../render/Event.js").default} */
                evt
              );
              const layerStatesArray = renderEvent.frameState.layerStatesArray;
              const layerState = this.getLayerState(false);
              assert(
                !layerStatesArray.some(function(arrayLayerState) {
                  return arrayLayerState.layer === layerState.layer;
                }),
                "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
              );
              layerStatesArray.push(layerState);
            },
            this
          );
          this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
          this.changed();
        }
      }
      /**
       * Set the layer source.
       * @param {SourceType|null} source The layer source.
       * @observable
       * @api
       */
      setSource(source) {
        this.set(Property_default.SOURCE, source);
      }
      /**
       * Get the renderer for this layer.
       * @return {RendererType|null} The layer renderer.
       */
      getRenderer() {
        if (!this.renderer_) {
          this.renderer_ = this.createRenderer();
        }
        return this.renderer_;
      }
      /**
       * @return {boolean} The layer has a renderer.
       */
      hasRenderer() {
        return !!this.renderer_;
      }
      /**
       * Create a renderer for this layer.
       * @return {RendererType} A layer renderer.
       * @protected
       */
      createRenderer() {
        return null;
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        if (this.renderer_) {
          this.renderer_.dispose();
          delete this.renderer_;
        }
        this.setSource(null);
        super.disposeInternal();
      }
    };
    Layer_default = Layer;
  }
});

// node_modules/quickselect/index.js
function quickselect(arr, k, left, right, compare) {
  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
}
function quickselectStep(arr, k, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselectStep(arr, k, newLeft, newRight, compare);
    }
    var t = arr[k];
    var i = left;
    var j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0)
      swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0)
        i++;
      while (compare(arr[j], t) > 0)
        j--;
    }
    if (compare(arr[left], t) === 0)
      swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
}
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var init_quickselect = __esm({
  "node_modules/quickselect/index.js"() {
  }
});

// node_modules/rbush/index.js
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i]))
      return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend3(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend3(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects2(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n)
      continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}
var RBush;
var init_rbush = __esm({
  "node_modules/rbush/index.js"() {
    init_quickselect();
    RBush = class {
      constructor(maxEntries = 9) {
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      }
      all() {
        return this._all(this.data, []);
      }
      search(bbox2) {
        let node = this.data;
        const result = [];
        if (!intersects2(bbox2, node))
          return result;
        const toBBox = this.toBBox;
        const nodesToSearch = [];
        while (node) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const childBBox = node.leaf ? toBBox(child) : child;
            if (intersects2(bbox2, childBBox)) {
              if (node.leaf)
                result.push(child);
              else if (contains(bbox2, childBBox))
                this._all(child, result);
              else
                nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      }
      collides(bbox2) {
        let node = this.data;
        if (!intersects2(bbox2, node))
          return false;
        const nodesToSearch = [];
        while (node) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects2(bbox2, childBBox)) {
              if (node.leaf || contains(bbox2, childBBox))
                return true;
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      }
      load(data) {
        if (!(data && data.length))
          return this;
        if (data.length < this._minEntries) {
          for (let i = 0; i < data.length; i++) {
            this.insert(data[i]);
          }
          return this;
        }
        let node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            const tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      }
      insert(item) {
        if (item)
          this._insert(item, this.data.height - 1);
        return this;
      }
      clear() {
        this.data = createNode([]);
        return this;
      }
      remove(item, equalsFn) {
        if (!item)
          return this;
        let node = this.data;
        const bbox2 = this.toBBox(item);
        const path = [];
        const indexes = [];
        let i, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            const index = findItem(item, node.children, equalsFn);
            if (index !== -1) {
              node.children.splice(index, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox2)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else
            node = null;
        }
        return this;
      }
      toBBox(item) {
        return item;
      }
      compareMinX(a, b) {
        return a.minX - b.minX;
      }
      compareMinY(a, b) {
        return a.minY - b.minY;
      }
      toJSON() {
        return this.data;
      }
      fromJSON(data) {
        this.data = data;
        return this;
      }
      _all(node, result) {
        const nodesToSearch = [];
        while (node) {
          if (node.leaf)
            result.push(...node.children);
          else
            nodesToSearch.push(...node.children);
          node = nodesToSearch.pop();
        }
        return result;
      }
      _build(items, left, right, height) {
        const N = right - left + 1;
        let M = this._maxEntries;
        let node;
        if (N <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        const N2 = Math.ceil(N / M);
        const N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (let i = left; i <= right; i += N1) {
          const right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (let j = i; j <= right2; j += N2) {
            const right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      }
      _chooseSubtree(bbox2, node, level2, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level2)
            break;
          let minArea = Infinity;
          let minEnlargement = Infinity;
          let targetNode;
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const area = bboxArea(child);
            const enlargement = enlargedArea(bbox2, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      }
      _insert(item, level2, isNode) {
        const bbox2 = isNode ? item : this.toBBox(item);
        const insertPath = [];
        const node = this._chooseSubtree(bbox2, this.data, level2, insertPath);
        node.children.push(item);
        extend3(node, bbox2);
        while (level2 >= 0) {
          if (insertPath[level2].children.length > this._maxEntries) {
            this._split(insertPath, level2);
            level2--;
          } else
            break;
        }
        this._adjustParentBBoxes(bbox2, insertPath, level2);
      }
      // split overflowed node into two
      _split(insertPath, level2) {
        const node = insertPath[level2];
        const M = node.children.length;
        const m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        const splitIndex = this._chooseSplitIndex(node, m, M);
        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level2)
          insertPath[level2 - 1].children.push(newNode);
        else
          this._splitRoot(node, newNode);
      }
      _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      }
      _chooseSplitIndex(node, m, M) {
        let index;
        let minOverlap = Infinity;
        let minArea = Infinity;
        for (let i = m; i <= M - m; i++) {
          const bbox1 = distBBox(node, 0, i, this.toBBox);
          const bbox2 = distBBox(node, i, M, this.toBBox);
          const overlap = intersectionArea(bbox1, bbox2);
          const area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
        return index || M - m;
      }
      // sorts node children by the best axis for split
      _chooseSplitAxis(node, m, M) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        const xMargin = this._allDistMargin(node, m, M, compareMinX);
        const yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin)
          node.children.sort(compareMinX);
      }
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        const toBBox = this.toBBox;
        const leftBBox = distBBox(node, 0, m, toBBox);
        const rightBBox = distBBox(node, M - m, M, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (let i = m; i < M - m; i++) {
          const child = node.children[i];
          extend3(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (let i = M - m - 1; i >= m; i--) {
          const child = node.children[i];
          extend3(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      }
      _adjustParentBBoxes(bbox2, path, level2) {
        for (let i = level2; i >= 0; i--) {
          extend3(path[i], bbox2);
        }
      }
      _condense(path) {
        for (let i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else
              this.clear();
          } else
            calcBBox(path[i], this.toBBox);
        }
      }
    };
  }
});

// node_modules/ol/ImageState.js
var ImageState_default;
var init_ImageState = __esm({
  "node_modules/ol/ImageState.js"() {
    ImageState_default = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4
    };
  }
});

// node_modules/ol/size.js
function buffer2(size, num, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] + 2 * num;
  dest[1] = size[1] + 2 * num;
  return dest;
}
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale4(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
var init_size = __esm({
  "node_modules/ol/size.js"() {
  }
});

// node_modules/ol/style/Image.js
var ImageStyle, Image_default;
var init_Image = __esm({
  "node_modules/ol/style/Image.js"() {
    init_util();
    init_size();
    ImageStyle = class _ImageStyle {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        this.opacity_ = options.opacity;
        this.rotateWithView_ = options.rotateWithView;
        this.rotation_ = options.rotation;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale);
        this.displacement_ = options.displacement;
        this.declutterMode_ = options.declutterMode;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      clone() {
        const scale5 = this.getScale();
        return new _ImageStyle({
          opacity: this.getOpacity(),
          scale: Array.isArray(scale5) ? scale5.slice() : scale5,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      getOpacity() {
        return this.opacity_;
      }
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      getDisplacement() {
        return this.displacement_;
      }
      /**
       * Get the declutter mode of the shape
       * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
       * @api
       */
      getDeclutterMode() {
        return this.declutterMode_;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      getAnchor() {
        return abstract();
      }
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getImage(pixelRatio) {
        return abstract();
      }
      /**
       * @abstract
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getHitDetectionImage() {
        return abstract();
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return 1;
      }
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return abstract();
      }
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return abstract();
      }
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      getOrigin() {
        return abstract();
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      getSize() {
        return abstract();
      }
      /**
       * Set the displacement.
       *
       * @param {Array<number>} displacement Displacement.
       * @api
       */
      setDisplacement(displacement) {
        this.displacement_ = displacement;
      }
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      setOpacity(opacity) {
        this.opacity_ = opacity;
      }
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale5) {
        this.scale_ = scale5;
        this.scaleArray_ = toSize(scale5);
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        abstract();
      }
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      load() {
        abstract();
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        abstract();
      }
      /**
       * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
       */
      ready() {
        return Promise.resolve();
      }
    };
    Image_default = ImageStyle;
  }
});

// node_modules/color-space/rgb.js
var rgb_default;
var init_rgb = __esm({
  "node_modules/color-space/rgb.js"() {
    rgb_default = {
      name: "rgb",
      min: [0, 0, 0],
      max: [255, 255, 255],
      channel: ["red", "green", "blue"],
      alias: ["RGB"]
    };
  }
});

// node_modules/color-space/xyz.js
var xyz, xyz_default;
var init_xyz = __esm({
  "node_modules/color-space/xyz.js"() {
    init_rgb();
    xyz = {
      name: "xyz",
      min: [0, 0, 0],
      channel: ["X", "Y", "Z"],
      alias: ["XYZ", "ciexyz", "cie1931"]
    };
    xyz.whitepoint = {
      //1931 2°
      2: {
        //incadescent
        A: [109.85, 100, 35.585],
        // B:[],
        C: [98.074, 100, 118.232],
        D50: [96.422, 100, 82.521],
        D55: [95.682, 100, 92.149],
        //daylight
        D65: [95.045592705167, 100, 108.9057750759878],
        D75: [94.972, 100, 122.638],
        //flourescent
        // F1: [],
        F2: [99.187, 100, 67.395],
        // F3: [],
        // F4: [],
        // F5: [],
        // F6:[],
        F7: [95.044, 100, 108.755],
        // F8: [],
        // F9: [],
        // F10: [],
        F11: [100.966, 100, 64.37],
        // F12: [],
        E: [100, 100, 100]
      },
      //1964  10°
      10: {
        //incadescent
        A: [111.144, 100, 35.2],
        C: [97.285, 100, 116.145],
        D50: [96.72, 100, 81.427],
        D55: [95.799, 100, 90.926],
        //daylight
        D65: [94.811, 100, 107.304],
        D75: [94.416, 100, 120.641],
        //flourescent
        F2: [103.28, 100, 69.026],
        F7: [95.792, 100, 107.687],
        F11: [103.866, 100, 65.627],
        E: [100, 100, 100]
      }
    };
    xyz.max = xyz.whitepoint[2].D65;
    xyz.rgb = function(_xyz, white) {
      white = white || xyz.whitepoint[2].E;
      var x = _xyz[0] / white[0], y = _xyz[1] / white[1], z = _xyz[2] / white[2], r, g, b;
      r = x * 3.240969941904521 + y * -1.537383177570093 + z * -0.498610760293;
      g = x * -0.96924363628087 + y * 1.87596750150772 + z * 0.041555057407175;
      b = x * 0.055630079696993 + y * -0.20397695888897 + z * 1.056971514242878;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    rgb_default.xyz = function(rgb, white) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.41239079926595 + g * 0.35758433938387 + b * 0.18048078840183;
      var y = r * 0.21263900587151 + g * 0.71516867876775 + b * 0.072192315360733;
      var z = r * 0.019330818715591 + g * 0.11919477979462 + b * 0.95053215224966;
      white = white || xyz.whitepoint[2].E;
      return [x * white[0], y * white[1], z * white[2]];
    };
    xyz_default = xyz;
  }
});

// node_modules/color-space/luv.js
var luv_default;
var init_luv = __esm({
  "node_modules/color-space/luv.js"() {
    init_xyz();
    luv_default = {
      name: "luv",
      //NOTE: luv has no rigidly defined limits
      //easyrgb fails to get proper coords
      //boronine states no rigid limits
      //colorMine refers this ones:
      min: [0, -134, -140],
      max: [100, 224, 122],
      channel: ["lightness", "u", "v"],
      alias: ["LUV", "cieluv", "cie1976"],
      xyz: function(arg, i, o) {
        var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
        l = arg[0], u = arg[1], v = arg[2];
        if (l === 0)
          return [0, 0, 0];
        var k = 0.0011070564598794539;
        i = i || "D65";
        o = o || 2;
        xn = xyz_default.whitepoint[o][i][0];
        yn = xyz_default.whitepoint[o][i][1];
        zn = xyz_default.whitepoint[o][i][2];
        un = 4 * xn / (xn + 15 * yn + 3 * zn);
        vn = 9 * yn / (xn + 15 * yn + 3 * zn);
        _u = u / (13 * l) + un || 0;
        _v = v / (13 * l) + vn || 0;
        y = l > 8 ? yn * Math.pow((l + 16) / 116, 3) : yn * l * k;
        x = y * 9 * _u / (4 * _v) || 0;
        z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;
        return [x, y, z];
      }
    };
    xyz_default.luv = function(arg, i, o) {
      var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
      var e = 0.008856451679035631;
      var k = 903.2962962962961;
      i = i || "D65";
      o = o || 2;
      xn = xyz_default.whitepoint[o][i][0];
      yn = xyz_default.whitepoint[o][i][1];
      zn = xyz_default.whitepoint[o][i][2];
      un = 4 * xn / (xn + 15 * yn + 3 * zn);
      vn = 9 * yn / (xn + 15 * yn + 3 * zn);
      x = arg[0], y = arg[1], z = arg[2];
      _u = 4 * x / (x + 15 * y + 3 * z) || 0;
      _v = 9 * y / (x + 15 * y + 3 * z) || 0;
      var yr = y / yn;
      l = yr <= e ? k * yr : 116 * Math.pow(yr, 1 / 3) - 16;
      u = 13 * l * (_u - un);
      v = 13 * l * (_v - vn);
      return [l, u, v];
    };
  }
});

// node_modules/color-space/lchuv.js
var lchuv, lchuv_default;
var init_lchuv = __esm({
  "node_modules/color-space/lchuv.js"() {
    init_luv();
    init_xyz();
    lchuv = {
      name: "lchuv",
      channel: ["lightness", "chroma", "hue"],
      alias: ["LCHuv", "cielchuv"],
      min: [0, 0, 0],
      max: [100, 100, 360],
      luv: function(luv) {
        var l = luv[0], c = luv[1], h = luv[2], u, v, hr;
        hr = h / 360 * 2 * Math.PI;
        u = c * Math.cos(hr);
        v = c * Math.sin(hr);
        return [l, u, v];
      },
      xyz: function(arg) {
        return luv_default.xyz(lchuv.luv(arg));
      }
    };
    lchuv_default = lchuv;
    luv_default.lchuv = function(luv) {
      var l = luv[0], u = luv[1], v = luv[2];
      var c = Math.sqrt(u * u + v * v);
      var hr = Math.atan2(v, u);
      var h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      return [l, c, h];
    };
    xyz_default.lchuv = function(arg) {
      return luv_default.lchuv(xyz_default.luv(arg));
    };
  }
});

// node_modules/color-parse/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-parse/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-parse/index.js
function parse(cstr) {
  var m, parts = [], alpha = 1, space;
  if (typeof cstr === "number") {
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  }
  if (typeof cstr === "number")
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  cstr = String(cstr).toLowerCase();
  if (import_color_name.default[cstr]) {
    parts = import_color_name.default[cstr].slice();
    space = "rgb";
  } else if (cstr === "transparent") {
    alpha = 0;
    space = "rgb";
    parts = [0, 0, 0];
  } else if (cstr[0] === "#") {
    var base = cstr.slice(1);
    var size = base.length;
    var isShort = size <= 4;
    alpha = 1;
    if (isShort) {
      parts = [
        parseInt(base[0] + base[0], 16),
        parseInt(base[1] + base[1], 16),
        parseInt(base[2] + base[2], 16)
      ];
      if (size === 4) {
        alpha = parseInt(base[3] + base[3], 16) / 255;
      }
    } else {
      parts = [
        parseInt(base[0] + base[1], 16),
        parseInt(base[2] + base[3], 16),
        parseInt(base[4] + base[5], 16)
      ];
      if (size === 8) {
        alpha = parseInt(base[6] + base[7], 16) / 255;
      }
    }
    if (!parts[0])
      parts[0] = 0;
    if (!parts[1])
      parts[1] = 0;
    if (!parts[2])
      parts[2] = 0;
    space = "rgb";
  } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
    var name = m[1];
    space = name.replace(/a$/, "");
    var dims = space === "cmyk" ? 4 : space === "gray" ? 1 : 3;
    parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
    if (space === "color")
      space = parts.shift();
    parts = parts.map(function(x, i) {
      if (x[x.length - 1] === "%") {
        x = parseFloat(x) / 100;
        if (i === 3)
          return x;
        if (space === "rgb")
          return x * 255;
        if (space[0] === "h")
          return x * 100;
        if (space[0] === "l" && !i)
          return x * 100;
        if (space === "lab")
          return x * 125;
        if (space === "lch")
          return i < 2 ? x * 150 : x * 360;
        if (space[0] === "o" && !i)
          return x;
        if (space === "oklab")
          return x * 0.4;
        if (space === "oklch")
          return i < 2 ? x * 0.4 : x * 360;
        return x;
      }
      if (space[i] === "h" || i === 2 && space[space.length - 1] === "h") {
        if (baseHues[x] !== void 0)
          return baseHues[x];
        if (x.endsWith("deg"))
          return parseFloat(x);
        if (x.endsWith("turn"))
          return parseFloat(x) * 360;
        if (x.endsWith("grad"))
          return parseFloat(x) * 360 / 400;
        if (x.endsWith("rad"))
          return parseFloat(x) * 180 / Math.PI;
      }
      if (x === "none")
        return 0;
      return parseFloat(x);
    });
    alpha = parts.length > dims ? parts.pop() : 1;
  } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
    parts = cstr.match(/([0-9]+)/g).map(function(value) {
      return parseFloat(value);
    });
    space = cstr.match(/([a-z])/ig)?.join("")?.toLowerCase() || "rgb";
  }
  return {
    space,
    values: parts,
    alpha
  };
}
var import_color_name, color_parse_default, baseHues;
var init_color_parse = __esm({
  "node_modules/color-parse/index.js"() {
    import_color_name = __toESM(require_color_name(), 1);
    color_parse_default = parse;
    baseHues = {
      red: 0,
      orange: 60,
      yellow: 120,
      green: 180,
      blue: 240,
      purple: 300
    };
  }
});

// node_modules/color-space/hsl.js
var hsl_default;
var init_hsl = __esm({
  "node_modules/color-space/hsl.js"() {
    init_rgb();
    hsl_default = {
      name: "hsl",
      min: [0, 0, 0],
      max: [360, 100, 100],
      channel: ["hue", "saturation", "lightness"],
      alias: ["HSL"],
      rgb: function(hsl) {
        var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i = 0;
        if (s === 0)
          return val = l * 255, [val, val, val];
        t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        t1 = 2 * l - t2;
        rgb = [0, 0, 0];
        for (; i < 3; ) {
          t3 = h + 1 / 3 * -(i - 1);
          t3 < 0 ? t3++ : t3 > 1 && t3--;
          val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
          rgb[i++] = val * 255;
        }
        return rgb;
      }
    };
    rgb_default.hsl = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
  }
});

// node_modules/color-rgba/index.js
function rgba(color) {
  if (Array.isArray(color) && color.raw)
    color = String.raw(...arguments);
  if (color instanceof Number)
    color = +color;
  var values, i, l;
  var parsed = color_parse_default(color);
  if (!parsed.space)
    return [];
  const min = parsed.space[0] === "h" ? hsl_default.min : rgb_default.min;
  const max = parsed.space[0] === "h" ? hsl_default.max : rgb_default.max;
  values = Array(3);
  values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
  values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
  values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
  if (parsed.space[0] === "h") {
    values = hsl_default.rgb(values);
  }
  values.push(Math.min(Math.max(parsed.alpha, 0), 1));
  return values;
}
var init_color_rgba = __esm({
  "node_modules/color-rgba/index.js"() {
    init_color_parse();
    init_rgb();
    init_hsl();
  }
});

// node_modules/ol/color.js
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  const output = color.slice();
  output[3] = 1;
  return output;
}
function rgbaToLcha(color) {
  const output = xyz_default.lchuv(rgb_default.xyz(color));
  output[3] = color[3];
  return output;
}
function lchaToRgba(color) {
  const output = xyz_default.rgb(lchuv_default.xyz(color));
  output[3] = color[3];
  return output;
}
function fromString(s) {
  if (cache2.hasOwnProperty(s)) {
    return cache2[s];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i = 0;
    for (const key in cache2) {
      if ((i++ & 3) === 0) {
        delete cache2[key];
        --cacheSize;
      }
    }
  }
  const color = rgba(s);
  if (color.length !== 4) {
    throw new Error('Failed to parse "' + s + '" as color');
  }
  for (const c of color) {
    if (isNaN(c)) {
      throw new Error('Failed to parse "' + s + '" as color');
    }
  }
  normalize(color);
  cache2[s] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}
function normalize(color) {
  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = clamp(color[3], 0, 1);
  return color;
}
function toString2(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 1e3) / 1e3;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}
function isStringColor(s) {
  try {
    fromString(s);
    return true;
  } catch (_) {
    return false;
  }
}
var MAX_CACHE_SIZE, cache2, cacheSize;
var init_color = __esm({
  "node_modules/ol/color.js"() {
    init_lchuv();
    init_color_rgba();
    init_rgb();
    init_xyz();
    init_math();
    MAX_CACHE_SIZE = 1024;
    cache2 = {};
    cacheSize = 0;
  }
});

// node_modules/ol/has.js
var ua, FIREFOX, SAFARI, SAFARI_BUG_237906, WEBKIT, MAC, DEVICE_PIXEL_RATIO, WORKER_OFFSCREEN_CANVAS, IMAGE_DECODE, CREATE_IMAGE_BITMAP, PASSIVE_EVENT_LISTENERS;
var init_has = __esm({
  "node_modules/ol/has.js"() {
    ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
    FIREFOX = ua.includes("firefox");
    SAFARI = ua.includes("safari") && !ua.includes("chrom");
    SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
    WEBKIT = ua.includes("webkit") && !ua.includes("edge");
    MAC = ua.includes("macintosh");
    DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
    WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
    IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
    CREATE_IMAGE_BITMAP = typeof createImageBitmap === "function";
    PASSIVE_EVENT_LISTENERS = function() {
      let passive = false;
      try {
        const options = Object.defineProperty({}, "passive", {
          get: function() {
            passive = true;
          }
        });
        window.addEventListener("_", null, options);
        window.removeEventListener("_", null, options);
      } catch (error2) {
      }
      return passive;
    }();
  }
});

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool3, settings) {
  let canvas;
  if (canvasPool3 && canvasPool3.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool3.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
function getSharedCanvasContext2D() {
  if (!sharedCanvasContext) {
    sharedCanvasContext = createCanvasContext2D(1, 1);
  }
  return sharedCanvasContext;
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
  let width = element.offsetWidth;
  const style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}
function outerHeight(element) {
  let height = element.offsetHeight;
  const style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;
  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }
    node.insertBefore(newChild, oldChild);
  }
}
var sharedCanvasContext;
var init_dom = __esm({
  "node_modules/ol/dom.js"() {
    init_has();
  }
});

// node_modules/ol/Image.js
function listenImage(image, loadHandler, errorHandler) {
  const img = (
    /** @type {HTMLImageElement} */
    image
  );
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType_default.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error2) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType_default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (src) {
      image.src = src;
    }
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve, reject) => image.decode().then(() => resolve(image)).catch(
      (e) => image.complete && image.width ? resolve(image) : reject(e)
    )
  ) : load(image);
}
function decode(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP ? image.decode().then(() => createImageBitmap(image)).catch((e) => {
    if (image.complete && image.width) {
      return image;
    }
    throw e;
  }) : decodeFallback(image);
}
var ImageWrapper, Image_default2;
var init_Image2 = __esm({
  "node_modules/ol/Image.js"() {
    init_Target();
    init_EventType();
    init_ImageState();
    init_has();
    init_events();
    init_functions();
    ImageWrapper = class extends Target_default {
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
       * resolution will be assumed.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
       */
      constructor(extent, resolution, pixelRatio, stateOrLoader) {
        super();
        this.extent = extent;
        this.pixelRatio_ = pixelRatio;
        this.resolution = resolution;
        this.state = typeof stateOrLoader === "function" ? ImageState_default.IDLE : stateOrLoader;
        this.image_ = null;
        this.loader = typeof stateOrLoader === "function" ? stateOrLoader : null;
      }
      /**
       * @protected
       */
      changed() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * @return {import("./extent.js").Extent} Extent.
       */
      getExtent() {
        return this.extent;
      }
      /**
       * @return {import('./DataTile.js').ImageLike} Image.
       */
      getImage() {
        return this.image_;
      }
      /**
       * @return {number} PixelRatio.
       */
      getPixelRatio() {
        return this.pixelRatio_;
      }
      /**
       * @return {number|Array<number>} Resolution.
       */
      getResolution() {
        return (
          /** @type {number} */
          this.resolution
        );
      }
      /**
       * @return {import("./ImageState.js").default} State.
       */
      getState() {
        return this.state;
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
        if (this.state == ImageState_default.IDLE) {
          if (this.loader) {
            this.state = ImageState_default.LOADING;
            this.changed();
            const resolution = this.getResolution();
            const requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;
            toPromise(
              () => this.loader(
                this.getExtent(),
                requestResolution,
                this.getPixelRatio()
              )
            ).then((image) => {
              if ("image" in image) {
                this.image_ = image.image;
              }
              if ("extent" in image) {
                this.extent = image.extent;
              }
              if ("resolution" in image) {
                this.resolution = image.resolution;
              }
              if ("pixelRatio" in image) {
                this.pixelRatio_ = image.pixelRatio;
              }
              if (image instanceof HTMLImageElement || image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) {
                this.image_ = image;
              }
              this.state = ImageState_default.LOADED;
            }).catch((error2) => {
              this.state = ImageState_default.ERROR;
              console.error(error2);
            }).finally(() => this.changed());
          }
        }
      }
      /**
       * @param {import('./DataTile.js').ImageLike} image The image.
       */
      setImage(image) {
        this.image_ = image;
      }
      /**
       * @param {number|Array<number>} resolution Resolution.
       */
      setResolution(resolution) {
        this.resolution = resolution;
      }
    };
    Image_default2 = ImageWrapper;
  }
});

// node_modules/ol/style/IconImageCache.js
function getCacheKey(src, crossOrigin, color) {
  const colorString = color ? asArray(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var IconImageCache, IconImageCache_default, shared;
var init_IconImageCache = __esm({
  "node_modules/ol/style/IconImageCache.js"() {
    init_ImageState();
    init_color();
    init_dom();
    IconImageCache = class {
      constructor() {
        this.cache_ = {};
        this.patternCache_ = {};
        this.cacheSize_ = 0;
        this.maxCacheSize_ = 32;
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        this.cache_ = {};
        this.patternCache_ = {};
        this.cacheSize_ = 0;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
      }
      /**
       * FIXME empty description for jsdoc
       */
      expire() {
        if (this.canExpireCache()) {
          let i = 0;
          for (const key in this.cache_) {
            const iconImage = this.cache_[key];
            if ((i++ & 3) === 0 && !iconImage.hasListener()) {
              delete this.cache_[key];
              delete this.patternCache_[key];
              --this.cacheSize_;
            }
          }
        }
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      get(src, crossOrigin, color) {
        const key = getCacheKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @return {CanvasPattern} Icon image.
       */
      getPattern(src, crossOrigin, color) {
        const key = getCacheKey(src, crossOrigin, color);
        return key in this.patternCache_ ? this.patternCache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color|string|null} color Color.
       * @param {import("./IconImage.js").default|null} iconImage Icon image.
       * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
       */
      set(src, crossOrigin, color, iconImage, pattern) {
        const key = getCacheKey(src, crossOrigin, color);
        const update = key in this.cache_;
        this.cache_[key] = iconImage;
        if (pattern) {
          if (iconImage.getImageState() === ImageState_default.IDLE) {
            iconImage.load();
          }
          if (iconImage.getImageState() === ImageState_default.LOADING) {
            iconImage.ready().then(() => {
              this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
                iconImage.getImage(1),
                "repeat"
              );
            });
          } else {
            this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
              iconImage.getImage(1),
              "repeat"
            );
          }
        }
        if (!update) {
          ++this.cacheSize_;
        }
      }
      /**
       * Set the cache size of the icon cache. Default is `32`. Change this value when
       * your map uses more than 32 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
      }
    };
    IconImageCache_default = IconImageCache;
    shared = new IconImageCache();
  }
});

// node_modules/ol/style/IconImage.js
function get4(image, cacheKey, crossOrigin, imageState, color, pattern) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image && "src" in image ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  if (pattern && iconImage && !shared.getPattern(cacheKey, crossOrigin, color)) {
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  return iconImage;
}
var taintedTestContext, IconImage, IconImage_default;
var init_IconImage = __esm({
  "node_modules/ol/style/IconImage.js"() {
    init_Target();
    init_EventType();
    init_ImageState();
    init_color();
    init_dom();
    init_Image2();
    init_IconImageCache();
    taintedTestContext = null;
    IconImage = class extends Target_default {
      /**
       * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
       * @param {string|undefined} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default|undefined} imageState Image state.
       * @param {import("../color.js").Color|string|null} color Color.
       */
      constructor(image, src, crossOrigin, imageState, color) {
        super();
        this.hitDetectionImage_ = null;
        this.image_ = image;
        this.crossOrigin_ = crossOrigin;
        this.canvas_ = {};
        this.color_ = color;
        this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
        this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
        this.src_ = src;
        this.tainted_;
        this.ready_ = null;
      }
      /**
       * @private
       */
      initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      isTainted_() {
        if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
          if (!taintedTestContext) {
            taintedTestContext = createCanvasContext2D(1, 1, void 0, {
              willReadFrequently: true
            });
          }
          taintedTestContext.drawImage(this.image_, 0, 0);
          try {
            taintedTestContext.getImageData(0, 0, 1, 1);
            this.tainted_ = false;
          } catch (e) {
            taintedTestContext = null;
            this.tainted_ = true;
          }
        }
        return this.tainted_ === true;
      }
      /**
       * @private
       */
      dispatchChangeEvent_() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * @private
       */
      handleImageError_() {
        this.imageState_ = ImageState_default.ERROR;
        this.dispatchChangeEvent_();
      }
      /**
       * @private
       */
      handleImageLoad_() {
        this.imageState_ = ImageState_default.LOADED;
        this.size_ = [this.image_.width, this.image_.height];
        this.dispatchChangeEvent_();
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
       */
      getImage(pixelRatio) {
        if (!this.image_) {
          this.initializeImage_();
        }
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        if (!this.image_) {
          this.initializeImage_();
        }
        if (!this.hitDetectionImage_) {
          if (this.isTainted_()) {
            const width = this.size_[0];
            const height = this.size_[1];
            const context = createCanvasContext2D(width, height);
            context.fillRect(0, 0, width, height);
            this.hitDetectionImage_ = context.canvas;
          } else {
            this.hitDetectionImage_ = this.image_;
          }
        }
        return this.hitDetectionImage_;
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      getSize() {
        return this.size_;
      }
      /**
       * @return {string|undefined} Image src.
       */
      getSrc() {
        return this.src_;
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
        if (this.imageState_ !== ImageState_default.IDLE) {
          return;
        }
        if (!this.image_) {
          this.initializeImage_();
        }
        this.imageState_ = ImageState_default.LOADING;
        try {
          if (this.src_ !== void 0) {
            this.image_.src = this.src_;
          }
        } catch (e) {
          this.handleImageError_();
        }
        if (this.image_ instanceof HTMLImageElement) {
          decodeFallback(this.image_, this.src_).then((image) => {
            this.image_ = image;
            this.handleImageLoad_();
          }).catch(this.handleImageError_.bind(this));
        }
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
          return;
        }
        const image = this.image_;
        const canvas = document.createElement("canvas");
        canvas.width = Math.ceil(image.width * pixelRatio);
        canvas.height = Math.ceil(image.height * pixelRatio);
        const ctx = canvas.getContext("2d");
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = "multiply";
        ctx.fillStyle = asString(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
      }
      /**
       * @return {Promise<void>} Promise that resolves when the image is loaded.
       */
      ready() {
        if (!this.ready_) {
          this.ready_ = new Promise((resolve) => {
            if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
              resolve();
            } else {
              this.addEventListener(EventType_default.CHANGE, function onChange() {
                if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
                  this.removeEventListener(EventType_default.CHANGE, onChange);
                  resolve();
                }
              });
            }
          });
        }
        return this.ready_;
      }
    };
    IconImage_default = IconImage;
  }
});

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (!color) {
    return null;
  }
  if (Array.isArray(color)) {
    return toString2(color);
  }
  if (typeof color === "object" && "src" in color) {
    return asCanvasPattern(color);
  }
  return color;
}
function asCanvasPattern(pattern) {
  if (!pattern.offset || !pattern.size) {
    return shared.getPattern(pattern.src, "anonymous", pattern.color);
  }
  const cacheKey = pattern.src + ":" + pattern.offset;
  const canvasPattern = shared.getPattern(
    cacheKey,
    void 0,
    pattern.color
  );
  if (canvasPattern) {
    return canvasPattern;
  }
  const iconImage = shared.get(pattern.src, "anonymous", null);
  if (iconImage.getImageState() !== ImageState_default.LOADED) {
    return null;
  }
  const patternCanvasContext = createCanvasContext2D(
    pattern.size[0],
    pattern.size[1]
  );
  patternCanvasContext.drawImage(
    iconImage.getImage(1),
    pattern.offset[0],
    pattern.offset[1],
    pattern.size[0],
    pattern.size[1],
    0,
    0,
    pattern.size[0],
    pattern.size[1]
  );
  get4(
    patternCanvasContext.canvas,
    cacheKey,
    void 0,
    ImageState_default.LOADED,
    pattern.color,
    true
  );
  return shared.getPattern(cacheKey, void 0, pattern.color);
}
var init_colorlike = __esm({
  "node_modules/ol/colorlike.js"() {
    init_ImageState();
    init_dom();
    init_IconImage();
    init_IconImageCache();
    init_color();
  }
});

// node_modules/ol/css.js
var CLASS_HIDDEN, CLASS_SELECTABLE, CLASS_UNSELECTABLE, CLASS_UNSUPPORTED, CLASS_CONTROL, CLASS_COLLAPSED, fontRegEx, fontRegExMatchIndex, getFontParameters;
var init_css = __esm({
  "node_modules/ol/css.js"() {
    CLASS_HIDDEN = "ol-hidden";
    CLASS_SELECTABLE = "ol-selectable";
    CLASS_UNSELECTABLE = "ol-unselectable";
    CLASS_UNSUPPORTED = "ol-unsupported";
    CLASS_CONTROL = "ol-control";
    CLASS_COLLAPSED = "ol-collapsed";
    fontRegEx = new RegExp(
      [
        "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
        "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
        "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
        "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
        `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
      ].join(""),
      "i"
    );
    fontRegExMatchIndex = [
      "style",
      "variant",
      "weight",
      "size",
      "lineHeight",
      "family"
    ];
    getFontParameters = function(fontSpec) {
      const match = fontSpec.match(fontRegEx);
      if (!match) {
        return null;
      }
      const style = (
        /** @type {FontParameters} */
        {
          lineHeight: "normal",
          size: "1.2em",
          style: "normal",
          weight: "normal",
          variant: "normal"
        }
      );
      for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
        const value = match[i + 1];
        if (value !== void 0) {
          style[fontRegExMatchIndex[i]] = value;
        }
      }
      style.families = style.family.split(/,\s?/);
      return style;
    };
  }
});

// node_modules/ol/render/canvas.js
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache3) {
  if (text in cache3) {
    return cache3[text];
  }
  const width = text.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache3[text] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight = 0;
  for (let i = 0, ii = chunks.length; i <= ii; i += 2) {
    const text = chunks[i];
    if (text === "\n" || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      lineHeight = 0;
      continue;
    }
    const font = chunks[i + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}
function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale5) {
  context.save();
  if (opacity !== 1) {
    if (context.globalAlpha === void 0) {
      context.globalAlpha = (context2) => context2.globalAlpha *= opacity;
    } else {
      context.globalAlpha *= opacity;
    }
  }
  if (transform2) {
    context.transform.apply(context, transform2);
  }
  if (
    /** @type {*} */
    labelOrImage.contextInstructions
  ) {
    context.translate(x, y);
    context.scale(scale5[0], scale5[1]);
    executeLabelInstructions(
      /** @type {Label} */
      labelOrImage,
      context
    );
  } else if (scale5[0] < 0 || scale5[1] < 0) {
    context.translate(x, y);
    context.scale(scale5[0], scale5[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h
    );
  } else {
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale5[0],
      h * scale5[1]
    );
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  const contextInstructions = label.contextInstructions;
  for (let i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(
        context,
        contextInstructions[i + 1]
      );
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}
var defaultFont, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, defaultPadding, defaultLineWidth, checkedFonts, measureContext, measureFont, textHeights, registerFont, measureTextHeight;
var init_canvas = __esm({
  "node_modules/ol/render/canvas.js"() {
    init_Object();
    init_has();
    init_obj();
    init_dom();
    init_css();
    defaultFont = "10px sans-serif";
    defaultFillStyle = "#000";
    defaultLineCap = "round";
    defaultLineDash = [];
    defaultLineDashOffset = 0;
    defaultLineJoin = "round";
    defaultMiterLimit = 10;
    defaultStrokeStyle = "#000";
    defaultTextAlign = "center";
    defaultTextBaseline = "middle";
    defaultPadding = [0, 0, 0, 0];
    defaultLineWidth = 1;
    checkedFonts = new Object_default();
    measureContext = null;
    textHeights = {};
    registerFont = function() {
      const retries = 100;
      const size = "32px ";
      const referenceFonts = ["monospace", "serif"];
      const len = referenceFonts.length;
      const text = "wmytzilWMYTZIL@#/&?$%10\uF013";
      let interval, referenceWidth;
      function isAvailable(fontStyle, fontWeight, fontFamily) {
        let available = true;
        for (let i = 0; i < len; ++i) {
          const referenceFont = referenceFonts[i];
          referenceWidth = measureTextWidth(
            fontStyle + " " + fontWeight + " " + size + referenceFont,
            text
          );
          if (fontFamily != referenceFont) {
            const width = measureTextWidth(
              fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont,
              text
            );
            available = available && width != referenceWidth;
          }
        }
        if (available) {
          return true;
        }
        return false;
      }
      function check() {
        let done = true;
        const fonts = checkedFonts.getKeys();
        for (let i = 0, ii = fonts.length; i < ii; ++i) {
          const font = fonts[i];
          if (checkedFonts.get(font) < retries) {
            if (isAvailable.apply(this, font.split("\n"))) {
              clear(textHeights);
              measureContext = null;
              measureFont = void 0;
              checkedFonts.set(font, retries);
            } else {
              checkedFonts.set(font, checkedFonts.get(font) + 1, true);
              done = false;
            }
          }
        }
        if (done) {
          clearInterval(interval);
          interval = void 0;
        }
      }
      return function(fontSpec) {
        const font = getFontParameters(fontSpec);
        if (!font) {
          return;
        }
        const families = font.families;
        for (let i = 0, ii = families.length; i < ii; ++i) {
          const family = families[i];
          const key = font.style + "\n" + font.weight + "\n" + family;
          if (checkedFonts.get(key) === void 0) {
            checkedFonts.set(key, retries, true);
            if (!isAvailable(font.style, font.weight, family)) {
              checkedFonts.set(key, 0, true);
              if (interval === void 0) {
                interval = setInterval(check, 32);
              }
            }
          }
        }
      };
    }();
    measureTextHeight = /* @__PURE__ */ function() {
      let measureElement;
      return function(fontSpec) {
        let height = textHeights[fontSpec];
        if (height == void 0) {
          if (WORKER_OFFSCREEN_CANVAS) {
            const font = getFontParameters(fontSpec);
            const metrics = measureText(fontSpec, "\u017Dg");
            const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
            height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
          } else {
            if (!measureElement) {
              measureElement = document.createElement("div");
              measureElement.innerHTML = "M";
              measureElement.style.minHeight = "0";
              measureElement.style.maxHeight = "none";
              measureElement.style.height = "auto";
              measureElement.style.padding = "0";
              measureElement.style.border = "none";
              measureElement.style.position = "absolute";
              measureElement.style.display = "block";
              measureElement.style.left = "-99999px";
            }
            measureElement.style.font = fontSpec;
            document.body.appendChild(measureElement);
            height = measureElement.offsetHeight;
            document.body.removeChild(measureElement);
          }
          textHeights[fontSpec] = height;
        }
        return height;
      };
    }();
  }
});

// node_modules/ol/style/RegularShape.js
var RegularShape, RegularShape_default;
var init_RegularShape = __esm({
  "node_modules/ol/style/RegularShape.js"() {
    init_ImageState();
    init_Image();
    init_color();
    init_colorlike();
    init_dom();
    init_canvas();
    RegularShape = class _RegularShape extends Image_default {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        super({
          opacity: 1,
          rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          scale: options.scale !== void 0 ? options.scale : 1,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
        this.canvases_;
        this.hitDetectionCanvas_ = null;
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.origin_ = [0, 0];
        this.points_ = options.points;
        this.radius_ = options.radius;
        this.radius2_ = options.radius2;
        this.angle_ = options.angle !== void 0 ? options.angle : 0;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.size_;
        this.renderOptions_;
        this.imageState_ = this.fill_ && this.fill_.loading() ? ImageState_default.LOADING : ImageState_default.LOADED;
        if (this.imageState_ === ImageState_default.LOADING) {
          this.ready().then(() => this.imageState_ = ImageState_default.LOADED);
        }
        this.render();
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       */
      clone() {
        const scale5 = this.getScale();
        const style = new _RegularShape({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          points: this.getPoints(),
          radius: this.getRadius(),
          radius2: this.getRadius2(),
          angle: this.getAngle(),
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale5) ? scale5.slice() : scale5,
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      getAnchor() {
        const size = this.size_;
        const displacement = this.getDisplacement();
        const scale5 = this.getScaleArray();
        return [
          size[0] / 2 - displacement[0] / scale5[0],
          size[1] / 2 + displacement[1] / scale5[1]
        ];
      }
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      getAngle() {
        return this.angle_;
      }
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
        this.render();
      }
      /**
       * @return {HTMLCanvasElement} Image element.
       */
      getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) {
          this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
            this.renderOptions_
          );
        }
        return this.hitDetectionCanvas_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       */
      getImage(pixelRatio) {
        let image = this.canvases_[pixelRatio];
        if (!image) {
          const renderOptions = this.renderOptions_;
          const context = createCanvasContext2D(
            renderOptions.size * pixelRatio,
            renderOptions.size * pixelRatio
          );
          this.draw_(renderOptions, context, pixelRatio);
          image = context.canvas;
          this.canvases_[pixelRatio] = image;
        }
        return image;
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return pixelRatio;
      }
      /**
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return this.size_;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      getOrigin() {
        return this.origin_;
      }
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      getPoints() {
        return this.points_;
      }
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return this.radius_;
      }
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      getRadius2() {
        return this.radius2_;
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       */
      getSize() {
        return this.size_;
      }
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
      }
      /**
       * Calculate additional canvas size needed for the miter.
       * @param {string} lineJoin Line join
       * @param {number} strokeWidth Stroke width
       * @param {number} miterLimit Miter limit
       * @return {number} Additional canvas size needed
       * @private
       */
      calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
          return strokeWidth;
        }
        let r1 = this.radius_;
        let r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
        if (r1 < r2) {
          const tmp = r1;
          r1 = r2;
          r2 = tmp;
        }
        const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a = r2 * Math.sin(alpha);
        const b = Math.sqrt(r2 * r2 - a * a);
        const d = r1 - b;
        const e = Math.sqrt(a * a + d * d);
        const miterRatio = e / a;
        if (lineJoin === "miter" && miterRatio <= miterLimit) {
          return miterRatio * strokeWidth;
        }
        const k = strokeWidth / 2 / miterRatio;
        const l = strokeWidth / 2 * (d / e);
        const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === void 0 || lineJoin === "bevel") {
          return bevelAdd * 2;
        }
        const aa = r1 * Math.sin(alpha);
        const bb = Math.sqrt(r1 * r1 - aa * aa);
        const dd = r2 - bb;
        const ee = Math.sqrt(aa * aa + dd * dd);
        const innerMiterRatio = ee / aa;
        if (innerMiterRatio <= miterLimit) {
          const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
          return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
      }
      /**
       * @return {RenderOptions}  The render options
       * @protected
       */
      createRenderOptions() {
        let lineCap = defaultLineCap;
        let lineJoin = defaultLineJoin;
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
          strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
          strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
          lineDash = this.stroke_.getLineDash();
          lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
          lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
          lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
          miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
        }
        const add4 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add4);
        return {
          strokeStyle,
          strokeWidth,
          size,
          lineCap,
          lineDash,
          lineDashOffset,
          lineJoin,
          miterLimit
        };
      }
      /**
       * @protected
       */
      render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.canvases_ = {};
        this.hitDetectionCanvas_ = null;
        this.size_ = [size, size];
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} pixelRatio The pixel ratio.
       */
      draw_(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
          let color = this.fill_.getColor();
          if (color === null) {
            color = defaultFillStyle;
          }
          context.fillStyle = asColorLike(color);
          context.fill();
        }
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineCap = renderOptions.lineCap;
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @return {HTMLCanvasElement} Canvas containing the icon
       */
      createHitDetectionCanvas_(renderOptions) {
        let context;
        if (this.fill_) {
          let color = this.fill_.getColor();
          let opacity = 0;
          if (typeof color === "string") {
            color = asArray(color);
          }
          if (color === null) {
            opacity = 1;
          } else if (Array.isArray(color)) {
            opacity = color.length === 4 ? color[3] : 1;
          }
          if (opacity === 0) {
            context = createCanvasContext2D(renderOptions.size, renderOptions.size);
            this.drawHitDetectionCanvas_(renderOptions, context);
          }
        }
        return context ? context.canvas : this.getImage(1);
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context The context to draw in.
       */
      createPath_(context) {
        let points = this.points_;
        const radius = this.radius_;
        if (points === Infinity) {
          context.arc(0, 0, radius, 0, 2 * Math.PI);
        } else {
          const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
          if (this.radius2_ !== void 0) {
            points *= 2;
          }
          const startAngle = this.angle_ - Math.PI / 2;
          const step = 2 * Math.PI / points;
          for (let i = 0; i < points; i++) {
            const angle0 = startAngle + i * step;
            const radiusC = i % 2 === 0 ? radius : radius2;
            context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
          }
          context.closePath();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       */
      drawHitDetectionCanvas_(renderOptions, context) {
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = defaultFillStyle;
        context.fill();
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
      ready() {
        return this.fill_ ? this.fill_.ready() : Promise.resolve();
      }
    };
    RegularShape_default = RegularShape;
  }
});

// node_modules/ol/style/Circle.js
var CircleStyle, Circle_default;
var init_Circle = __esm({
  "node_modules/ol/style/Circle.js"() {
    init_RegularShape();
    CircleStyle = class _CircleStyle extends RegularShape_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options ? options : { radius: 5 };
        super({
          points: Infinity,
          fill: options.fill,
          radius: options.radius,
          stroke: options.stroke,
          scale: options.scale !== void 0 ? options.scale : 1,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       */
      clone() {
        const scale5 = this.getScale();
        const style = new _CircleStyle({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          radius: this.getRadius(),
          scale: Array.isArray(scale5) ? scale5.slice() : scale5,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      setRadius(radius) {
        this.radius_ = radius;
        this.render();
      }
    };
    Circle_default = CircleStyle;
  }
});

// node_modules/ol/style/Fill.js
var Fill, Fill_default;
var init_Fill = __esm({
  "node_modules/ol/style/Fill.js"() {
    init_ImageState();
    init_IconImage();
    Fill = class _Fill {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.patternImage_ = null;
        this.color_ = null;
        if (options.color !== void 0) {
          this.setColor(options.color);
        }
      }
      /**
       * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Fill({
          color: Array.isArray(color) ? color.slice() : color || void 0
        });
      }
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
       * @api
       */
      setColor(color) {
        if (color !== null && typeof color === "object" && "src" in color) {
          const patternImage = get4(
            null,
            color.src,
            "anonymous",
            void 0,
            color.offset ? null : color.color ? color.color : null,
            !(color.offset && color.size)
          );
          patternImage.ready().then(() => {
            this.patternImage_ = null;
          });
          if (patternImage.getImageState() === ImageState_default.IDLE) {
            patternImage.load();
          }
          if (patternImage.getImageState() === ImageState_default.LOADING) {
            this.patternImage_ = patternImage;
          }
        }
        this.color_ = color;
      }
      /**
       * @return {boolean} The fill style is loading an image pattern.
       */
      loading() {
        return !!this.patternImage_;
      }
      /**
       * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
       */
      ready() {
        return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
      }
    };
    Fill_default = Fill;
  }
});

// node_modules/ol/style/Stroke.js
var Stroke, Stroke_default;
var init_Stroke = __esm({
  "node_modules/ol/style/Stroke.js"() {
    Stroke = class _Stroke {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.color_ = options.color !== void 0 ? options.color : null;
        this.lineCap_ = options.lineCap;
        this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
        this.lineDashOffset_ = options.lineDashOffset;
        this.lineJoin_ = options.lineJoin;
        this.miterLimit_ = options.miterLimit;
        this.width_ = options.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Stroke({
          color: Array.isArray(color) ? color.slice() : color || void 0,
          lineCap: this.getLineCap(),
          lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
          lineDashOffset: this.getLineDashOffset(),
          lineJoin: this.getLineJoin(),
          miterLimit: this.getMiterLimit(),
          width: this.getWidth()
        });
      }
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      getLineCap() {
        return this.lineCap_;
      }
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>|null} Line dash.
       * @api
       */
      getLineDash() {
        return this.lineDash_;
      }
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      getLineDashOffset() {
        return this.lineDashOffset_;
      }
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      getLineJoin() {
        return this.lineJoin_;
      }
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      getMiterLimit() {
        return this.miterLimit_;
      }
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      getWidth() {
        return this.width_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      setColor(color) {
        this.color_ = color;
      }
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      setLineCap(lineCap) {
        this.lineCap_ = lineCap;
      }
      /**
       * Set the line dash.
       *
       * @param {Array<number>|null} lineDash Line dash.
       * @api
       */
      setLineDash(lineDash) {
        this.lineDash_ = lineDash;
      }
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
      }
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
      }
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
      }
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      setWidth(width) {
        this.width_ = width;
      }
    };
    Stroke_default = Stroke;
  }
});

// node_modules/ol/style/Style.js
var Style_exports = {};
__export(Style_exports, {
  createDefaultStyle: () => createDefaultStyle,
  createEditingStyle: () => createEditingStyle,
  default: () => Style_default,
  toFunction: () => toFunction
});
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(
        typeof /** @type {?} */
        obj.getZIndex === "function",
        "Expected an `Style` or an array of `Style`"
      );
      const style = (
        /** @type {Style} */
        obj
      );
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill_default({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke_default({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new Circle_default({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function createEditingStyle() {
  const styles = {};
  const white = [255, 255, 255, 1];
  const blue = [0, 153, 255, 1];
  const width = 3;
  styles["Polygon"] = [
    new Style({
      fill: new Fill_default({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles["MultiPolygon"] = styles["Polygon"];
  styles["LineString"] = [
    new Style({
      stroke: new Stroke_default({
        color: white,
        width: width + 2
      })
    }),
    new Style({
      stroke: new Stroke_default({
        color: blue,
        width
      })
    })
  ];
  styles["MultiLineString"] = styles["LineString"];
  styles["Circle"] = styles["Polygon"].concat(styles["LineString"]);
  styles["Point"] = [
    new Style({
      image: new Circle_default({
        radius: width * 2,
        fill: new Fill_default({
          color: blue
        }),
        stroke: new Stroke_default({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles["MultiPoint"] = styles["Point"];
  styles["GeometryCollection"] = styles["Polygon"].concat(
    styles["LineString"],
    styles["Point"]
  );
  return styles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style, defaultStyles, Style_default;
var init_Style = __esm({
  "node_modules/ol/style/Style.js"() {
    init_Circle();
    init_Fill();
    init_Stroke();
    init_asserts();
    Style = class _Style {
      /**
       * @param {Options} [options] Style options.
       */
      constructor(options) {
        options = options || {};
        this.geometry_ = null;
        this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== void 0) {
          this.setGeometry(options.geometry);
        }
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.image_ = options.image !== void 0 ? options.image : null;
        this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
        this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.text_ = options.text !== void 0 ? options.text : null;
        this.zIndex_ = options.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === "object") {
          geometry = /** @type {import("../geom/Geometry.js").default} */
          geometry.clone();
        }
        return new _Style({
          geometry: geometry ?? void 0,
          fill: this.getFill() ? this.getFill().clone() : void 0,
          image: this.getImage() ? this.getImage().clone() : void 0,
          renderer: this.getRenderer() ?? void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          text: this.getText() ? this.getText().clone() : void 0,
          zIndex: this.getZIndex()
        });
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getRenderer() {
        return this.renderer_;
      }
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setRenderer(renderer) {
        this.renderer_ = renderer;
      }
      /**
       * Sets a custom renderer function for this style used
       * in hit detection.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
      }
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      getGeometry() {
        return this.geometry_;
      }
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      getGeometryFunction() {
        return this.geometryFunction_;
      }
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Get the image style.
       * @return {import("./Image.js").default|null} Image style.
       * @api
       */
      getImage() {
        return this.image_;
      }
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      setImage(image) {
        this.image_ = image;
      }
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Get the text style.
       * @return {import("./Text.js").default|null} Text style.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      setText(text) {
        this.text_ = text;
      }
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      getZIndex() {
        return this.zIndex_;
      }
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      setGeometry(geometry) {
        if (typeof geometry === "function") {
          this.geometryFunction_ = geometry;
        } else if (typeof geometry === "string") {
          this.geometryFunction_ = function(feature) {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              feature.get(geometry)
            );
          };
        } else if (!geometry) {
          this.geometryFunction_ = defaultGeometryFunction;
        } else if (geometry !== void 0) {
          this.geometryFunction_ = function() {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              geometry
            );
          };
        }
        this.geometry_ = geometry;
      }
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      setZIndex(zIndex) {
        this.zIndex_ = zIndex;
      }
    };
    defaultStyles = null;
    Style_default = Style;
  }
});

// node_modules/ol/style/Icon.js
var Icon_exports = {};
__export(Icon_exports, {
  default: () => Icon_default
});
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== void 0 && wantedHeight !== void 0) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== void 0) {
    return wantedWidth / width;
  }
  if (wantedHeight !== void 0) {
    return wantedHeight / height;
  }
  return 1;
}
var Icon, Icon_default;
var init_Icon = __esm({
  "node_modules/ol/style/Icon.js"() {
    init_EventType();
    init_ImageState();
    init_Image();
    init_color();
    init_asserts();
    init_IconImage();
    init_util();
    Icon = class _Icon extends Image_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        const opacity = options.opacity !== void 0 ? options.opacity : 1;
        const rotation = options.rotation !== void 0 ? options.rotation : 0;
        const scale5 = options.scale !== void 0 ? options.scale : 1;
        const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
        super({
          opacity,
          rotation,
          scale: scale5,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          rotateWithView,
          declutterMode: options.declutterMode
        });
        this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
        this.normalizedAnchor_ = null;
        this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
        this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
        this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
        this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
        const image = options.img !== void 0 ? options.img : null;
        let cacheKey = options.src;
        assert(
          !(cacheKey !== void 0 && image),
          "`image` and `src` cannot be provided at the same time"
        );
        if ((cacheKey === void 0 || cacheKey.length === 0) && image) {
          cacheKey = /** @type {HTMLImageElement} */
          image.src || getUid(image);
        }
        assert(
          cacheKey !== void 0 && cacheKey.length > 0,
          "A defined and non-empty `src` or `image` must be provided"
        );
        assert(
          !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
          "`width` or `height` cannot be provided together with `scale`"
        );
        let imageState;
        if (options.src !== void 0) {
          imageState = ImageState_default.IDLE;
        } else if (image !== void 0) {
          if ("complete" in image) {
            if (image.complete) {
              imageState = image.src ? ImageState_default.LOADED : ImageState_default.IDLE;
            } else {
              imageState = ImageState_default.LOADING;
            }
          } else {
            imageState = ImageState_default.LOADED;
          }
        }
        this.color_ = options.color !== void 0 ? asArray(options.color) : null;
        this.iconImage_ = get4(
          image,
          /** @type {string} */
          cacheKey,
          this.crossOrigin_,
          imageState,
          this.color_
        );
        this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
        this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
        this.origin_ = null;
        this.size_ = options.size !== void 0 ? options.size : null;
        if (options.width !== void 0 || options.height !== void 0) {
          let width, height;
          if (options.size) {
            [width, height] = options.size;
          } else {
            const image2 = this.getImage(1);
            if (image2.width && image2.height) {
              width = image2.width;
              height = image2.height;
            } else if (image2 instanceof HTMLImageElement) {
              this.initialOptions_ = options;
              const onload = () => {
                this.unlistenImageChange(onload);
                if (!this.initialOptions_) {
                  return;
                }
                const imageSize = this.iconImage_.getSize();
                this.setScale(
                  calculateScale(
                    imageSize[0],
                    imageSize[1],
                    options.width,
                    options.height
                  )
                );
              };
              this.listenImageChange(onload);
              return;
            }
          }
          if (width !== void 0) {
            this.setScale(
              calculateScale(width, height, options.width, options.height)
            );
          }
        }
      }
      /**
       * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
       * @return {Icon} The cloned style.
       * @api
       */
      clone() {
        let scale5, width, height;
        if (this.initialOptions_) {
          width = this.initialOptions_.width;
          height = this.initialOptions_.height;
        } else {
          scale5 = this.getScale();
          scale5 = Array.isArray(scale5) ? scale5.slice() : scale5;
        }
        return new _Icon({
          anchor: this.anchor_.slice(),
          anchorOrigin: this.anchorOrigin_,
          anchorXUnits: this.anchorXUnits_,
          anchorYUnits: this.anchorYUnits_,
          color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
          crossOrigin: this.crossOrigin_,
          offset: this.offset_.slice(),
          offsetOrigin: this.offsetOrigin_,
          opacity: this.getOpacity(),
          rotateWithView: this.getRotateWithView(),
          rotation: this.getRotation(),
          scale: scale5,
          width,
          height,
          size: this.size_ !== null ? this.size_.slice() : void 0,
          src: this.getSrc(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      getAnchor() {
        let anchor = this.normalizedAnchor_;
        if (!anchor) {
          anchor = this.anchor_;
          const size = this.getSize();
          if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
            if (!size) {
              return null;
            }
            anchor = this.anchor_.slice();
            if (this.anchorXUnits_ == "fraction") {
              anchor[0] *= size[0];
            }
            if (this.anchorYUnits_ == "fraction") {
              anchor[1] *= size[1];
            }
          }
          if (this.anchorOrigin_ != "top-left") {
            if (!size) {
              return null;
            }
            if (anchor === this.anchor_) {
              anchor = this.anchor_.slice();
            }
            if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
              anchor[0] = -anchor[0] + size[0];
            }
            if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
              anchor[1] = -anchor[1] + size[1];
            }
          }
          this.normalizedAnchor_ = anchor;
        }
        const displacement = this.getDisplacement();
        const scale5 = this.getScaleArray();
        return [
          anchor[0] - displacement[0] / scale5[0],
          anchor[1] + displacement[1] / scale5[1]
        ];
      }
      /**
       * Set the anchor point. The anchor determines the center point for the
       * symbolizer.
       *
       * @param {Array<number>} anchor Anchor.
       * @api
       */
      setAnchor(anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
      }
      /**
       * Get the icon color.
       * @return {import("../color.js").Color} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
       * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
       * @api
       */
      getImage(pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
      }
      /**
       * Get the pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} The pixel ratio of the image.
       * @api
       */
      getPixelRatio(pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
      }
      /**
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return this.iconImage_.getSize();
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.iconImage_.getImageState();
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage();
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      getOrigin() {
        if (this.origin_) {
          return this.origin_;
        }
        let offset2 = this.offset_;
        if (this.offsetOrigin_ != "top-left") {
          const size = this.getSize();
          const iconImageSize = this.iconImage_.getSize();
          if (!size || !iconImageSize) {
            return null;
          }
          offset2 = offset2.slice();
          if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
            offset2[0] = iconImageSize[0] - size[0] - offset2[0];
          }
          if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
            offset2[1] = iconImageSize[1] - size[1] - offset2[1];
          }
        }
        this.origin_ = offset2;
        return this.origin_;
      }
      /**
       * Get the image URL.
       * @return {string|undefined} Image src.
       * @api
       */
      getSrc() {
        return this.iconImage_.getSrc();
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       * @api
       */
      getSize() {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
      }
      /**
       * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
       * @return {number} Icon width (in pixels).
       * @api
       */
      getWidth() {
        const scale5 = this.getScaleArray();
        if (this.size_) {
          return this.size_[0] * scale5[0];
        }
        if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
          return this.iconImage_.getSize()[0] * scale5[0];
        }
        return void 0;
      }
      /**
       * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
       * @return {number} Icon height (in pixels).
       * @api
       */
      getHeight() {
        const scale5 = this.getScaleArray();
        if (this.size_) {
          return this.size_[1] * scale5[1];
        }
        if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
          return this.iconImage_.getSize()[1] * scale5[1];
        }
        return void 0;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale5) {
        delete this.initialOptions_;
        super.setScale(scale5);
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
      }
      /**
       * Load not yet loaded URI.
       * When rendering a feature with an icon style, the vector renderer will
       * automatically call this method. However, you might want to call this
       * method yourself for preloading or other purposes.
       * @api
       */
      load() {
        this.iconImage_.load();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
      }
      ready() {
        return this.iconImage_.ready();
      }
    };
    Icon_default = Icon;
  }
});

// node_modules/ol/style/Text.js
var DEFAULT_FILL_COLOR, Text, Text_default;
var init_Text = __esm({
  "node_modules/ol/style/Text.js"() {
    init_Fill();
    init_size();
    DEFAULT_FILL_COLOR = "#333";
    Text = class _Text {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.font_ = options.font;
        this.rotation_ = options.rotation;
        this.rotateWithView_ = options.rotateWithView;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
        this.text_ = options.text;
        this.textAlign_ = options.textAlign;
        this.justify_ = options.justify;
        this.repeat_ = options.repeat;
        this.textBaseline_ = options.textBaseline;
        this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
        this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
        this.placement_ = options.placement !== void 0 ? options.placement : "point";
        this.overflow_ = !!options.overflow;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
        this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
        this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
        this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
        this.padding_ = options.padding === void 0 ? null : options.padding;
        this.declutterMode_ = options.declutterMode;
      }
      /**
       * Clones the style.
       * @return {Text} The cloned style.
       * @api
       */
      clone() {
        const scale5 = this.getScale();
        return new _Text({
          font: this.getFont(),
          placement: this.getPlacement(),
          repeat: this.getRepeat(),
          maxAngle: this.getMaxAngle(),
          overflow: this.getOverflow(),
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale5) ? scale5.slice() : scale5,
          text: this.getText(),
          textAlign: this.getTextAlign(),
          justify: this.getJustify(),
          textBaseline: this.getTextBaseline(),
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          offsetX: this.getOffsetX(),
          offsetY: this.getOffsetY(),
          backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
          backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
          padding: this.getPadding() || void 0,
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the `overflow` configuration.
       * @return {boolean} Let text overflow the length of the path they follow.
       * @api
       */
      getOverflow() {
        return this.overflow_;
      }
      /**
       * Get the font name.
       * @return {string|undefined} Font.
       * @api
       */
      getFont() {
        return this.font_;
      }
      /**
       * Get the maximum angle between adjacent characters.
       * @return {number} Angle in radians.
       * @api
       */
      getMaxAngle() {
        return this.maxAngle_;
      }
      /**
       * Get the label placement.
       * @return {TextPlacement} Text placement.
       * @api
       */
      getPlacement() {
        return this.placement_;
      }
      /**
       * Get the repeat interval of the text.
       * @return {number|undefined} Repeat interval in pixels.
       * @api
       */
      getRepeat() {
        return this.repeat_;
      }
      /**
       * Get the x-offset for the text.
       * @return {number} Horizontal text offset.
       * @api
       */
      getOffsetX() {
        return this.offsetX_;
      }
      /**
       * Get the y-offset for the text.
       * @return {number} Vertical text offset.
       * @api
       */
      getOffsetY() {
        return this.offsetY_;
      }
      /**
       * Get the fill style for the text.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Determine whether the text rotates with the map.
       * @return {boolean|undefined} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the text rotation.
       * @return {number|undefined} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the text scale.
       * @return {number|import("../size.js").Size|undefined} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the stroke style for the text.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Get the text to be rendered.
       * @return {string|Array<string>|undefined} Text.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Get the text alignment.
       * @return {CanvasTextAlign|undefined} Text align.
       * @api
       */
      getTextAlign() {
        return this.textAlign_;
      }
      /**
       * Get the justification.
       * @return {TextJustify|undefined} Justification.
       * @api
       */
      getJustify() {
        return this.justify_;
      }
      /**
       * Get the text baseline.
       * @return {CanvasTextBaseline|undefined} Text baseline.
       * @api
       */
      getTextBaseline() {
        return this.textBaseline_;
      }
      /**
       * Get the background fill style for the text.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getBackgroundFill() {
        return this.backgroundFill_;
      }
      /**
       * Get the background stroke style for the text.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getBackgroundStroke() {
        return this.backgroundStroke_;
      }
      /**
       * Get the padding for the text.
       * @return {Array<number>|null} Padding.
       * @api
       */
      getPadding() {
        return this.padding_;
      }
      /**
       * Get the declutter mode of the shape
       * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
       * @api
       */
      getDeclutterMode() {
        return this.declutterMode_;
      }
      /**
       * Set the `overflow` property.
       *
       * @param {boolean} overflow Let text overflow the path that it follows.
       * @api
       */
      setOverflow(overflow) {
        this.overflow_ = overflow;
      }
      /**
       * Set the font.
       *
       * @param {string|undefined} font Font.
       * @api
       */
      setFont(font) {
        this.font_ = font;
      }
      /**
       * Set the maximum angle between adjacent characters.
       *
       * @param {number} maxAngle Angle in radians.
       * @api
       */
      setMaxAngle(maxAngle) {
        this.maxAngle_ = maxAngle;
      }
      /**
       * Set the x offset.
       *
       * @param {number} offsetX Horizontal text offset.
       * @api
       */
      setOffsetX(offsetX) {
        this.offsetX_ = offsetX;
      }
      /**
       * Set the y offset.
       *
       * @param {number} offsetY Vertical text offset.
       * @api
       */
      setOffsetY(offsetY) {
        this.offsetY_ = offsetY;
      }
      /**
       * Set the text placement.
       *
       * @param {TextPlacement} placement Placement.
       * @api
       */
      setPlacement(placement) {
        this.placement_ = placement;
      }
      /**
       * Set the repeat interval of the text.
       * @param {number|undefined} [repeat] Repeat interval in pixels.
       * @api
       */
      setRepeat(repeat) {
        this.repeat_ = repeat;
      }
      /**
       * Set whether to rotate the text with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the fill.
       *
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Set the rotation.
       *
       * @param {number|undefined} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size|undefined} scale Scale.
       * @api
       */
      setScale(scale5) {
        this.scale_ = scale5;
        this.scaleArray_ = toSize(scale5 !== void 0 ? scale5 : 1);
      }
      /**
       * Set the stroke.
       *
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Set the text.
       *
       * @param {string|Array<string>|undefined} text Text.
       * @api
       */
      setText(text) {
        this.text_ = text;
      }
      /**
       * Set the text alignment.
       *
       * @param {CanvasTextAlign|undefined} textAlign Text align.
       * @api
       */
      setTextAlign(textAlign) {
        this.textAlign_ = textAlign;
      }
      /**
       * Set the justification.
       *
       * @param {TextJustify|undefined} justify Justification.
       * @api
       */
      setJustify(justify) {
        this.justify_ = justify;
      }
      /**
       * Set the text baseline.
       *
       * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
       * @api
       */
      setTextBaseline(textBaseline) {
        this.textBaseline_ = textBaseline;
      }
      /**
       * Set the background fill.
       *
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setBackgroundFill(fill) {
        this.backgroundFill_ = fill;
      }
      /**
       * Set the background stroke.
       *
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setBackgroundStroke(stroke) {
        this.backgroundStroke_ = stroke;
      }
      /**
       * Set the padding (`[top, right, bottom, left]`).
       *
       * @param {Array<number>|null} padding Padding.
       * @api
       */
      setPadding(padding) {
        this.padding_ = padding;
      }
    };
    Text_default = Text;
  }
});

// node_modules/ol/expr/expression.js
function typeName(type) {
  const names2 = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names2.push(typeNames[namedType]);
    }
  }
  if (names2.length === 0) {
    return "untyped";
  }
  if (names2.length < 3) {
    return names2.join(" or ");
  }
  return names2.slice(0, -1).join(", ") + ", or " + names2[names2.length - 1];
}
function includesType(broad, specific) {
  return (broad & specific) === specific;
}
function overlapsType(oneType, otherType) {
  return !!(oneType & otherType);
}
function isType(type, expected) {
  return type === expected;
}
function newParsingContext() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: false,
    geometryType: false,
    style: {}
  };
}
function getTypeFromHint(typeHint) {
  switch (typeHint) {
    case "string":
      return StringType;
    case "color":
      return ColorType;
    case "number":
      return NumberType;
    case "boolean":
      return BooleanType;
    case "number[]":
      return NumberArrayType;
    default:
      throw new Error(`Unrecognized type hint: ${typeHint}`);
  }
}
function parse2(encoded, context, typeHint) {
  switch (typeof encoded) {
    case "boolean": {
      return new LiteralExpression(BooleanType, encoded);
    }
    case "number": {
      return new LiteralExpression(
        typeHint === SizeType ? SizeType : NumberType,
        encoded
      );
    }
    case "string": {
      let type2 = StringType;
      if (isStringColor(encoded)) {
        type2 |= ColorType;
      }
      if (!isType(type2 & typeHint, NoneType)) {
        type2 &= typeHint;
      }
      return new LiteralExpression(type2, encoded);
    }
    default: {
    }
  }
  if (!Array.isArray(encoded)) {
    throw new Error("Expression must be an array or a primitive value");
  }
  if (encoded.length === 0) {
    throw new Error("Empty expression");
  }
  if (typeof encoded[0] === "string") {
    return parseCallExpression(encoded, context, typeHint);
  }
  for (const item of encoded) {
    if (typeof item !== "number") {
      throw new Error("Expected an array of numbers");
    }
  }
  let type = NumberArrayType;
  if (encoded.length === 2) {
    type |= SizeType;
  } else if (encoded.length === 3 || encoded.length === 4) {
    type |= ColorType;
  }
  if (typeHint) {
    type &= typeHint;
  }
  return new LiteralExpression(type, encoded);
}
function withGetArgs(encoded, context) {
  const arg = parse2(encoded[1], context);
  if (!(arg instanceof LiteralExpression)) {
    throw new Error("Expected a literal argument for get operation");
  }
  if (typeof arg.value !== "string") {
    throw new Error("Expected a string argument for get operation");
  }
  context.properties.add(arg.value);
  if (encoded.length === 3) {
    const hint = parse2(encoded[2], context);
    return [arg, hint];
  }
  return [arg];
}
function withVarArgs(encoded, context, parsedArgs, typeHint) {
  const varName = encoded[1];
  if (typeof varName !== "string") {
    throw new Error("Expected a string argument for var operation");
  }
  context.variables.add(varName);
  if (!("variables" in context.style) || context.style.variables[varName] === void 0) {
    return [new LiteralExpression(AnyType, varName)];
  }
  const initialValue = context.style.variables[varName];
  const arg = (
    /** @type {LiteralExpression} */
    parse2(initialValue, context)
  );
  arg.value = varName;
  if (typeHint && !overlapsType(typeHint, arg.type)) {
    throw new Error(
      `The variable ${varName} has type ${typeName(
        arg.type
      )} but the following type was expected: ${typeName(typeHint)}`
    );
  }
  return [arg];
}
function usesFeatureId(encoded, context) {
  context.featureId = true;
}
function usesGeometryType(encoded, context) {
  context.geometryType = true;
}
function withNoArgs(encoded, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`Expected no arguments for ${operation} operation`);
  }
  return [];
}
function withArgsCount(minArgs, maxArgs) {
  return function(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? "" : "s";
        throw new Error(
          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
      throw new Error(
        `Expected ${range} arguments for ${operation}, got ${argCount}`
      );
    }
  };
}
function parseArgsOfType(argType) {
  return function(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    const args = new Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse2(encoded[i + 1], context);
      if (!overlapsType(argType, expression.type)) {
        const gotType = typeName(argType);
        const expectedType = typeName(expression.type);
        throw new Error(
          `Unexpected type for argument ${i} of ${operation} operation, got ${gotType} but expected ${expectedType}`
        );
      }
      expression.type &= argType;
      args[i] = expression;
    }
    return args;
  };
}
function narrowArgsType(encoded, context, parsedArgs) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  let sameType = AnyType;
  for (let i = 0; i < parsedArgs.length; ++i) {
    sameType &= parsedArgs[i].type;
  }
  if (sameType === NoneType) {
    throw new Error(
      `No common type could be found for arguments of ${operation} operation`
    );
  }
  const args = new Array(argCount);
  for (let i = 0; i < argCount; ++i) {
    args[i] = parse2(encoded[i + 1], context, sameType);
  }
  return args;
}
function withOddArgs(encoded, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error(
      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(
        argCount
      )} instead`
    );
  }
}
function withEvenArgs(encoded, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error(
      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(
        argCount
      )} instead`
    );
  }
}
function parseMatchArgs(encoded, context, parsedArgs, typeHint) {
  const argsCount = encoded.length - 1;
  const input = parse2(encoded[1], context);
  let inputType = input.type;
  const fallback = parse2(encoded[encoded.length - 1], context);
  let outputType = typeHint !== void 0 ? typeHint & fallback.type : fallback.type;
  const args = new Array(argsCount - 2);
  for (let i = 0; i < argsCount - 2; i += 2) {
    const match = parse2(encoded[i + 2], context);
    const output = parse2(encoded[i + 3], context);
    inputType &= match.type;
    outputType &= output.type;
    args[i] = match;
    args[i + 1] = output;
  }
  const expectedInputType = StringType | NumberType | BooleanType;
  if (!overlapsType(expectedInputType, inputType)) {
    throw new Error(
      `Expected an input of type ${typeName(
        expectedInputType
      )} for the interpolate operation, got ${typeName(inputType)} instead`
    );
  }
  inputType &= expectedInputType;
  if (isType(outputType, NoneType)) {
    throw new Error(
      `Could not find a common output type for the following match operation: ` + JSON.stringify(encoded)
    );
  }
  for (let i = 0; i < argsCount - 2; i += 2) {
    const match = parse2(encoded[i + 2], context, inputType);
    const output = parse2(encoded[i + 3], context, outputType);
    args[i] = match;
    args[i + 1] = output;
  }
  return [
    parse2(encoded[1], context, inputType),
    ...args,
    parse2(encoded[encoded.length - 1], context, outputType)
  ];
}
function parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {
  const interpolationType = encoded[1];
  let interpolation;
  switch (interpolationType[0]) {
    case "linear":
      interpolation = 1;
      break;
    case "exponential":
      interpolation = interpolationType[1];
      if (typeof interpolation !== "number") {
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(interpolation)} instead`
        );
      }
      break;
    default:
      interpolation = null;
  }
  if (!interpolation) {
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`
    );
  }
  interpolation = parse2(interpolation, context);
  let input = parse2(encoded[2], context);
  if (!overlapsType(NumberType, input.type)) {
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${typeName(input.type)} instead`
    );
  }
  input = parse2(encoded[2], context, NumberType);
  const args = new Array(encoded.length - 3);
  for (let i = 0; i < args.length; i += 2) {
    let stop = parse2(encoded[i + 3], context);
    if (!overlapsType(NumberType, stop.type)) {
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${typeName(stop.type)} at position ${i + 2} instead`
      );
    }
    let output = parse2(encoded[i + 4], context);
    if (!overlapsType(NumberType | ColorType, output.type)) {
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${typeName(output.type)} at position ${i + 3} instead`
      );
    }
    stop = parse2(encoded[i + 3], context, NumberType);
    output = parse2(encoded[i + 4], context, NumberType | ColorType);
    args[i] = stop;
    args[i + 1] = output;
  }
  return [interpolation, input, ...args];
}
function parseCaseArgs(encoded, context, parsedArgs, typeHint) {
  const fallback = parse2(encoded[encoded.length - 1], context, typeHint);
  let outputType = typeHint !== void 0 ? typeHint & fallback.type : fallback.type;
  const args = new Array(encoded.length - 1);
  for (let i = 0; i < args.length - 1; i += 2) {
    const condition = parse2(encoded[i + 1], context);
    const output = parse2(encoded[i + 2], context, typeHint);
    if (!overlapsType(BooleanType, condition.type)) {
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${typeName(condition.type)} at position ${i} instead`
      );
    }
    outputType &= output.type;
    args[i] = condition;
    args[i + 1] = output;
  }
  if (isType(outputType, NoneType)) {
    throw new Error(
      `Could not find a common output type for the following case operation: ` + JSON.stringify(encoded)
    );
  }
  for (let i = 0; i < args.length - 1; i += 2) {
    args[i + 1] = parse2(encoded[i + 2], context, outputType);
  }
  args[args.length - 1] = parse2(
    encoded[encoded.length - 1],
    context,
    outputType
  );
  return args;
}
function parseInArgs(encoded, context) {
  let haystack = (
    /** @type {any} */
    encoded[2]
  );
  if (!Array.isArray(haystack)) {
    throw new Error(
      `The "in" operator was provided a literal value which was not an array as second argument.`
    );
  }
  if (typeof haystack[0] === "string") {
    if (haystack[0] !== "literal") {
      throw new Error(
        `For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.`
      );
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error(
        `The "in" operator was provided a literal value which was not an array as second argument.`
      );
    }
    haystack = haystack[1];
  }
  let needleType = StringType | NumberType;
  const args = new Array(haystack.length);
  for (let i = 0; i < args.length; i++) {
    const arg = parse2(haystack[i], context);
    needleType &= arg.type;
    args[i] = arg;
  }
  if (isType(needleType, NoneType)) {
    throw new Error(
      `Could not find a common type for the following in operation: ` + JSON.stringify(encoded)
    );
  }
  const needle = parse2(encoded[1], context, needleType);
  return [needle, ...args];
}
function parsePaletteArgs(encoded, context) {
  const index = parse2(encoded[1], context, NumberType);
  if (index.type !== NumberType) {
    throw new Error(
      `The first argument of palette must be an number, got ${typeName(
        index.type
      )} instead`
    );
  }
  const colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error("The second argument of palette must be an array");
  }
  const parsedColors = new Array(colors.length);
  for (let i = 0; i < parsedColors.length; i++) {
    const color = parse2(colors[i], context, ColorType);
    if (!(color instanceof LiteralExpression)) {
      throw new Error(
        `The palette color at index ${i} must be a literal value`
      );
    }
    if (!overlapsType(color.type, ColorType)) {
      throw new Error(
        `The palette color at index ${i} should be of type color, got ${typeName(
          color.type
        )} instead`
      );
    }
    parsedColors[i] = color;
  }
  return [index, ...parsedColors];
}
function createParser(returnType, ...argValidators) {
  return function(encoded, context, typeHint) {
    const operator = encoded[0];
    let parsedArgs = [];
    for (let i = 0; i < argValidators.length; i++) {
      parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;
    }
    let actualType = typeof returnType === "function" ? returnType(parsedArgs) : returnType;
    if (typeHint !== void 0) {
      if (!overlapsType(actualType, typeHint)) {
        throw new Error(
          `The following expression was expected to return ${typeName(
            typeHint
          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(
            encoded
          )}`
        );
      }
      actualType &= typeHint;
    }
    if (actualType === NoneType) {
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          encoded
        )}`
      );
    }
    return new CallExpression(actualType, operator, ...parsedArgs);
  };
}
function parseCallExpression(encoded, context, typeHint) {
  const operator = encoded[0];
  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`Unknown operator: ${operator}`);
  }
  return parser(encoded, context, typeHint);
}
function computeGeometryType(geometry) {
  if (!geometry) {
    return "";
  }
  const type = geometry.getType();
  switch (type) {
    case "Point":
    case "LineString":
    case "Polygon":
      return type;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        type.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return computeGeometryType(
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry.getGeometries()[0]
      );
    default:
      return "";
  }
}
var numTypes, NoneType, BooleanType, NumberType, StringType, ColorType, NumberArrayType, SizeType, AnyType, typeNames, namedTypes, LiteralExpression, CallExpression, Ops, parsers;
var init_expression = __esm({
  "node_modules/ol/expr/expression.js"() {
    init_array();
    init_color();
    numTypes = 0;
    NoneType = 0;
    BooleanType = 1 << numTypes++;
    NumberType = 1 << numTypes++;
    StringType = 1 << numTypes++;
    ColorType = 1 << numTypes++;
    NumberArrayType = 1 << numTypes++;
    SizeType = 1 << numTypes++;
    AnyType = Math.pow(2, numTypes) - 1;
    typeNames = {
      [BooleanType]: "boolean",
      [NumberType]: "number",
      [StringType]: "string",
      [ColorType]: "color",
      [NumberArrayType]: "number[]",
      [SizeType]: "size"
    };
    namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
    LiteralExpression = class {
      /**
       * @param {number} type The value type.
       * @param {LiteralValue} value The literal value.
       */
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
    };
    CallExpression = class {
      /**
       * @param {number} type The return type.
       * @param {string} operator The operator.
       * @param {...Expression} args The arguments.
       */
      constructor(type, operator, ...args) {
        this.type = type;
        this.operator = operator;
        this.args = args;
      }
    };
    Ops = {
      Get: "get",
      Var: "var",
      Concat: "concat",
      GeometryType: "geometry-type",
      Any: "any",
      All: "all",
      Not: "!",
      Resolution: "resolution",
      Zoom: "zoom",
      Time: "time",
      Equal: "==",
      NotEqual: "!=",
      GreaterThan: ">",
      GreaterThanOrEqualTo: ">=",
      LessThan: "<",
      LessThanOrEqualTo: "<=",
      Multiply: "*",
      Divide: "/",
      Add: "+",
      Subtract: "-",
      Clamp: "clamp",
      Mod: "%",
      Pow: "^",
      Abs: "abs",
      Floor: "floor",
      Ceil: "ceil",
      Round: "round",
      Sin: "sin",
      Cos: "cos",
      Atan: "atan",
      Sqrt: "sqrt",
      Match: "match",
      Between: "between",
      Interpolate: "interpolate",
      Coalesce: "coalesce",
      Case: "case",
      In: "in",
      Number: "number",
      String: "string",
      Array: "array",
      Color: "color",
      Id: "id",
      Band: "band",
      Palette: "palette",
      ToString: "to-string"
    };
    parsers = {
      [Ops.Get]: createParser(
        ([_, typeHint]) => {
          if (typeHint !== void 0) {
            return getTypeFromHint(
              /** @type {string} */
              /** @type {LiteralExpression} */
              typeHint.value
            );
          }
          return AnyType;
        },
        withArgsCount(1, 2),
        withGetArgs
      ),
      [Ops.Var]: createParser(
        ([firstArg]) => firstArg.type,
        withArgsCount(1, 1),
        withVarArgs
      ),
      [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),
      [Ops.Concat]: createParser(
        StringType,
        withArgsCount(2, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.GeometryType]: createParser(StringType, withNoArgs, usesGeometryType),
      [Ops.Resolution]: createParser(NumberType, withNoArgs),
      [Ops.Zoom]: createParser(NumberType, withNoArgs),
      [Ops.Time]: createParser(NumberType, withNoArgs),
      [Ops.Any]: createParser(
        BooleanType,
        withArgsCount(2, Infinity),
        parseArgsOfType(BooleanType)
      ),
      [Ops.All]: createParser(
        BooleanType,
        withArgsCount(2, Infinity),
        parseArgsOfType(BooleanType)
      ),
      [Ops.Not]: createParser(
        BooleanType,
        withArgsCount(1, 1),
        parseArgsOfType(BooleanType)
      ),
      [Ops.Equal]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.NotEqual]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.GreaterThan]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.GreaterThanOrEqualTo]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.LessThan]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.LessThanOrEqualTo]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.Multiply]: createParser(
        (parsedArgs) => {
          let outputType = NumberType | ColorType;
          for (let i = 0; i < parsedArgs.length; i++) {
            outputType &= parsedArgs[i].type;
          }
          return outputType;
        },
        withArgsCount(2, Infinity),
        parseArgsOfType(NumberType | ColorType),
        narrowArgsType
      ),
      [Ops.Coalesce]: createParser(
        (parsedArgs) => {
          let type = AnyType;
          for (let i = 1; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          type &= parsedArgs[parsedArgs.length - 1].type;
          return type;
        },
        withArgsCount(2, Infinity),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.Divide]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Add]: createParser(
        NumberType,
        withArgsCount(2, Infinity),
        parseArgsOfType(NumberType)
      ),
      [Ops.Subtract]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Clamp]: createParser(
        NumberType,
        withArgsCount(3, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Mod]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Pow]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Abs]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Floor]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Ceil]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Round]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Sin]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Cos]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Atan]: createParser(
        NumberType,
        withArgsCount(1, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Sqrt]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Match]: createParser(
        (parsedArgs) => {
          let type = AnyType;
          for (let i = 2; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          type &= parsedArgs[parsedArgs.length - 1].type;
          return type;
        },
        withArgsCount(4, Infinity),
        withEvenArgs,
        parseMatchArgs
      ),
      [Ops.Between]: createParser(
        BooleanType,
        withArgsCount(3, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Interpolate]: createParser(
        (parsedArgs) => {
          let type = ColorType | NumberType;
          for (let i = 3; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          return type;
        },
        withArgsCount(6, Infinity),
        withEvenArgs,
        parseInterpolateArgs
      ),
      [Ops.Case]: createParser(
        (parsedArgs) => {
          let type = AnyType;
          for (let i = 1; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          type &= parsedArgs[parsedArgs.length - 1].type;
          return type;
        },
        withArgsCount(3, Infinity),
        withOddArgs,
        parseCaseArgs
      ),
      [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),
      [Ops.Number]: createParser(
        NumberType,
        withArgsCount(1, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.String]: createParser(
        StringType,
        withArgsCount(1, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.Array]: createParser(
        (parsedArgs) => {
          return parsedArgs.length === 2 ? NumberArrayType | SizeType : parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;
        },
        withArgsCount(1, Infinity),
        parseArgsOfType(NumberType)
      ),
      [Ops.Color]: createParser(
        ColorType,
        withArgsCount(1, 4),
        parseArgsOfType(NumberType)
      ),
      [Ops.Band]: createParser(
        NumberType,
        withArgsCount(1, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs),
      [Ops.ToString]: createParser(
        StringType,
        withArgsCount(1, 1),
        parseArgsOfType(BooleanType | NumberType | StringType | ColorType)
      )
    };
  }
});

// node_modules/ol/expr/cpu.js
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function buildExpression(encoded, type, context) {
  const expression = parse2(encoded, context);
  if (!overlapsType(type, expression.type)) {
    const expected = typeName(type);
    const actual = typeName(expression.type);
    throw new Error(
      `Expected expression to be of type ${expected}, got ${actual}`
    );
  }
  return compileExpression(expression, context);
}
function compileExpression(expression, context) {
  if (expression instanceof LiteralExpression) {
    if (expression.type === ColorType && typeof expression.value === "string") {
      const colorValue = fromString(expression.value);
      return function() {
        return colorValue;
      };
    }
    return function() {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case Ops.Number:
    case Ops.String:
    case Ops.Coalesce: {
      return compileAssertionExpression(expression, context);
    }
    case Ops.Get:
    case Ops.Var: {
      return compileAccessorExpression(expression, context);
    }
    case Ops.Id: {
      return (context2) => context2.featureId;
    }
    case Ops.GeometryType: {
      return (context2) => context2.geometryType;
    }
    case Ops.Concat: {
      const args = expression.args.map((e) => compileExpression(e, context));
      return (context2) => "".concat(...args.map((arg) => arg(context2).toString()));
    }
    case Ops.Resolution: {
      return (context2) => context2.resolution;
    }
    case Ops.Any:
    case Ops.All:
    case Ops.Between:
    case Ops.In:
    case Ops.Not: {
      return compileLogicalExpression(expression, context);
    }
    case Ops.Equal:
    case Ops.NotEqual:
    case Ops.LessThan:
    case Ops.LessThanOrEqualTo:
    case Ops.GreaterThan:
    case Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression, context);
    }
    case Ops.Multiply:
    case Ops.Divide:
    case Ops.Add:
    case Ops.Subtract:
    case Ops.Clamp:
    case Ops.Mod:
    case Ops.Pow:
    case Ops.Abs:
    case Ops.Floor:
    case Ops.Ceil:
    case Ops.Round:
    case Ops.Sin:
    case Ops.Cos:
    case Ops.Atan:
    case Ops.Sqrt: {
      return compileNumericExpression(expression, context);
    }
    case Ops.Case: {
      return compileCaseExpression(expression, context);
    }
    case Ops.Match: {
      return compileMatchExpression(expression, context);
    }
    case Ops.Interpolate: {
      return compileInterpolateExpression(expression, context);
    }
    case Ops.ToString: {
      return compileConvertExpression(expression, context);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
  }
}
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (type) {
    case Ops.Coalesce: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value !== "undefined" && value !== null) {
            return value;
          }
        }
        throw new Error("Expected one of the values to be non-null");
      };
    }
    case Ops.Number:
    case Ops.String: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}
function compileAccessorExpression(expression, context) {
  const nameExpression = (
    /** @type {LiteralExpression} */
    expression.args[0]
  );
  const name = (
    /** @type {string} */
    nameExpression.value
  );
  switch (expression.operator) {
    case Ops.Get: {
      return (context2) => context2.properties[name];
    }
    case Ops.Var: {
      return (context2) => context2.variables[name];
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0], context);
  const right = compileExpression(expression.args[1], context);
  switch (op) {
    case Ops.Equal: {
      return (context2) => left(context2) === right(context2);
    }
    case Ops.NotEqual: {
      return (context2) => left(context2) !== right(context2);
    }
    case Ops.LessThan: {
      return (context2) => left(context2) < right(context2);
    }
    case Ops.LessThanOrEqualTo: {
      return (context2) => left(context2) <= right(context2);
    }
    case Ops.GreaterThan: {
      return (context2) => left(context2) > right(context2);
    }
    case Ops.GreaterThanOrEqualTo: {
      return (context2) => left(context2) >= right(context2);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Any: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.All: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (!args[i](context2)) {
            return false;
          }
        }
        return true;
      };
    }
    case Ops.Between: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        const max = args[2](context2);
        return value >= min && value <= max;
      };
    }
    case Ops.In: {
      return (context2) => {
        const value = args[0](context2);
        for (let i = 1; i < length; ++i) {
          if (value === args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.Not: {
      return (context2) => !args[0](context2);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Multiply: {
      return (context2) => {
        let value = 1;
        for (let i = 0; i < length; ++i) {
          value *= args[i](context2);
        }
        return value;
      };
    }
    case Ops.Divide: {
      return (context2) => args[0](context2) / args[1](context2);
    }
    case Ops.Add: {
      return (context2) => {
        let value = 0;
        for (let i = 0; i < length; ++i) {
          value += args[i](context2);
        }
        return value;
      };
    }
    case Ops.Subtract: {
      return (context2) => args[0](context2) - args[1](context2);
    }
    case Ops.Clamp: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        if (value < min) {
          return min;
        }
        const max = args[2](context2);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case Ops.Mod: {
      return (context2) => args[0](context2) % args[1](context2);
    }
    case Ops.Pow: {
      return (context2) => Math.pow(args[0](context2), args[1](context2));
    }
    case Ops.Abs: {
      return (context2) => Math.abs(args[0](context2));
    }
    case Ops.Floor: {
      return (context2) => Math.floor(args[0](context2));
    }
    case Ops.Ceil: {
      return (context2) => Math.ceil(args[0](context2));
    }
    case Ops.Round: {
      return (context2) => Math.round(args[0](context2));
    }
    case Ops.Sin: {
      return (context2) => Math.sin(args[0](context2));
    }
    case Ops.Cos: {
      return (context2) => Math.cos(args[0](context2));
    }
    case Ops.Atan: {
      if (length === 2) {
        return (context2) => Math.atan2(args[0](context2), args[1](context2));
      }
      return (context2) => Math.atan(args[0](context2));
    }
    case Ops.Sqrt: {
      return (context2) => Math.sqrt(args[0](context2));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}
function compileCaseExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    for (let i = 0; i < length - 1; i += 2) {
      const condition = args[i](context2);
      if (condition) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const value = args[0](context2);
    for (let i = 1; i < length; i += 2) {
      if (value === args[i](context2)) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileInterpolateExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const base = args[0](context2);
    const value = args[1](context2);
    let previousInput;
    let previousOutput;
    for (let i = 2; i < length; i += 2) {
      const input = args[i](context2);
      let output = args[i + 1](context2);
      const isColor = Array.isArray(output);
      if (isColor) {
        output = withAlpha(output);
      }
      if (input >= value) {
        if (i === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(
            base,
            value,
            previousInput,
            previousOutput,
            input,
            output
          );
        }
        return interpolateNumber(
          base,
          value,
          previousInput,
          previousOutput,
          input,
          output
        );
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}
function compileConvertExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.ToString: {
      return (context2) => {
        const value = args[0](context2);
        if (expression.args[0].type === ColorType) {
          return toString2(value);
        }
        return value.toString();
      };
    }
    default: {
      throw new Error(`Unsupported convert operator ${op}`);
    }
  }
}
function interpolateNumber(base, value, input1, output1, input2, output2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  const along = value - input1;
  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  const lcha1 = rgbaToLcha(rgba1);
  const lcha2 = rgbaToLcha(rgba2);
  let deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }
  const lcha = [
    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
  ];
  return normalize(lchaToRgba(lcha));
}
var init_cpu = __esm({
  "node_modules/ol/expr/cpu.js"() {
    init_expression();
    init_color();
  }
});

// node_modules/ol/render/canvas/style.js
function always(context) {
  return true;
}
function rulesToStyleFunction(rules) {
  const parsingContext = newParsingContext();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = newEvaluationContext();
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    if (parsingContext.geometryType) {
      evaluationContext.geometryType = computeGeometryType(
        feature.getGeometry()
      );
    }
    return evaluator(evaluationContext);
  };
}
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = newParsingContext();
  const length = flatStyles.length;
  const evaluators = new Array(length);
  for (let i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  const evaluationContext = newEvaluationContext();
  const styles = new Array(length);
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    let nonNullCount = 0;
    for (let i = 0; i < length; ++i) {
      const style = evaluators[i](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}
function buildRuleSet(rules, context) {
  const length = rules.length;
  const compiledRules = new Array(length);
  for (let i = 0; i < length; ++i) {
    const rule = rules[i];
    const filter = "filter" in rule ? buildExpression(rule.filter, BooleanType, context) : always;
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }
    compiledRules[i] = { filter, styles };
  }
  return function(context2) {
    const styles = [];
    let someMatched = false;
    for (let i = 0; i < length; ++i) {
      const filterEvaluator = compiledRules[i].filter;
      if (!filterEvaluator(context2)) {
        continue;
      }
      if (rules[i].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i].styles) {
        const style = styleEvaluator(context2);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }
    return styles;
  };
}
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, "", context);
  const evaluateStroke = buildStroke(flatStyle, "", context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(flatStyle)
    );
  }
  const style = new Style_default();
  return function(context2) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context2);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context2);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text = evaluateText(context2);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      const image = evaluateImage(context2);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context2));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}
function buildFill(flatStyle, prefix, context) {
  let evaluateColor;
  if (prefix + "fill-pattern-src" in flatStyle) {
    evaluateColor = patternEvaluator(flatStyle, prefix + "fill-", context);
  } else {
    evaluateColor = colorLikeEvaluator(
      flatStyle,
      prefix + "fill-color",
      context
    );
  }
  if (!evaluateColor) {
    return null;
  }
  const fill = new Fill_default();
  return function(context2) {
    const color = evaluateColor(context2);
    if (color === "none") {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + "stroke-width",
    context
  );
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "stroke-color",
    context
  );
  if (!evaluateWidth && !evaluateColor) {
    return null;
  }
  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-cap",
    context
  );
  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-join",
    context
  );
  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + "stroke-line-dash",
    context
  );
  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + "stroke-line-dash-offset",
    context
  );
  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + "stroke-miter-limit",
    context
  );
  const stroke = new Stroke_default();
  return function(context2) {
    if (evaluateColor) {
      const color = evaluateColor(context2);
      if (color === "none") {
        return null;
      }
      stroke.setColor(color);
    }
    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context2));
    }
    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context2);
      if (lineCap !== "butt" && lineCap !== "round" && lineCap !== "square") {
        throw new Error("Expected butt, round, or square line cap");
      }
      stroke.setLineCap(lineCap);
    }
    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context2);
      if (lineJoin !== "bevel" && lineJoin !== "round" && lineJoin !== "miter") {
        throw new Error("Expected bevel, round, or miter line join");
      }
      stroke.setLineJoin(lineJoin);
    }
    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context2));
    }
    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context2));
    }
    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context2));
    }
    return stroke;
  };
}
function buildText(flatStyle, context) {
  const prefix = "text-";
  const evaluateValue = stringEvaluator(flatStyle, prefix + "value", context);
  if (!evaluateValue) {
    return null;
  }
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateFont = stringEvaluator(flatStyle, prefix + "font", context);
  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + "max-angle",
    context
  );
  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + "offset-x",
    context
  );
  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + "offset-y",
    context
  );
  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + "overflow",
    context
  );
  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + "placement",
    context
  );
  const evaluateRepeat = numberEvaluator(flatStyle, prefix + "repeat", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateAlign = stringEvaluator(flatStyle, prefix + "align", context);
  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + "justify",
    context
  );
  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + "baseline",
    context
  );
  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + "padding",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const text = new Text_default({ declutterMode });
  return function(context2) {
    text.setText(evaluateValue(context2));
    if (evaluateFill) {
      text.setFill(evaluateFill(context2));
    }
    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context2));
    }
    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context2));
    }
    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context2));
    }
    if (evaluateFont) {
      text.setFont(evaluateFont(context2));
    }
    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context2));
    }
    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context2));
    }
    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context2));
    }
    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context2));
    }
    if (evaluatePlacement) {
      const placement = evaluatePlacement(context2);
      if (placement !== "point" && placement !== "line") {
        throw new Error("Expected point or line for text-placement");
      }
      text.setPlacement(placement);
    }
    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context2));
    }
    if (evaluateScale) {
      text.setScale(evaluateScale(context2));
    }
    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context2));
    }
    if (evaluateAlign) {
      const textAlign = evaluateAlign(context2);
      if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right" && textAlign !== "end" && textAlign !== "start") {
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      }
      text.setTextAlign(textAlign);
    }
    if (evaluateJustify) {
      const justify = evaluateJustify(context2);
      if (justify !== "left" && justify !== "right" && justify !== "center") {
        throw new Error("Expected left, right, or center for text-justify");
      }
      text.setJustify(justify);
    }
    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context2);
      if (textBaseline !== "bottom" && textBaseline !== "top" && textBaseline !== "middle" && textBaseline !== "alphabetic" && textBaseline !== "hanging") {
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      }
      text.setTextBaseline(textBaseline);
    }
    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context2));
    }
    return text;
  };
}
function buildImage(flatStyle, context) {
  if ("icon-src" in flatStyle) {
    return buildIcon(flatStyle, context);
  }
  if ("shape-points" in flatStyle) {
    return buildShape(flatStyle, context);
  }
  if ("circle-radius" in flatStyle) {
    return buildCircle(flatStyle, context);
  }
  return null;
}
function buildIcon(flatStyle, context) {
  const prefix = "icon-";
  const srcName = prefix + "src";
  const src = requireString(flatStyle[srcName], srcName);
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + "anchor",
    context
  );
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + "opacity",
    context
  );
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + "anchor-origin");
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-x-units"
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-y-units"
  );
  const color = optionalColorLike(flatStyle, prefix + "color");
  const crossOrigin = optionalString(flatStyle, prefix + "cross-origin");
  const offset2 = optionalNumberArray(flatStyle, prefix + "offset");
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + "offset-origin");
  const width = optionalNumber(flatStyle, prefix + "width");
  const height = optionalNumber(flatStyle, prefix + "height");
  const size = optionalSize(flatStyle, prefix + "size");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const icon = new Icon_default({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset: offset2,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode
  });
  return function(context2) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context2));
    }
    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      icon.setScale(evaluateScale(context2));
    }
    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context2));
    }
    return icon;
  };
}
function buildShape(flatStyle, context) {
  const prefix = "shape-";
  const pointsName = prefix + "points";
  const radiusName = prefix + "radius";
  const points = requireNumber(flatStyle[pointsName], pointsName);
  const radius = requireNumber(flatStyle[radiusName], radiusName);
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const radius2 = optionalNumber(flatStyle, prefix + "radius2");
  const angle = optionalNumber(flatStyle, prefix + "angle");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const shape = new RegularShape_default({
    points,
    radius,
    radius2,
    angle,
    declutterMode
  });
  return function(context2) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context2));
    }
    return shape;
  };
}
function buildCircle(flatStyle, context) {
  const prefix = "circle-";
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + "radius", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const circle = new Circle_default({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode
  });
  return function(context2) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context2));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context2));
    }
    return circle;
  };
}
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return void 0;
  }
  const evaluator = buildExpression(flatStyle[name], NumberType, context);
  return function(context2) {
    return requireNumber(evaluator(context2), name);
  };
}
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], StringType, context);
  return function(context2) {
    return requireString(evaluator(context2), name);
  };
}
function patternEvaluator(flatStyle, prefix, context) {
  const srcEvaluator = stringEvaluator(
    flatStyle,
    prefix + "pattern-src",
    context
  );
  const offsetEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-offset",
    context
  );
  const patternSizeEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-size",
    context
  );
  const colorEvaluator = colorLikeEvaluator(
    flatStyle,
    prefix + "color",
    context
  );
  return function(context2) {
    return {
      src: srcEvaluator(context2),
      offset: offsetEvaluator && offsetEvaluator(context2),
      size: patternSizeEvaluator && patternSizeEvaluator(context2),
      color: colorEvaluator && colorEvaluator(context2)
    };
  };
}
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], BooleanType, context);
  return function(context2) {
    const value = evaluator(context2);
    if (typeof value !== "boolean") {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    ColorType | StringType,
    context
  );
  return function(context2) {
    return requireColorLike(evaluator(context2), name);
  };
}
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireNumberArray(evaluator(context2), name);
  };
}
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    const array = requireNumberArray(evaluator(context2), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}
function sizeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireSize(evaluator(context2), name);
  };
}
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    NumberArrayType | NumberType,
    context
  );
  return function(context2) {
    return requireSizeLike(evaluator(context2), name);
  };
}
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === void 0) {
    return void 0;
  }
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded === "number") {
    return toSize(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (encoded.length !== 2 || typeof encoded[0] !== "number" || typeof encoded[1] !== "number") {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "bottom-left" && encoded !== "bottom-right" && encoded !== "top-left" && encoded !== "top-right") {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
    );
  }
  return encoded;
}
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "pixels" && encoded !== "fraction") {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireNumberArray(encoded, property);
}
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== "declutter" && encoded !== "obstacle" && encoded !== "none") {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireColorLike(encoded, property);
}
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    if (typeof value[i] !== "number") {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}
function requireString(value, property) {
  if (typeof value !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}
function requireNumber(value, property) {
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function requireColorLike(value, property) {
  if (typeof value === "string") {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}
function requireSize(value, property) {
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}
function requireSizeLike(value, property) {
  if (typeof value === "number") {
    return value;
  }
  return requireSize(value, property);
}
var init_style = __esm({
  "node_modules/ol/render/canvas/style.js"() {
    init_Circle();
    init_Fill();
    init_Icon();
    init_RegularShape();
    init_Stroke();
    init_Style();
    init_Text();
    init_expression();
    init_cpu();
    init_obj();
    init_size();
  }
});

// node_modules/ol/layer/BaseVector.js
function toStyleLike(style) {
  if (style === void 0) {
    return createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === "function") {
    return style;
  }
  if (style instanceof Style_default) {
    return style;
  }
  if (!Array.isArray(style)) {
    return flatStylesToStyleFunction([style]);
  }
  if (style.length === 0) {
    return [];
  }
  const length = style.length;
  const first = style[0];
  if (first instanceof Style_default) {
    const styles = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!(candidate instanceof Style_default)) {
        throw new Error("Expected a list of style instances");
      }
      styles[i] = candidate;
    }
    return styles;
  }
  if ("style" in first) {
    const rules = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!("style" in candidate)) {
        throw new Error("Expected a list of rules with a style property");
      }
      rules[i] = candidate;
    }
    return rulesToStyleFunction(rules);
  }
  const flatStyles = (
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    style
  );
  return flatStylesToStyleFunction(flatStyles);
}
var Property2, BaseVectorLayer, BaseVector_default;
var init_BaseVector = __esm({
  "node_modules/ol/layer/BaseVector.js"() {
    init_Layer();
    init_rbush();
    init_Style();
    init_style();
    Property2 = {
      RENDER_ORDER: "renderOrder"
    };
    BaseVectorLayer = class extends Layer_default {
      /**
       * @param {Options<VectorSourceType>} [options] Options.
       */
      constructor(options) {
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        super(baseOptions);
        this.declutter_ = options.declutter ? String(options.declutter) : void 0;
        this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.setStyle(options.style);
        this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
        this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
      }
      /**
       * @return {string} Declutter group.
       */
      getDeclutter() {
        return this.declutter_;
      }
      /**
       * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
       * that resolves with an array of features. The array will either contain the topmost feature
       * when a hit was detected, or it will be empty.
       *
       * The hit detection algorithm used for this method is optimized for performance, but is less
       * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
       * Text is not considered, and icons are only represented by their bounding box instead of the exact
       * image.
       *
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
       * @api
       */
      getFeatures(pixel) {
        return super.getFeatures(pixel);
      }
      /**
       * @return {number|undefined} Render buffer.
       */
      getRenderBuffer() {
        return this.renderBuffer_;
      }
      /**
       * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
       *     order.
       */
      getRenderOrder() {
        return (
          /** @type {import("../render.js").OrderFunction|null|undefined} */
          this.get(Property2.RENDER_ORDER)
        );
      }
      /**
       * Get the style for features.  This returns whatever was passed to the `style`
       * option at construction or to the `setStyle` method.
       * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the style function.
       * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     animating.
       */
      getUpdateWhileAnimating() {
        return this.updateWhileAnimating_;
      }
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     interacting.
       */
      getUpdateWhileInteracting() {
        return this.updateWhileInteracting_;
      }
      /**
       * Render declutter items for this layer
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {import("../layer/Layer.js").State} layerState Layer state.
       */
      renderDeclutter(frameState, layerState) {
        const declutterGroup = this.getDeclutter();
        if (declutterGroup in frameState.declutter === false) {
          frameState.declutter[declutterGroup] = new RBush(9);
        }
        this.getRenderer().renderDeclutter(frameState, layerState);
      }
      /**
       * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
       *     Render order.
       */
      setRenderOrder(renderOrder) {
        this.set(Property2.RENDER_ORDER, renderOrder);
      }
      /**
       * Set the style for features.  This can be a single style object, an array
       * of styles, or a function that takes a feature and resolution and returns
       * an array of styles. If set to `null`, the layer has no style (a `null` style),
       * so only features that have their own styles will be rendered in the layer. Call
       * `setStyle()` without arguments to reset to the default style. See
       * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
       *
       * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
       * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
       * ```js
       * vectorLayer.setStyle({
       *   "fill-color": "yellow",
       *   "stroke-color": "black",
       *   "stroke-width": 4
       * })
       * ```
       *
       * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
       * @api
       */
      setStyle(style) {
        this.style_ = style === void 0 ? createDefaultStyle : style;
        const styleLike = toStyleLike(style);
        this.styleFunction_ = style === null ? void 0 : toFunction(styleLike);
        this.changed();
      }
    };
    BaseVector_default = BaseVectorLayer;
  }
});

// node_modules/ol/render/Event.js
var RenderEvent, Event_default2;
var init_Event2 = __esm({
  "node_modules/ol/render/Event.js"() {
    init_Event();
    RenderEvent = class extends Event_default {
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../Map.js").FrameState} [frameState] Frame state.
       * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
       */
      constructor(type, inversePixelTransform, frameState, context) {
        super(type);
        this.inversePixelTransform = inversePixelTransform;
        this.frameState = frameState;
        this.context = context;
      }
    };
    Event_default2 = RenderEvent;
  }
});

// node_modules/ol/MapEventType.js
var MapEventType_default;
var init_MapEventType = __esm({
  "node_modules/ol/MapEventType.js"() {
    MapEventType_default = {
      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: "movestart",
      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: "moveend",
      /**
       * Triggered when loading of additional map data (tiles, images, features) starts.
       * @event module:ol/MapEvent~MapEvent#loadstart
       * @api
       */
      LOADSTART: "loadstart",
      /**
       * Triggered when loading of additional map data has completed.
       * @event module:ol/MapEvent~MapEvent#loadend
       * @api
       */
      LOADEND: "loadend"
    };
  }
});

// node_modules/ol/control/Control.js
var Control_exports = {};
__export(Control_exports, {
  default: () => Control_default
});
var Control, Control_default;
var init_Control = __esm({
  "node_modules/ol/control/Control.js"() {
    init_Object();
    init_MapEventType();
    init_functions();
    init_events();
    init_dom();
    Control = class extends Object_default {
      /**
       * @param {Options} options Control options.
       */
      constructor(options) {
        super();
        const element = options.element;
        if (element && !options.target && !element.style.pointerEvents) {
          element.style.pointerEvents = "auto";
        }
        this.element = element ? element : null;
        this.target_ = null;
        this.map_ = null;
        this.listenerKeys = [];
        if (options.render) {
          this.render = options.render;
        }
        if (options.target) {
          this.setTarget(options.target);
        }
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        removeNode(this.element);
        super.disposeInternal();
      }
      /**
       * Get the map associated with this control.
       * @return {import("../Map.js").default|null} Map.
       * @api
       */
      getMap() {
        return this.map_;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Pass `null` to just remove the control from the current map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.map_) {
          removeNode(this.element);
        }
        for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
          unlistenByKey(this.listenerKeys[i]);
        }
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (map) {
          const target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
          target.appendChild(this.element);
          if (this.render !== VOID) {
            this.listenerKeys.push(
              listen(map, MapEventType_default.POSTRENDER, this.render, this)
            );
          }
          map.render();
        }
      }
      /**
       * Renders the control.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @api
       */
      render(mapEvent) {
      }
      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */
      setTarget(target) {
        this.target_ = typeof target === "string" ? document.getElementById(target) : target;
      }
    };
    Control_default = Control;
  }
});

// node_modules/ol/source/Source.js
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  return function(frameState) {
    return [attributionLike];
  };
}
var Source, Source_default;
var init_Source = __esm({
  "node_modules/ol/source/Source.js"() {
    init_Object();
    init_proj();
    Source = class extends Object_default {
      /**
       * @param {Options} options Source options.
       */
      constructor(options) {
        super();
        this.projection = get3(options.projection);
        this.attributions_ = adaptAttributions(options.attributions);
        this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
        this.loading = false;
        this.state_ = options.state !== void 0 ? options.state : "ready";
        this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
        this.interpolate_ = !!options.interpolate;
        this.viewResolver = null;
        this.viewRejector = null;
        const self2 = this;
        this.viewPromise_ = new Promise(function(resolve, reject) {
          self2.viewResolver = resolve;
          self2.viewRejector = reject;
        });
      }
      /**
       * Get the attribution function for the source.
       * @return {?Attribution} Attribution function.
       * @api
       */
      getAttributions() {
        return this.attributions_;
      }
      /**
       * @return {boolean} Attributions are collapsible.
       * @api
       */
      getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
      }
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default|null} Projection.
       * @api
       */
      getProjection() {
        return this.projection;
      }
      /**
       * @param {import("../proj/Projection").default} [projection] Projection.
       * @return {Array<number>|null} Resolutions.
       */
      getResolutions(projection) {
        return null;
      }
      /**
       * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
       */
      getView() {
        return this.viewPromise_;
      }
      /**
       * Get the state of the source, see {@link import("./Source.js").State} for possible states.
       * @return {import("./Source.js").State} State.
       * @api
       */
      getState() {
        return this.state_;
      }
      /**
       * @return {boolean|undefined} Wrap X.
       */
      getWrapX() {
        return this.wrapX_;
      }
      /**
       * @return {boolean} Use linear interpolation when resampling.
       */
      getInterpolate() {
        return this.interpolate_;
      }
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */
      refresh() {
        this.changed();
      }
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */
      setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
      }
      /**
       * Set the state of the source.
       * @param {import("./Source.js").State} state State.
       */
      setState(state) {
        this.state_ = state;
        this.changed();
      }
    };
    Source_default = Source;
  }
});

// node_modules/ol/renderer/Layer.js
var LayerRenderer, Layer_default2;
var init_Layer2 = __esm({
  "node_modules/ol/renderer/Layer.js"() {
    init_EventType();
    init_ImageState();
    init_Observable();
    init_util();
    LayerRenderer = class extends Observable_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super();
        this.ready = true;
        this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        this.layer_ = layer;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        return abstract();
      }
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        return null;
      }
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        return abstract();
      }
      /**
       * Render the layer.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement|null} The rendered element.
       */
      renderFrame(frameState, target) {
        return abstract();
      }
      /**
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */
      loadedTileCallback(tiles, zoom, tile2) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }
        tiles[zoom][tile2.tileCoord.toString()] = tile2;
        return void 0;
      }
      /**
       * Create a function that adds loaded tiles to the tile lookup.
       * @param {import("../source/Tile.js").default} source Tile source.
       * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
       *     called with a zoom level and a tile range to add loaded tiles to the lookup.
       * @protected
       */
      createLoadedTileFinder(source, projection, tiles) {
        return (
          /**
           * @param {number} zoom Zoom level.
           * @param {import("../TileRange.js").default} tileRange Tile range.
           * @return {boolean} The tile range is fully loaded.
           */
          (zoom, tileRange) => {
            const callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
          }
        );
      }
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return void 0;
      }
      /**
       * @return {LayerType} Layer.
       */
      getLayer() {
        return this.layer_;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      handleFontsChanged() {
      }
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      handleImageChange_(event) {
        const image = (
          /** @type {import("../Image.js").default} */
          event.target
        );
        if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
          this.renderIfReadyAndVisible();
        }
      }
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../Image.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      loadImage(image) {
        let imageState = image.getState();
        if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
          image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
        }
        if (imageState == ImageState_default.IDLE) {
          image.load();
          imageState = image.getState();
        }
        return imageState == ImageState_default.LOADED;
      }
      /**
       * @protected
       */
      renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
          layer.changed();
        }
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */
      renderDeferred(frameState) {
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
      }
    };
    Layer_default2 = LayerRenderer;
  }
});

// node_modules/ol/render/canvas/ZIndexContext.js
var ZIndexContext, ZIndexContext_default;
var init_ZIndexContext = __esm({
  "node_modules/ol/render/canvas/ZIndexContext.js"() {
    init_dom();
    ZIndexContext = class {
      constructor() {
        /**
         * @private
         * @param {...*} args Args.
         * @return {ZIndexContext} This.
         */
        __publicField(this, "pushMethodArgs_", (...args) => {
          this.instructions_[this.zIndex + this.offset_].push(args);
          return this;
        });
        this.instructions_ = [];
        this.zIndex = 0;
        this.offset_ = 0;
        this.context_ = /** @type {ZIndexContextProxy} */
        new Proxy(getSharedCanvasContext2D(), {
          get: (target, property) => {
            if (typeof /** @type {*} */
            getSharedCanvasContext2D()[property] !== "function") {
              return void 0;
            }
            if (!this.instructions_[this.zIndex + this.offset_]) {
              this.instructions_[this.zIndex + this.offset_] = [];
            }
            this.instructions_[this.zIndex + this.offset_].push(property);
            return this.pushMethodArgs_;
          },
          set: (target, property, value) => {
            if (!this.instructions_[this.zIndex + this.offset_]) {
              this.instructions_[this.zIndex + this.offset_] = [];
            }
            this.instructions_[this.zIndex + this.offset_].push(property, value);
            return true;
          }
        });
      }
      /**
       * Push a function that renders to the context directly.
       * @param {function(CanvasRenderingContext2D): void} render Function.
       */
      pushFunction(render2) {
        this.instructions_[this.zIndex + this.offset_].push(render2);
      }
      /**
       * Get a proxy for CanvasRenderingContext2D which does not support getting state
       * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
       * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
       * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
       * @return {ZIndexContextProxy} Context.
       */
      getContext() {
        return this.context_;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       */
      draw(context) {
        this.instructions_.forEach((instructionsAtIndex) => {
          for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {
            const property = instructionsAtIndex[i];
            if (typeof property === "function") {
              property(context);
              continue;
            }
            const instructionAtIndex = instructionsAtIndex[++i];
            if (typeof /** @type {*} */
            context[property] === "function") {
              context[property](...instructionAtIndex);
            } else {
              if (typeof instructionAtIndex === "function") {
                context[property] = instructionAtIndex(context);
                continue;
              }
              context[property] = instructionAtIndex;
            }
          }
        });
      }
      clear() {
        this.instructions_.length = 0;
        this.zIndex = 0;
        this.offset_ = 0;
      }
      /**
       * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
       * avoid conflicting context.clip() or context.save()/restore() calls.
       */
      offset() {
        this.offset_ = this.instructions_.length;
        this.zIndex = 0;
      }
    };
    ZIndexContext_default = ZIndexContext;
  }
});

// node_modules/ol/renderer/canvas/Layer.js
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var canvasPool2, pixelContext, CanvasLayerRenderer, Layer_default3;
var init_Layer3 = __esm({
  "node_modules/ol/renderer/canvas/Layer.js"() {
    init_Layer2();
    init_Event2();
    init_EventType2();
    init_ZIndexContext();
    init_transform();
    init_color();
    init_dom();
    init_array();
    init_extent();
    canvasPool2 = [];
    pixelContext = null;
    CanvasLayerRenderer = class extends Layer_default2 {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super(layer);
        this.container = null;
        this.renderedResolution;
        this.tempTransform = create();
        this.pixelTransform = create();
        this.inversePixelTransform = create();
        this.context = null;
        this.deferredContext_ = null;
        this.containerReused = false;
        this.pixelContext_ = null;
        this.frameState = null;
      }
      /**
       * @param {import('../../DataTile.js').ImageLike} image Image.
       * @param {number} col The column index.
       * @param {number} row The row index.
       * @return {Uint8ClampedArray|null} The image data.
       */
      getImageData(image, col, row) {
        if (!pixelContext) {
          createPixelContext();
        }
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
          pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
          data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
          pixelContext = null;
          return null;
        }
        return data;
      }
      /**
       * @param {import('../../Map.js').FrameState} frameState Frame state.
       * @return {string} Background color.
       */
      getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === "function") {
          background = background(frameState.viewState.resolution);
        }
        return background || void 0;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {string} [backgroundColor] Background color.
       */
      useContainer(target, transform2, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(
          asArray(target.style.backgroundColor),
          asArray(backgroundColor)
        ))) {
          const canvas = target.firstElementChild;
          if (canvas instanceof HTMLCanvasElement) {
            context = canvas.getContext("2d");
          }
        }
        if (context && context.canvas.style.transform === transform2) {
          this.container = target;
          this.context = context;
          this.containerReused = true;
        } else if (this.containerReused) {
          this.container = null;
          this.context = null;
          this.containerReused = false;
        } else if (this.container) {
          this.container.style.backgroundColor = null;
        }
        if (!this.container) {
          container = document.createElement("div");
          container.className = layerClassName;
          let style = container.style;
          style.position = "absolute";
          style.width = "100%";
          style.height = "100%";
          context = createCanvasContext2D();
          const canvas = context.canvas;
          container.appendChild(canvas);
          style = canvas.style;
          style.position = "absolute";
          style.left = "0";
          style.transformOrigin = "top left";
          this.container = container;
          this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
          this.container.style.backgroundColor = backgroundColor;
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      clipUnrotated(context, frameState, extent) {
        const topLeft = getTopLeft(extent);
        const topRight = getTopRight(extent);
        const bottomRight = getBottomRight(extent);
        const bottomLeft = getBottomLeft(extent);
        apply(frameState.coordinateToPixelTransform, topLeft);
        apply(frameState.coordinateToPixelTransform, topRight);
        apply(frameState.coordinateToPixelTransform, bottomRight);
        apply(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        apply(inverted, topLeft);
        apply(inverted, topRight);
        apply(inverted, bottomRight);
        apply(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @protected
       */
      prepareContainer(frameState, target) {
        const extent = frameState.extent;
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const pixelRatio = frameState.pixelRatio;
        const width = Math.round(getWidth(extent) / resolution * pixelRatio);
        const height = Math.round(getHeight(extent) / resolution * pixelRatio);
        compose(
          this.pixelTransform,
          frameState.size[0] / 2,
          frameState.size[1] / 2,
          1 / pixelRatio,
          1 / pixelRatio,
          rotation,
          -width / 2,
          -height / 2
        );
        makeInverse(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = toString(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        if (!this.containerReused) {
          const canvas = this.context.canvas;
          if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
          } else {
            this.context.clearRect(0, 0, width, height);
          }
          if (canvasTransform !== canvas.style.transform) {
            canvas.style.transform = canvasTransform;
          }
        }
      }
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @private
       */
      dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
          const event = new Event_default2(
            type,
            this.inversePixelTransform,
            frameState,
            context
          );
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      preRender(context, frameState) {
        this.frameState = frameState;
        if (frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      postRender(context, frameState) {
        if (frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeferredInternal(frameState) {
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
       */
      getRenderContext(frameState) {
        if (frameState.declutter && !this.deferredContext_) {
          this.deferredContext_ = new ZIndexContext_default();
        }
        return frameState.declutter ? this.deferredContext_.getContext() : this.context;
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @override
       */
      renderDeferred(frameState) {
        if (!frameState.declutter) {
          return;
        }
        this.dispatchRenderEvent_(
          EventType_default2.PRERENDER,
          this.context,
          frameState
        );
        if (frameState.declutter && this.deferredContext_) {
          this.deferredContext_.draw(this.context);
          this.deferredContext_.clear();
        }
        this.renderDeferredInternal(frameState);
        this.dispatchRenderEvent_(
          EventType_default2.POSTRENDER,
          this.context,
          frameState
        );
      }
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return compose(
          this.tempTransform,
          dx1,
          dy1,
          sx,
          sy,
          -rotation,
          dx2,
          dy2
        );
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
      }
    };
    Layer_default3 = CanvasLayerRenderer;
  }
});

// node_modules/ol/Feature.js
var Feature_exports = {};
__export(Feature_exports, {
  createStyleFunction: () => createStyleFunction,
  default: () => Feature_default
});
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(
      typeof /** @type {?} */
      obj.getZIndex === "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    );
    const style = (
      /** @type {import("./style/Style.js").default} */
      obj
    );
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature, Feature_default;
var init_Feature = __esm({
  "node_modules/ol/Feature.js"() {
    init_Object();
    init_EventType();
    init_asserts();
    init_events();
    Feature = class _Feature extends Object_default {
      /**
       * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      constructor(geometryOrProperties) {
        super();
        this.on;
        this.once;
        this.un;
        this.id_ = void 0;
        this.geometryName_ = "geometry";
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
          if (typeof /** @type {?} */
          geometryOrProperties.getSimplifiedGeometry === "function") {
            const geometry = (
              /** @type {Geometry} */
              geometryOrProperties
            );
            this.setGeometry(geometry);
          } else {
            const properties = geometryOrProperties;
            this.setProperties(properties);
          }
        }
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature<Geometry>} The clone.
       * @api
       */
      clone() {
        const clone2 = (
          /** @type {Feature<Geometry>} */
          new _Feature(this.hasProperties() ? this.getProperties() : null)
        );
        clone2.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) {
          clone2.setGeometry(
            /** @type {Geometry} */
            geometry.clone()
          );
        }
        const style = this.getStyle();
        if (style) {
          clone2.setStyle(style);
        }
        return clone2;
      }
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      getGeometry() {
        return (
          /** @type {Geometry|undefined} */
          this.get(this.geometryName_)
        );
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      getGeometryName() {
        return this.geometryName_;
      }
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @private
       */
      handleGeometryChange_() {
        this.changed();
      }
      /**
       * @private
       */
      handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
          unlistenByKey(this.geometryChangeKey_);
          this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) {
          this.geometryChangeKey_ = listen(
            geometry,
            EventType_default.CHANGE,
            this.handleGeometryChange_,
            this
          );
        }
        this.changed();
      }
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
      }
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
        this.changed();
      }
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setId(id) {
        this.id_ = id;
        this.changed();
      }
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
      }
    };
    Feature_default = Feature;
  }
});

// node_modules/ol/geom/flat/interpolate.js
function interpolatePoint(flatCoordinates, offset2, end, stride, fraction, dest, dimension) {
  let o, t;
  const n = (end - offset2) / stride;
  if (n === 1) {
    o = offset2;
  } else if (n === 2) {
    o = offset2;
    t = fraction;
  } else if (n !== 0) {
    let x1 = flatCoordinates[offset2];
    let y1 = flatCoordinates[offset2 + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i = offset2 + stride; i < end; i += stride) {
      const x2 = flatCoordinates[i];
      const y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index = binarySearch(cumulativeLengths, target);
    if (index < 0) {
      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset2 + (-index - 2) * stride;
    } else {
      o = offset2 + index * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i = 0; i < dimension; ++i) {
    dest[i] = o === void 0 ? NaN : t === void 0 ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }
  return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m, extrapolate) {
  if (end == offset2) {
    return null;
  }
  let coordinate;
  if (m < flatCoordinates[offset2 + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset2, offset2 + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (m == flatCoordinates[offset2 + stride - 1]) {
    return flatCoordinates.slice(offset2, offset2 + stride);
  }
  let lo = offset2 / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (let i = 0; i < stride - 1; ++i) {
    coordinate.push(
      lerp(
        flatCoordinates[(lo - 1) * stride + i],
        flatCoordinates[lo * stride + i],
        t
      )
    );
  }
  coordinate.push(m);
  return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset2, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates,
      offset2,
      ends[ends.length - 1],
      stride,
      m,
      extrapolate
    );
  }
  let coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    if (offset2 == end) {
      continue;
    }
    if (m < flatCoordinates[offset2 + stride - 1]) {
      return null;
    }
    if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset2,
        end,
        stride,
        m,
        false
      );
    }
    offset2 = end;
  }
  return null;
}
var init_interpolate = __esm({
  "node_modules/ol/geom/flat/interpolate.js"() {
    init_array();
    init_math();
  }
});

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset2, end, stride) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  let length = 0;
  for (let i = offset2 + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}
function linearRingLength(flatCoordinates, offset2, end, stride) {
  let perimeter = lineStringLength(flatCoordinates, offset2, end, stride);
  const dx = flatCoordinates[end - stride] - flatCoordinates[offset2];
  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset2 + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}
var init_length = __esm({
  "node_modules/ol/geom/flat/length.js"() {
  }
});

// node_modules/ol/geom/LineString.js
var LineString, LineString_default;
var init_LineString = __esm({
  "node_modules/ol/geom/LineString.js"() {
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_simplify();
    init_array();
    init_segments();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    init_length();
    LineString = class _LineString extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.flatMidpoint_ = null;
        this.flatMidpointRevision_ = -1;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @api
       */
      appendCoordinate(coordinate) {
        extend(this.flatCoordinates, coordinate);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       */
      clone() {
        const lineString = new _LineString(
          this.flatCoordinates.slice(),
          this.layout
        );
        lineString.applyProperties(this);
        return lineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          false,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      forEachSegment(callback) {
        return forEach(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          callback
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m, extrapolate) {
        if (this.layout != "XYM" && this.layout != "XYZM") {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        return lineStringCoordinateAtM(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          m,
          extrapolate
        );
      }
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */
      getCoordinateAt(fraction, dest) {
        return interpolatePoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          fraction,
          dest,
          this.stride
        );
      }
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      getLength() {
        return lineStringLength(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
          this.flatMidpoint_ = this.getCoordinateAt(
            0.5,
            this.flatMidpoint_ ?? void 0
          );
          this.flatMidpointRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatMidpoint_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LineString(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "LineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLineString(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LineString_default = LineString;
  }
});

// node_modules/ol/render/canvas/Instruction.js
var Instruction, fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction, Instruction_default;
var init_Instruction = __esm({
  "node_modules/ol/render/canvas/Instruction.js"() {
    Instruction = {
      BEGIN_GEOMETRY: 0,
      BEGIN_PATH: 1,
      CIRCLE: 2,
      CLOSE_PATH: 3,
      CUSTOM: 4,
      DRAW_CHARS: 5,
      DRAW_IMAGE: 6,
      END_GEOMETRY: 7,
      FILL: 8,
      MOVE_TO_LINE_TO: 9,
      SET_FILL_STYLE: 10,
      SET_STROKE_STYLE: 11,
      STROKE: 12
    };
    fillInstruction = [Instruction.FILL];
    strokeInstruction = [Instruction.STROKE];
    beginPathInstruction = [Instruction.BEGIN_PATH];
    closePathInstruction = [Instruction.CLOSE_PATH];
    Instruction_default = Instruction;
  }
});

// node_modules/ol/render/VectorContext.js
var VectorContext, VectorContext_default;
var init_VectorContext = __esm({
  "node_modules/ol/render/VectorContext.js"() {
    VectorContext = class {
      /**
       * Render a geometry with a custom renderer.
       *
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       * @param {Function} hitDetectionRenderer Renderer.
       * @param {number} [index] Render order index.
       */
      drawCustom(geometry, feature, renderer, hitDetectionRenderer, index) {
      }
      /**
       * Render a geometry.
       *
       * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
       */
      drawGeometry(geometry) {
      }
      /**
       * Set the rendering style.
       *
       * @param {import("../style/Style.js").default} style The rendering style.
       */
      setStyle(style) {
      }
      /**
       * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../Feature.js").default} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawCircle(circleGeometry, feature, index) {
      }
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("../style/Style.js").default} style Style.
       * @param {number} [index] Render order index.
       */
      drawFeature(feature, style, index) {
      }
      /**
       * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
       * @param {import("../Feature.js").default} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawGeometryCollection(geometryCollectionGeometry, feature, index) {
      }
      /**
       * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawLineString(lineStringGeometry, feature, index) {
      }
      /**
       * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiLineString(multiLineStringGeometry, feature, index) {
      }
      /**
       * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiPoint(multiPointGeometry, feature, index) {
      }
      /**
       * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiPolygon(multiPolygonGeometry, feature, index) {
      }
      /**
       * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawPoint(pointGeometry, feature, index) {
      }
      /**
       * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawPolygon(polygonGeometry, feature, index) {
      }
      /**
       * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawText(geometry, feature, index) {
      }
      /**
       * @param {import("../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
      }
      /**
       * @param {import("../style/Image.js").default} imageStyle Image style.
       * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
       */
      setImageStyle(imageStyle, declutterImageWithText) {
      }
      /**
       * @param {import("../style/Text.js").default} textStyle Text style.
       * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
       */
      setTextStyle(textStyle, declutterImageWithText) {
      }
    };
    VectorContext_default = VectorContext;
  }
});

// node_modules/ol/render/canvas/Builder.js
var CanvasBuilder, Builder_default;
var init_Builder = __esm({
  "node_modules/ol/render/canvas/Builder.js"() {
    init_Instruction();
    init_Relationship();
    init_VectorContext();
    init_colorlike();
    init_extent();
    init_canvas();
    init_array();
    init_inflate();
    CanvasBuilder = class extends VectorContext_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super();
        this.tolerance = tolerance;
        this.maxExtent = maxExtent;
        this.pixelRatio = pixelRatio;
        this.maxLineWidth = 0;
        this.resolution = resolution;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_ = null;
        this.bufferedMaxExtent_ = null;
        this.instructions = [];
        this.coordinates = [];
        this.tmpCoordinate_ = [];
        this.hitDetectionInstructions = [];
        this.state = /** @type {import("../canvas.js").FillStrokeState} */
        {};
      }
      /**
       * @protected
       * @param {Array<number>} dashArray Dash array.
       * @return {Array<number>} Dash array with pixel ratio applied
       */
      applyPixelRatio(dashArray) {
        const pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
          return dash * pixelRatio;
        });
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} stride Stride.
       * @protected
       * @return {number} My end
       */
      appendFlatPointCoordinates(flatCoordinates, stride) {
        const extent = this.getBufferedMaxExtent();
        const tmpCoord = this.tmpCoordinate_;
        const coordinates2 = this.coordinates;
        let myEnd = coordinates2.length;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          tmpCoord[0] = flatCoordinates[i];
          tmpCoord[1] = flatCoordinates[i + 1];
          if (containsCoordinate(extent, tmpCoord)) {
            coordinates2[myEnd++] = tmpCoord[0];
            coordinates2[myEnd++] = tmpCoord[1];
          }
        }
        return myEnd;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} closed Last input coordinate equals first.
       * @param {boolean} skipFirst Skip first coordinate.
       * @protected
       * @return {number} My end.
       */
      appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, closed, skipFirst) {
        const coordinates2 = this.coordinates;
        let myEnd = coordinates2.length;
        const extent = this.getBufferedMaxExtent();
        if (skipFirst) {
          offset2 += stride;
        }
        let lastXCoord = flatCoordinates[offset2];
        let lastYCoord = flatCoordinates[offset2 + 1];
        const nextCoord = this.tmpCoordinate_;
        let skipped = true;
        let i, lastRel, nextRel;
        for (i = offset2 + stride; i < end; i += stride) {
          nextCoord[0] = flatCoordinates[i];
          nextCoord[1] = flatCoordinates[i + 1];
          nextRel = coordinateRelationship(extent, nextCoord);
          if (nextRel !== lastRel) {
            if (skipped) {
              coordinates2[myEnd++] = lastXCoord;
              coordinates2[myEnd++] = lastYCoord;
              skipped = false;
            }
            coordinates2[myEnd++] = nextCoord[0];
            coordinates2[myEnd++] = nextCoord[1];
          } else if (nextRel === Relationship_default.INTERSECTING) {
            coordinates2[myEnd++] = nextCoord[0];
            coordinates2[myEnd++] = nextCoord[1];
            skipped = false;
          } else {
            skipped = true;
          }
          lastXCoord = nextCoord[0];
          lastYCoord = nextCoord[1];
          lastRel = nextRel;
        }
        if (closed && skipped || i === offset2 + stride) {
          coordinates2[myEnd++] = lastXCoord;
          coordinates2[myEnd++] = lastYCoord;
        }
        return myEnd;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Array<number>} builderEnds Builder ends.
       * @return {number} Offset.
       */
      drawCustomCoordinates_(flatCoordinates, offset2, ends, stride, builderEnds) {
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const builderEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            offset2,
            end,
            stride,
            false,
            false
          );
          builderEnds.push(builderEnd);
          offset2 = end;
        }
        return offset2;
      }
      /**
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       * @param {Function} hitDetectionRenderer Renderer.
       * @param {number} [index] Render order index.
       */
      drawCustom(geometry, feature, renderer, hitDetectionRenderer, index) {
        this.beginGeometry(geometry, feature, index);
        const type = geometry.getType();
        const stride = geometry.getStride();
        const builderBegin = this.coordinates.length;
        let flatCoordinates, builderEnd, builderEnds, builderEndss;
        let offset2;
        switch (type) {
          case "MultiPolygon":
            flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getOrientedFlatCoordinates();
            builderEndss = [];
            const endss = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getEndss()
            );
            offset2 = 0;
            for (let i = 0, ii = endss.length; i < ii; ++i) {
              const myEnds = [];
              offset2 = this.drawCustomCoordinates_(
                flatCoordinates,
                offset2,
                endss[i],
                stride,
                myEnds
              );
              builderEndss.push(myEnds);
            }
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEndss,
              geometry,
              renderer,
              inflateMultiCoordinatesArray,
              index
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEndss,
              geometry,
              hitDetectionRenderer || renderer,
              inflateMultiCoordinatesArray,
              index
            ]);
            break;
          case "Polygon":
          case "MultiLineString":
            builderEnds = [];
            flatCoordinates = type == "Polygon" ? (
              /** @type {import("../../geom/Polygon.js").default} */
              geometry.getOrientedFlatCoordinates()
            ) : geometry.getFlatCoordinates();
            offset2 = this.drawCustomCoordinates_(
              flatCoordinates,
              0,
              /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
              geometry.getEnds(),
              stride,
              builderEnds
            );
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnds,
              geometry,
              renderer,
              inflateCoordinatesArray,
              index
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnds,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinatesArray,
              index
            ]);
            break;
          case "LineString":
          case "Circle":
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatLineCoordinates(
              flatCoordinates,
              0,
              flatCoordinates.length,
              stride,
              false,
              false
            );
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer,
              inflateCoordinates,
              index
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinates,
              index
            ]);
            break;
          case "MultiPoint":
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (builderEnd > builderBegin) {
              this.instructions.push([
                Instruction_default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                renderer,
                inflateCoordinates,
                index
              ]);
              this.hitDetectionInstructions.push([
                Instruction_default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                hitDetectionRenderer || renderer,
                inflateCoordinates,
                index
              ]);
            }
            break;
          case "Point":
            flatCoordinates = geometry.getFlatCoordinates();
            this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
            builderEnd = this.coordinates.length;
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer,
              void 0,
              index
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer,
              void 0,
              index
            ]);
            break;
          default:
        }
        this.endGeometry(feature);
      }
      /**
       * @protected
       * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} index Render order index
       */
      beginGeometry(geometry, feature, index) {
        this.beginGeometryInstruction1_ = [
          Instruction_default.BEGIN_GEOMETRY,
          feature,
          0,
          geometry,
          index
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
          Instruction_default.BEGIN_GEOMETRY,
          feature,
          0,
          geometry,
          index
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        return {
          instructions: this.instructions,
          hitDetectionInstructions: this.hitDetectionInstructions,
          coordinates: this.coordinates
        };
      }
      /**
       * Reverse the hit detection instructions.
       */
      reverseHitDetectionInstructions() {
        const hitDetectionInstructions = this.hitDetectionInstructions;
        hitDetectionInstructions.reverse();
        let i;
        const n = hitDetectionInstructions.length;
        let instruction;
        let type;
        let begin = -1;
        for (i = 0; i < n; ++i) {
          instruction = hitDetectionInstructions[i];
          type = /** @type {import("./Instruction.js").default} */
          instruction[0];
          if (type == Instruction_default.END_GEOMETRY) {
            begin = i;
          } else if (type == Instruction_default.BEGIN_GEOMETRY) {
            instruction[2] = i;
            reverseSubArray(this.hitDetectionInstructions, begin, i);
            begin = -1;
          }
        }
      }
      /**
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
        const state = this.state;
        if (fillStyle) {
          const fillStyleColor = fillStyle.getColor();
          state.fillPatternScale = fillStyleColor && typeof fillStyleColor === "object" && "src" in fillStyleColor ? this.pixelRatio : 1;
          state.fillStyle = asColorLike(
            fillStyleColor ? fillStyleColor : defaultFillStyle
          );
        } else {
          state.fillStyle = void 0;
        }
        if (strokeStyle) {
          const strokeStyleColor = strokeStyle.getColor();
          state.strokeStyle = asColorLike(
            strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
          );
          const strokeStyleLineCap = strokeStyle.getLineCap();
          state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
          const strokeStyleLineDash = strokeStyle.getLineDash();
          state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
          const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
          const strokeStyleLineJoin = strokeStyle.getLineJoin();
          state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
          const strokeStyleWidth = strokeStyle.getWidth();
          state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
          const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
          if (state.lineWidth > this.maxLineWidth) {
            this.maxLineWidth = state.lineWidth;
            this.bufferedMaxExtent_ = null;
          }
        } else {
          state.strokeStyle = void 0;
          state.lineCap = void 0;
          state.lineDash = null;
          state.lineDashOffset = void 0;
          state.lineJoin = void 0;
          state.lineWidth = void 0;
          state.miterLimit = void 0;
        }
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Fill instruction.
       */
      createFill(state) {
        const fillStyle = state.fillStyle;
        const fillInstruction2 = [Instruction_default.SET_FILL_STYLE, fillStyle];
        if (typeof fillStyle !== "string") {
          fillInstruction2.push(state.fillPatternScale);
        }
        return fillInstruction2;
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      applyStroke(state) {
        this.instructions.push(this.createStroke(state));
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Stroke instruction.
       */
      createStroke(state) {
        return [
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth * this.pixelRatio,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          this.applyPixelRatio(state.lineDash),
          state.lineDashOffset * this.pixelRatio
        ];
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
       */
      updateFillStyle(state, createFill) {
        const fillStyle = state.fillStyle;
        if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
          if (fillStyle !== void 0) {
            this.instructions.push(createFill.call(this, state));
          }
          state.currentFillStyle = fillStyle;
        }
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
       */
      updateStrokeStyle(state, applyStroke) {
        const strokeStyle = state.strokeStyle;
        const lineCap = state.lineCap;
        const lineDash = state.lineDash;
        const lineDashOffset = state.lineDashOffset;
        const lineJoin = state.lineJoin;
        const lineWidth = state.lineWidth;
        const miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
          if (strokeStyle !== void 0) {
            applyStroke.call(this, state);
          }
          state.currentStrokeStyle = strokeStyle;
          state.currentLineCap = lineCap;
          state.currentLineDash = lineDash;
          state.currentLineDashOffset = lineDashOffset;
          state.currentLineJoin = lineJoin;
          state.currentLineWidth = lineWidth;
          state.currentMiterLimit = miterLimit;
        }
      }
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      endGeometry(feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        const endGeometryInstruction = [Instruction_default.END_GEOMETRY, feature];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
      }
      /**
       * Get the buffered rendering extent.  Rendering will be clipped to the extent
       * provided to the constructor.  To account for symbolizers that may intersect
       * this extent, we calculate a buffered extent (e.g. based on stroke width).
       * @return {import("../../extent.js").Extent} The buffered rendering extent.
       * @protected
       */
      getBufferedMaxExtent() {
        if (!this.bufferedMaxExtent_) {
          this.bufferedMaxExtent_ = clone(this.maxExtent);
          if (this.maxLineWidth > 0) {
            const width = this.resolution * (this.maxLineWidth + 1) / 2;
            buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
          }
        }
        return this.bufferedMaxExtent_;
      }
    };
    Builder_default = CanvasBuilder;
  }
});

// node_modules/ol/render/canvas/ImageBuilder.js
var CanvasImageBuilder, ImageBuilder_default;
var init_ImageBuilder = __esm({
  "node_modules/ol/render/canvas/ImageBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_extent();
    CanvasImageBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = void 0;
        this.anchorX_ = void 0;
        this.anchorY_ = void 0;
        this.height_ = void 0;
        this.opacity_ = void 0;
        this.originX_ = void 0;
        this.originY_ = void 0;
        this.rotateWithView_ = void 0;
        this.rotation_ = void 0;
        this.scale_ = void 0;
        this.width_ = void 0;
        this.declutterMode_ = void 0;
        this.declutterImageWithText_ = void 0;
      }
      /**
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawPoint(pointGeometry, feature, index) {
        if (!this.image_ || this.maxExtent && !containsCoordinate(this.maxExtent, pointGeometry.getFlatCoordinates())) {
          return;
        }
        this.beginGeometry(pointGeometry, feature, index);
        const flatCoordinates = pointGeometry.getFlatCoordinates();
        const stride = pointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_ * this.imagePixelRatio_,
          this.anchorY_ * this.imagePixelRatio_,
          Math.ceil(this.height_ * this.imagePixelRatio_),
          this.opacity_,
          this.originX_ * this.imagePixelRatio_,
          this.originY_ * this.imagePixelRatio_,
          this.rotateWithView_,
          this.rotation_,
          [
            this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
            this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
          ],
          Math.ceil(this.width_ * this.imagePixelRatio_),
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiPoint(multiPointGeometry, feature, index) {
        if (!this.image_) {
          return;
        }
        this.beginGeometry(multiPointGeometry, feature, index);
        const flatCoordinates = multiPointGeometry.getFlatCoordinates();
        const filteredFlatCoordinates = [];
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += multiPointGeometry.getStride()) {
          if (!this.maxExtent || containsCoordinate(this.maxExtent, flatCoordinates.slice(i, i + 2))) {
            filteredFlatCoordinates.push(
              flatCoordinates[i],
              flatCoordinates[i + 1]
            );
          }
        }
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(filteredFlatCoordinates, 2);
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_ * this.imagePixelRatio_,
          this.anchorY_ * this.imagePixelRatio_,
          Math.ceil(this.height_ * this.imagePixelRatio_),
          this.opacity_,
          this.originX_ * this.imagePixelRatio_,
          this.originY_ * this.imagePixelRatio_,
          this.rotateWithView_,
          this.rotation_,
          [
            this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
            this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
          ],
          Math.ceil(this.width_ * this.imagePixelRatio_),
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        this.reverseHitDetectionInstructions();
        this.anchorX_ = void 0;
        this.anchorY_ = void 0;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = void 0;
        this.height_ = void 0;
        this.scale_ = void 0;
        this.opacity_ = void 0;
        this.originX_ = void 0;
        this.originY_ = void 0;
        this.rotateWithView_ = void 0;
        this.rotation_ = void 0;
        this.width_ = void 0;
        return super.finish();
      }
      /**
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       * @param {Object} [sharedData] Shared data.
       */
      setImageStyle(imageStyle, sharedData) {
        const anchor = imageStyle.getAnchor();
        const size = imageStyle.getSize();
        const origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
        this.image_ = imageStyle.getImage(this.pixelRatio);
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0];
        this.originY_ = origin[1];
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterMode_ = imageStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
      }
    };
    ImageBuilder_default = CanvasImageBuilder;
  }
});

// node_modules/ol/render/canvas/LineStringBuilder.js
var CanvasLineStringBuilder, LineStringBuilder_default;
var init_LineStringBuilder = __esm({
  "node_modules/ol/render/canvas/LineStringBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_canvas();
    CanvasLineStringBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} end.
       */
      drawFlatCoordinates_(flatCoordinates, offset2, end, stride) {
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          offset2,
          end,
          stride,
          false,
          false
        );
        const moveToLineToInstruction = [
          Instruction_default.MOVE_TO_LINE_TO,
          myBegin,
          myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
      }
      /**
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawLineString(lineStringGeometry, feature, index) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === void 0 || lineWidth === void 0) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature, index);
        this.hitDetectionInstructions.push(
          [
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ],
          beginPathInstruction
        );
        const flatCoordinates = lineStringGeometry.getFlatCoordinates();
        const stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride
        );
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiLineString(multiLineStringGeometry, feature, index) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === void 0 || lineWidth === void 0) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature, index);
        this.hitDetectionInstructions.push(
          [
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ],
          beginPathInstruction
        );
        const ends = multiLineStringGeometry.getEnds();
        const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        const stride = multiLineStringGeometry.getStride();
        let offset2 = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          offset2 = this.drawFlatCoordinates_(
            flatCoordinates,
            offset2,
            /** @type {number} */
            ends[i],
            stride
          );
        }
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        const state = this.state;
        if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
        }
        this.reverseHitDetectionInstructions();
        this.state = null;
        return super.finish();
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      applyStroke(state) {
        if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
          state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        super.applyStroke(state);
        this.instructions.push(beginPathInstruction);
      }
    };
    LineStringBuilder_default = CanvasLineStringBuilder;
  }
});

// node_modules/ol/render/canvas/PolygonBuilder.js
var CanvasPolygonBuilder, PolygonBuilder_default;
var init_PolygonBuilder = __esm({
  "node_modules/ol/render/canvas/PolygonBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_canvas();
    init_simplify();
    CanvasPolygonBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      drawFlatCoordinatess_(flatCoordinates, offset2, ends, stride) {
        const state = this.state;
        const fill = state.fillStyle !== void 0;
        const stroke = state.strokeStyle !== void 0;
        const numEnds = ends.length;
        this.instructions.push(beginPathInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction);
        for (let i = 0; i < numEnds; ++i) {
          const end = ends[i];
          const myBegin = this.coordinates.length;
          const myEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            offset2,
            end,
            stride,
            true,
            !stroke
          );
          const moveToLineToInstruction = [
            Instruction_default.MOVE_TO_LINE_TO,
            myBegin,
            myEnd
          ];
          this.instructions.push(moveToLineToInstruction);
          this.hitDetectionInstructions.push(moveToLineToInstruction);
          if (stroke) {
            this.instructions.push(closePathInstruction);
            this.hitDetectionInstructions.push(closePathInstruction);
          }
          offset2 = end;
        }
        if (fill) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (stroke) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        return offset2;
      }
      /**
       * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawCircle(circleGeometry, feature, index) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature, index);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const flatCoordinates = circleGeometry.getFlatCoordinates();
        const stride = circleGeometry.getStride();
        const myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          false,
          false
        );
        const circleInstruction = [Instruction_default.CIRCLE, myBegin];
        this.instructions.push(beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
        if (state.fillStyle !== void 0) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (state.strokeStyle !== void 0) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawPolygon(polygonGeometry, feature, index) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature, index);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const ends = polygonGeometry.getEnds();
        const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        const stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(
          flatCoordinates,
          0,
          /** @type {Array<number>} */
          ends,
          stride
        );
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawMultiPolygon(multiPolygonGeometry, feature, index) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature, index);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const endss = multiPolygonGeometry.getEndss();
        const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        const stride = multiPolygonGeometry.getStride();
        let offset2 = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          offset2 = this.drawFlatCoordinatess_(
            flatCoordinates,
            offset2,
            endss[i],
            stride
          );
        }
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        this.reverseHitDetectionInstructions();
        this.state = null;
        const tolerance = this.tolerance;
        if (tolerance !== 0) {
          const coordinates2 = this.coordinates;
          for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
            coordinates2[i] = snap(coordinates2[i], tolerance);
          }
        }
        return super.finish();
      }
      /**
       * @private
       */
      setFillStrokeStyles_() {
        const state = this.state;
        const fillStyle = state.fillStyle;
        if (fillStyle !== void 0) {
          this.updateFillStyle(state, this.createFill);
        }
        if (state.strokeStyle !== void 0) {
          this.updateStrokeStyle(state, this.applyStroke);
        }
      }
    };
    PolygonBuilder_default = CanvasPolygonBuilder;
  }
});

// node_modules/ol/geom/flat/linechunk.js
function lineChunk(chunkLength, flatCoordinates, offset2, end, stride) {
  const chunks = [];
  let cursor = offset2;
  let chunkM = 0;
  let currentChunk = flatCoordinates.slice(offset2, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    const [x1, y1] = currentChunk.slice(-2);
    const x2 = flatCoordinates[cursor + stride];
    const y2 = flatCoordinates[cursor + stride + 1];
    const segmentLength = Math.sqrt(
      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
    );
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      const m = (chunkLength - chunkM + segmentLength) / segmentLength;
      const x = lerp(x1, x2, m);
      const y = lerp(y1, y2, m);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(
        flatCoordinates[cursor + stride],
        flatCoordinates[cursor + stride + 1]
      );
      cursor += stride;
    } else {
      const missing = segmentLength - chunkM;
      const x = lerp(x1, x2, missing / segmentLength);
      const y = lerp(y1, y2, missing / segmentLength);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}
var init_linechunk = __esm({
  "node_modules/ol/geom/flat/linechunk.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/straightchunk.js
function matchingChunk(maxAngle, flatCoordinates, offset2, end, stride) {
  let chunkStart = offset2;
  let chunkEnd = offset2;
  let chunkM = 0;
  let m = 0;
  let start = offset2;
  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset2; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    if (x1 !== void 0) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}
var init_straightchunk = __esm({
  "node_modules/ol/geom/flat/straightchunk.js"() {
  }
});

// node_modules/ol/render/canvas/TextBuilder.js
var TEXT_ALIGN, CanvasTextBuilder, TextBuilder_default;
var init_TextBuilder = __esm({
  "node_modules/ol/render/canvas/TextBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_colorlike();
    init_canvas();
    init_util();
    init_extent();
    init_linechunk();
    init_straightchunk();
    TEXT_ALIGN = {
      "left": 0,
      "center": 0.5,
      "right": 1,
      "top": 0,
      "middle": 0.5,
      "hanging": 0.2,
      "alphabetic": 0.8,
      "ideographic": 0.8,
      "bottom": 1
    };
    CanvasTextBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
        this.labels_ = null;
        this.text_ = "";
        this.textOffsetX_ = 0;
        this.textOffsetY_ = 0;
        this.textRotateWithView_ = void 0;
        this.textRotation_ = 0;
        this.textFillState_ = null;
        this.fillStates = {};
        this.fillStates[defaultFillStyle] = { fillStyle: defaultFillStyle };
        this.textStrokeState_ = null;
        this.strokeStates = {};
        this.textState_ = /** @type {import("../canvas.js").TextState} */
        {};
        this.textStates = {};
        this.textKey_ = "";
        this.fillKey_ = "";
        this.strokeKey_ = "";
        this.declutterMode_ = void 0;
        this.declutterImageWithText_ = void 0;
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        const instructions = super.finish();
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
      }
      /**
       * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} [index] Render order index.
       */
      drawText(geometry, feature, index) {
        const fillState = this.textFillState_;
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        if (this.text_ === "" || !textState || !fillState && !strokeState) {
          return;
        }
        const coordinates2 = this.coordinates;
        let begin = coordinates2.length;
        const geometryType = geometry.getType();
        let flatCoordinates = null;
        let stride = geometry.getStride();
        if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
          if (!intersects(this.maxExtent, geometry.getExtent())) {
            return;
          }
          let ends;
          flatCoordinates = geometry.getFlatCoordinates();
          if (geometryType == "LineString") {
            ends = [flatCoordinates.length];
          } else if (geometryType == "MultiLineString") {
            ends = /** @type {import("../../geom/MultiLineString.js").default} */
            geometry.getEnds();
          } else if (geometryType == "Polygon") {
            ends = /** @type {import("../../geom/Polygon.js").default} */
            geometry.getEnds().slice(0, 1);
          } else if (geometryType == "MultiPolygon") {
            const endss = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getEndss()
            );
            ends = [];
            for (let i = 0, ii = endss.length; i < ii; ++i) {
              ends.push(endss[i][0]);
            }
          }
          this.beginGeometry(geometry, feature, index);
          const repeat = textState.repeat;
          const textAlign = repeat ? void 0 : textState.textAlign;
          let flatOffset = 0;
          for (let o = 0, oo = ends.length; o < oo; ++o) {
            let chunks;
            if (repeat) {
              chunks = lineChunk(
                repeat * this.resolution,
                flatCoordinates,
                flatOffset,
                ends[o],
                stride
              );
            } else {
              chunks = [flatCoordinates.slice(flatOffset, ends[o])];
            }
            for (let c = 0, cc = chunks.length; c < cc; ++c) {
              const chunk = chunks[c];
              let chunkBegin = 0;
              let chunkEnd = chunk.length;
              if (textAlign == void 0) {
                const range = matchingChunk(
                  textState.maxAngle,
                  chunk,
                  0,
                  chunk.length,
                  2
                );
                chunkBegin = range[0];
                chunkEnd = range[1];
              }
              for (let i = chunkBegin; i < chunkEnd; i += stride) {
                coordinates2.push(chunk[i], chunk[i + 1]);
              }
              const end = coordinates2.length;
              flatOffset = ends[o];
              this.drawChars_(begin, end);
              begin = end;
            }
          }
          this.endGeometry(feature);
        } else {
          let geometryWidths = textState.overflow ? null : [];
          switch (geometryType) {
            case "Point":
            case "MultiPoint":
              flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
              geometry.getFlatCoordinates();
              break;
            case "LineString":
              flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
              geometry.getFlatMidpoint();
              break;
            case "Circle":
              flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
              geometry.getCenter();
              break;
            case "MultiLineString":
              flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
              geometry.getFlatMidpoints();
              stride = 2;
              break;
            case "Polygon":
              flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
              geometry.getFlatInteriorPoint();
              if (!textState.overflow) {
                geometryWidths.push(flatCoordinates[2] / this.resolution);
              }
              stride = 3;
              break;
            case "MultiPolygon":
              const interiorPoints = (
                /** @type {import("../../geom/MultiPolygon.js").default} */
                geometry.getFlatInteriorPoints()
              );
              flatCoordinates = [];
              for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                if (!textState.overflow) {
                  geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                }
                flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
              }
              if (flatCoordinates.length === 0) {
                return;
              }
              stride = 2;
              break;
            default:
          }
          const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
          if (end === begin) {
            return;
          }
          if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
            let beg = begin / 2;
            geometryWidths = geometryWidths.filter((w, i) => {
              const keep = coordinates2[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates2[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
              if (!keep) {
                --beg;
              }
              return keep;
            });
          }
          this.saveTextStates_();
          if (textState.backgroundFill || textState.backgroundStroke) {
            this.setFillStrokeStyle(
              textState.backgroundFill,
              textState.backgroundStroke
            );
            if (textState.backgroundFill) {
              this.updateFillStyle(this.state, this.createFill);
            }
            if (textState.backgroundStroke) {
              this.updateStrokeStyle(this.state, this.applyStroke);
              this.hitDetectionInstructions.push(this.createStroke(this.state));
            }
          }
          this.beginGeometry(geometry, feature, index);
          let padding = textState.padding;
          if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
            let p0 = textState.padding[0];
            let p12 = textState.padding[1];
            let p22 = textState.padding[2];
            let p32 = textState.padding[3];
            if (textState.scale[0] < 0) {
              p12 = -p12;
              p32 = -p32;
            }
            if (textState.scale[1] < 0) {
              p0 = -p0;
              p22 = -p22;
            }
            padding = [p0, p12, p22, p32];
          }
          const pixelRatio = this.pixelRatio;
          this.instructions.push([
            Instruction_default.DRAW_IMAGE,
            begin,
            end,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [1, 1],
            NaN,
            this.declutterMode_,
            this.declutterImageWithText_,
            padding == defaultPadding ? defaultPadding : padding.map(function(p) {
              return p * pixelRatio;
            }),
            !!textState.backgroundFill,
            !!textState.backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            geometryWidths
          ]);
          const scale5 = 1 / pixelRatio;
          const currentFillStyle = this.state.fillStyle;
          if (textState.backgroundFill) {
            this.state.fillStyle = defaultFillStyle;
            this.hitDetectionInstructions.push(this.createFill(this.state));
          }
          this.hitDetectionInstructions.push([
            Instruction_default.DRAW_IMAGE,
            begin,
            end,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [scale5, scale5],
            NaN,
            this.declutterMode_,
            this.declutterImageWithText_,
            padding,
            !!textState.backgroundFill,
            !!textState.backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_ ? defaultFillStyle : this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            geometryWidths
          ]);
          if (textState.backgroundFill) {
            this.state.fillStyle = currentFillStyle;
            this.hitDetectionInstructions.push(this.createFill(this.state));
          }
          this.endGeometry(feature);
        }
      }
      /**
       * @private
       */
      saveTextStates_() {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const fillState = this.textFillState_;
        const strokeKey = this.strokeKey_;
        if (strokeState) {
          if (!(strokeKey in this.strokeStates)) {
            this.strokeStates[strokeKey] = {
              strokeStyle: strokeState.strokeStyle,
              lineCap: strokeState.lineCap,
              lineDashOffset: strokeState.lineDashOffset,
              lineWidth: strokeState.lineWidth,
              lineJoin: strokeState.lineJoin,
              miterLimit: strokeState.miterLimit,
              lineDash: strokeState.lineDash
            };
          }
        }
        const textKey = this.textKey_;
        if (!(textKey in this.textStates)) {
          this.textStates[textKey] = {
            font: textState.font,
            textAlign: textState.textAlign || defaultTextAlign,
            justify: textState.justify,
            textBaseline: textState.textBaseline || defaultTextBaseline,
            scale: textState.scale
          };
        }
        const fillKey = this.fillKey_;
        if (fillState) {
          if (!(fillKey in this.fillStates)) {
            this.fillStates[fillKey] = {
              fillStyle: fillState.fillStyle
            };
          }
        }
      }
      /**
       * @private
       * @param {number} begin Begin.
       * @param {number} end End.
       */
      drawChars_(begin, end) {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const strokeKey = this.strokeKey_;
        const textKey = this.textKey_;
        const fillKey = this.fillKey_;
        this.saveTextStates_();
        const pixelRatio = this.pixelRatio;
        const baseline = TEXT_ALIGN[textState.textBaseline];
        const offsetY = this.textOffsetY_ * pixelRatio;
        const text = this.text_;
        const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
        this.instructions.push([
          Instruction_default.DRAW_CHARS,
          begin,
          end,
          baseline,
          textState.overflow,
          fillKey,
          textState.maxAngle,
          pixelRatio,
          offsetY,
          strokeKey,
          strokeWidth * pixelRatio,
          text,
          textKey,
          1,
          this.declutterMode_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_CHARS,
          begin,
          end,
          baseline,
          textState.overflow,
          fillKey ? defaultFillStyle : fillKey,
          textState.maxAngle,
          pixelRatio,
          offsetY,
          strokeKey,
          strokeWidth * pixelRatio,
          text,
          textKey,
          1 / pixelRatio,
          this.declutterMode_
        ]);
      }
      /**
       * @param {import("../../style/Text.js").default} textStyle Text style.
       * @param {Object} [sharedData] Shared data.
       */
      setTextStyle(textStyle, sharedData) {
        let textState, fillState, strokeState;
        if (!textStyle) {
          this.text_ = "";
        } else {
          const textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            fillState = null;
            this.textFillState_ = fillState;
          } else {
            fillState = this.textFillState_;
            if (!fillState) {
              fillState = /** @type {import("../canvas.js").FillState} */
              {};
              this.textFillState_ = fillState;
            }
            fillState.fillStyle = asColorLike(
              textFillStyle.getColor() || defaultFillStyle
            );
          }
          const textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            strokeState = null;
            this.textStrokeState_ = strokeState;
          } else {
            strokeState = this.textStrokeState_;
            if (!strokeState) {
              strokeState = /** @type {import("../canvas.js").StrokeState} */
              {};
              this.textStrokeState_ = strokeState;
            }
            const lineDash = textStrokeStyle.getLineDash();
            const lineDashOffset = textStrokeStyle.getLineDashOffset();
            const lineWidth = textStrokeStyle.getWidth();
            const miterLimit = textStrokeStyle.getMiterLimit();
            strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
            strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
            strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
            strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
            strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
            strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
            strokeState.strokeStyle = asColorLike(
              textStrokeStyle.getColor() || defaultStrokeStyle
            );
          }
          textState = this.textState_;
          const font = textStyle.getFont() || defaultFont;
          registerFont(font);
          const textScale = textStyle.getScaleArray();
          textState.overflow = textStyle.getOverflow();
          textState.font = font;
          textState.maxAngle = textStyle.getMaxAngle();
          textState.placement = textStyle.getPlacement();
          textState.textAlign = textStyle.getTextAlign();
          textState.repeat = textStyle.getRepeat();
          textState.justify = textStyle.getJustify();
          textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
          textState.backgroundFill = textStyle.getBackgroundFill();
          textState.backgroundStroke = textStyle.getBackgroundStroke();
          textState.padding = textStyle.getPadding() || defaultPadding;
          textState.scale = textScale === void 0 ? [1, 1] : textScale;
          const textOffsetX = textStyle.getOffsetX();
          const textOffsetY = textStyle.getOffsetY();
          const textRotateWithView = textStyle.getRotateWithView();
          const textRotation = textStyle.getRotation();
          this.text_ = textStyle.getText() || "";
          this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
          this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
          this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
          this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
          this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
          this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.repeat || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
          this.fillKey_ = fillState && fillState.fillStyle ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
        }
        this.declutterMode_ = textStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
      }
    };
    TextBuilder_default = CanvasTextBuilder;
  }
});

// node_modules/ol/render/canvas/BuilderGroup.js
var BATCH_CONSTRUCTORS, BuilderGroup, BuilderGroup_default;
var init_BuilderGroup = __esm({
  "node_modules/ol/render/canvas/BuilderGroup.js"() {
    init_Builder();
    init_ImageBuilder();
    init_LineStringBuilder();
    init_PolygonBuilder();
    init_TextBuilder();
    BATCH_CONSTRUCTORS = {
      "Circle": PolygonBuilder_default,
      "Default": Builder_default,
      "Image": ImageBuilder_default,
      "LineString": LineStringBuilder_default,
      "Polygon": PolygonBuilder_default,
      "Text": TextBuilder_default
    };
    BuilderGroup = class {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Max extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        this.tolerance_ = tolerance;
        this.maxExtent_ = maxExtent;
        this.pixelRatio_ = pixelRatio;
        this.resolution_ = resolution;
        this.buildersByZIndex_ = {};
      }
      /**
       * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
       */
      finish() {
        const builderInstructions = {};
        for (const zKey in this.buildersByZIndex_) {
          builderInstructions[zKey] = builderInstructions[zKey] || {};
          const builders = this.buildersByZIndex_[zKey];
          for (const builderKey in builders) {
            const builderInstruction = builders[builderKey].finish();
            builderInstructions[zKey][builderKey] = builderInstruction;
          }
        }
        return builderInstructions;
      }
      /**
       * @param {number|undefined} zIndex Z index.
       * @param {import("../canvas.js").BuilderType} builderType Replay type.
       * @return {import("../VectorContext.js").default} Replay.
       */
      getBuilder(zIndex, builderType) {
        const zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
        let replays = this.buildersByZIndex_[zIndexKey];
        if (replays === void 0) {
          replays = {};
          this.buildersByZIndex_[zIndexKey] = replays;
        }
        let replay = replays[builderType];
        if (replay === void 0) {
          const Constructor = BATCH_CONSTRUCTORS[builderType];
          replay = new Constructor(
            this.tolerance_,
            this.maxExtent_,
            this.resolution_,
            this.pixelRatio_
          );
          replays[builderType] = replay;
        }
        return replay;
      }
    };
    BuilderGroup_default = BuilderGroup;
  }
});

// node_modules/ol/geom/flat/textpath.js
function drawTextOnPath(flatCoordinates, offset2, end, stride, text, startM, maxAngle, scale5, measureAndCacheTextWidth2, font, cache3, rotation) {
  let x2 = flatCoordinates[offset2];
  let y2 = flatCoordinates[offset2 + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset2 += stride;
    x2 = flatCoordinates[offset2];
    y2 = flatCoordinates[offset2 + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset2 < end - stride && segmentM + segmentLength < startM);
  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = lerp(x1, x2, interpolate);
  const beginY = lerp(y1, y2, interpolate);
  const startOffset = offset2 - stride;
  const startLength = segmentM;
  const endM = startM + scale5 * measureAndCacheTextWidth2(font, text, cache3);
  while (offset2 < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = lerp(x1, x2, interpolate);
  const endY = lerp(y1, y2, interpolate);
  let reverse;
  if (rotation) {
    const flat = [beginX, beginY, endX, endY];
    rotate3(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }
  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset2;
  offset2 = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset2];
  y2 = flatCoordinates[offset2 + 1];
  let previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x = (endX + beginX) / 2;
    const y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }
  text = text.replace(/\n/g, " ");
  for (let i = 0, ii = text.length; i < ii; ) {
    advance();
    let angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      let delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;
    const iStart = i;
    let charLength = 0;
    for (; i < ii; ++i) {
      const index = reverse ? ii - i - 1 : i;
      const len = scale5 * measureAndCacheTextWidth2(font, text[index], cache3);
      if (offset2 + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    const x = lerp(x1, x2, interpolate);
    const y = lerp(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}
var init_textpath = __esm({
  "node_modules/ol/geom/flat/textpath.js"() {
    init_math();
    init_transform2();
  }
});

// node_modules/ol/render/canvas/Executor.js
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
function horizontalTextAlign(text, align) {
  if (align === "start") {
    align = rtlRegEx.test(text) ? "right" : "left";
  } else if (align === "end") {
    align = rtlRegEx.test(text) ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
var tmpExtent, p1, p2, p3, p4, rtlRegEx, Executor, Executor_default;
var init_Executor = __esm({
  "node_modules/ol/render/canvas/Executor.js"() {
    init_Instruction();
    init_ZIndexContext();
    init_TextBuilder();
    init_transform();
    init_extent();
    init_canvas();
    init_textpath();
    init_array();
    init_length();
    init_transform2();
    tmpExtent = createEmpty();
    p1 = [];
    p2 = [];
    p3 = [];
    p4 = [];
    rtlRegEx = new RegExp(
      /* eslint-disable prettier/prettier */
      "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
      /* eslint-enable prettier/prettier */
    );
    Executor = class {
      /**
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The replay can have overlapping geometries.
       * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
       * @param {boolean} [deferredRendering] Enable deferred rendering.
       */
      constructor(resolution, pixelRatio, overlaps, instructions, deferredRendering) {
        this.overlaps = overlaps;
        this.pixelRatio = pixelRatio;
        this.resolution = resolution;
        this.alignAndScaleFill_;
        this.instructions = instructions.instructions;
        this.coordinates = instructions.coordinates;
        this.coordinateCache_ = {};
        this.renderedTransform_ = create();
        this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        this.pixelCoordinates_ = null;
        this.viewRotation_ = 0;
        this.fillStates = instructions.fillStates || {};
        this.strokeStates = instructions.strokeStates || {};
        this.textStates = instructions.textStates || {};
        this.widths_ = {};
        this.labels_ = {};
        this.zIndexContext_ = deferredRendering ? new ZIndexContext_default() : null;
      }
      /**
       * @return {ZIndexContext} ZIndex context.
       */
      getZIndexContext() {
        return this.zIndexContext_;
      }
      /**
       * @param {string|Array<string>} text Text.
       * @param {string} textKey Text style key.
       * @param {string} fillKey Fill style key.
       * @param {string} strokeKey Stroke style key.
       * @return {import("../canvas.js").Label} Label.
       */
      createLabel(text, textKey, fillKey, strokeKey) {
        const key = text + textKey + fillKey + strokeKey;
        if (this.labels_[key]) {
          return this.labels_[key];
        }
        const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        const fillState = fillKey ? this.fillStates[fillKey] : null;
        const textState = this.textStates[textKey];
        const pixelRatio = this.pixelRatio;
        const scale5 = [
          textState.scale[0] * pixelRatio,
          textState.scale[1] * pixelRatio
        ];
        const textIsArray = Array.isArray(text);
        const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(
          Array.isArray(text) ? text[0] : text,
          textState.textAlign || defaultTextAlign
        );
        const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const chunks = textIsArray ? text : text.split("\n").reduce(createTextChunks, []);
        const { width, height, widths, heights, lineWidths } = getTextDimensions(
          textState,
          chunks
        );
        const renderWidth = width + strokeWidth;
        const contextInstructions = [];
        const w = (renderWidth + 2) * scale5[0];
        const h = (height + strokeWidth) * scale5[1];
        const label = {
          width: w < 0 ? Math.floor(w) : Math.ceil(w),
          height: h < 0 ? Math.floor(h) : Math.ceil(h),
          contextInstructions
        };
        if (scale5[0] != 1 || scale5[1] != 1) {
          contextInstructions.push("scale", scale5);
        }
        if (strokeKey) {
          contextInstructions.push("strokeStyle", strokeState.strokeStyle);
          contextInstructions.push("lineWidth", strokeWidth);
          contextInstructions.push("lineCap", strokeState.lineCap);
          contextInstructions.push("lineJoin", strokeState.lineJoin);
          contextInstructions.push("miterLimit", strokeState.miterLimit);
          contextInstructions.push("setLineDash", [strokeState.lineDash]);
          contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
        }
        if (fillKey) {
          contextInstructions.push("fillStyle", fillState.fillStyle);
        }
        contextInstructions.push("textBaseline", "middle");
        contextInstructions.push("textAlign", "center");
        const leftRight = 0.5 - align;
        let x = align * renderWidth + leftRight * strokeWidth;
        const strokeInstructions = [];
        const fillInstructions = [];
        let lineHeight = 0;
        let lineOffset = 0;
        let widthHeightIndex = 0;
        let lineWidthIndex = 0;
        let previousFont;
        for (let i = 0, ii = chunks.length; i < ii; i += 2) {
          const text2 = chunks[i];
          if (text2 === "\n") {
            lineOffset += lineHeight;
            lineHeight = 0;
            x = align * renderWidth + leftRight * strokeWidth;
            ++lineWidthIndex;
            continue;
          }
          const font = chunks[i + 1] || textState.font;
          if (font !== previousFont) {
            if (strokeKey) {
              strokeInstructions.push("font", font);
            }
            if (fillKey) {
              fillInstructions.push("font", font);
            }
            previousFont = font;
          }
          lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
          const fillStrokeArgs = [
            text2,
            x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
            0.5 * (strokeWidth + lineHeight) + lineOffset
          ];
          x += widths[widthHeightIndex];
          if (strokeKey) {
            strokeInstructions.push("strokeText", fillStrokeArgs);
          }
          if (fillKey) {
            fillInstructions.push("fillText", fillStrokeArgs);
          }
          ++widthHeightIndex;
        }
        Array.prototype.push.apply(contextInstructions, strokeInstructions);
        Array.prototype.push.apply(contextInstructions, fillInstructions);
        this.labels_[key] = label;
        return label;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       */
      replayTextBackground_(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
        context.beginPath();
        context.moveTo.apply(context, p12);
        context.lineTo.apply(context, p22);
        context.lineTo.apply(context, p32);
        context.lineTo.apply(context, p42);
        context.lineTo.apply(context, p12);
        if (fillInstruction2) {
          this.alignAndScaleFill_ = /** @type {number} */
          fillInstruction2[2];
          this.fill_(context);
        }
        if (strokeInstruction2) {
          this.setStrokeStyle_(
            context,
            /** @type {Array<*>} */
            strokeInstruction2
          );
          context.stroke();
        }
      }
      /**
       * @private
       * @param {number} sheetWidth Width of the sprite sheet.
       * @param {number} sheetHeight Height of the sprite sheet.
       * @param {number} centerX X.
       * @param {number} centerY Y.
       * @param {number} width Width.
       * @param {number} height Height.
       * @param {number} anchorX Anchor X.
       * @param {number} anchorY Anchor Y.
       * @param {number} originX Origin X.
       * @param {number} originY Origin Y.
       * @param {number} rotation Rotation.
       * @param {import("../../size.js").Size} scale Scale.
       * @param {boolean} snapToPixel Snap to pixel.
       * @param {Array<number>} padding Padding.
       * @param {boolean} fillStroke Background fill or stroke.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
       */
      calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale5, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale5[0];
        anchorY *= scale5[1];
        let x = centerX - anchorX;
        let y = centerY - anchorY;
        const w = width + originX > sheetWidth ? sheetWidth - originX : width;
        const h = height + originY > sheetHeight ? sheetHeight - originY : height;
        const boxW = padding[3] + w * scale5[0] + padding[1];
        const boxH = padding[0] + h * scale5[1] + padding[2];
        const boxX = x - padding[3];
        const boxY = y - padding[0];
        if (fillStroke || rotation !== 0) {
          p1[0] = boxX;
          p4[0] = boxX;
          p1[1] = boxY;
          p2[1] = boxY;
          p2[0] = boxX + boxW;
          p3[0] = p2[0];
          p3[1] = boxY + boxH;
          p4[1] = p3[1];
        }
        let transform2;
        if (rotation !== 0) {
          transform2 = compose(
            create(),
            centerX,
            centerY,
            1,
            1,
            rotation,
            -centerX,
            -centerY
          );
          apply(transform2, p1);
          apply(transform2, p2);
          apply(transform2, p3);
          apply(transform2, p4);
          createOrUpdate(
            Math.min(p1[0], p2[0], p3[0], p4[0]),
            Math.min(p1[1], p2[1], p3[1], p4[1]),
            Math.max(p1[0], p2[0], p3[0], p4[0]),
            Math.max(p1[1], p2[1], p3[1], p4[1]),
            tmpExtent
          );
        } else {
          createOrUpdate(
            Math.min(boxX, boxX + boxW),
            Math.min(boxY, boxY + boxH),
            Math.max(boxX, boxX + boxW),
            Math.max(boxY, boxY + boxH),
            tmpExtent
          );
        }
        if (snapToPixel) {
          x = Math.round(x);
          y = Math.round(y);
        }
        return {
          drawImageX: x,
          drawImageY: y,
          drawImageW: w,
          drawImageH: h,
          originX,
          originY,
          declutterBox: {
            minX: tmpExtent[0],
            minY: tmpExtent[1],
            maxX: tmpExtent[2],
            maxY: tmpExtent[3],
            value: feature
          },
          canvasTransform: transform2,
          scale: scale5
        };
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
       * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
       * @param {ImageOrLabelDimensions} dimensions Dimensions.
       * @param {number} opacity Opacity.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @return {boolean} The image or label was rendered.
       */
      replayImageOrLabel_(context, scaledCanvasSize, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
        const fillStroke = !!(fillInstruction2 || strokeInstruction2);
        const box = dimensions.declutterBox;
        const strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
        const intersects3 = box.minX - strokePadding <= scaledCanvasSize[0] && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= scaledCanvasSize[1] && box.maxY + strokePadding >= 0;
        if (intersects3) {
          if (fillStroke) {
            this.replayTextBackground_(
              context,
              p1,
              p2,
              p3,
              p4,
              /** @type {Array<*>} */
              fillInstruction2,
              /** @type {Array<*>} */
              strokeInstruction2
            );
          }
          drawImageOrLabel(
            context,
            dimensions.canvasTransform,
            opacity,
            imageOrLabel,
            dimensions.originX,
            dimensions.originY,
            dimensions.drawImageW,
            dimensions.drawImageH,
            dimensions.drawImageX,
            dimensions.drawImageY,
            dimensions.scale
          );
        }
        return true;
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       */
      fill_(context) {
        const alignAndScale = this.alignAndScaleFill_;
        if (alignAndScale) {
          const origin = apply(this.renderedTransform_, [0, 0]);
          const repeatSize = 512 * this.pixelRatio;
          context.save();
          context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
          if (alignAndScale !== 1) {
            context.scale(alignAndScale, alignAndScale);
          }
          context.rotate(this.viewRotation_);
        }
        context.fill();
        if (alignAndScale) {
          context.restore();
        }
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {Array<*>} instruction Instruction.
       */
      setStrokeStyle_(context, instruction) {
        context.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
        instruction[1];
        context.lineWidth = /** @type {number} */
        instruction[2];
        context.lineCap = /** @type {CanvasLineCap} */
        instruction[3];
        context.lineJoin = /** @type {CanvasLineJoin} */
        instruction[4];
        context.miterLimit = /** @type {number} */
        instruction[5];
        context.lineDashOffset = /** @type {number} */
        instruction[7];
        context.setLineDash(
          /** @type {Array<number>} */
          instruction[6]
        );
      }
      /**
       * @private
       * @param {string|Array<string>} text The text to draw.
       * @param {string} textKey The key of the text state.
       * @param {string} strokeKey The key for the stroke state.
       * @param {string} fillKey The key for the fill state.
       * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
       */
      drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
        const textState = this.textStates[textKey];
        const label = this.createLabel(text, textKey, fillKey, strokeKey);
        const strokeState = this.strokeStates[strokeKey];
        const pixelRatio = this.pixelRatio;
        const align = horizontalTextAlign(
          Array.isArray(text) ? text[0] : text,
          textState.textAlign || defaultTextAlign
        );
        const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
        const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const width = label.width / pixelRatio - 2 * textState.scale[0];
        const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        return {
          label,
          anchorX,
          anchorY
        };
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {Array<*>} instructions Instructions array.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {FeatureCallback<T>} [featureCallback] Feature callback.
       * @param {import("../../extent.js").Extent} [hitExtent] Only check
       *     features that intersect this extent.
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       * @return {T|undefined} Callback result.
       * @template T
       */
      execute_(context, scaledCanvasSize, transform2, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
        const zIndexContext = this.zIndexContext_;
        let pixelCoordinates;
        if (this.pixelCoordinates_ && equals(transform2, this.renderedTransform_)) {
          pixelCoordinates = this.pixelCoordinates_;
        } else {
          if (!this.pixelCoordinates_) {
            this.pixelCoordinates_ = [];
          }
          pixelCoordinates = transform2D(
            this.coordinates,
            0,
            this.coordinates.length,
            2,
            transform2,
            this.pixelCoordinates_
          );
          setFromArray(this.renderedTransform_, transform2);
        }
        let i = 0;
        const ii = instructions.length;
        let d = 0;
        let dd;
        let anchorX, anchorY, declutterMode, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
        let pendingFill = 0;
        let pendingStroke = 0;
        let lastFillInstruction = null;
        let lastStrokeInstruction = null;
        const coordinateCache = this.coordinateCache_;
        const viewRotation = this.viewRotation_;
        const viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
        const state = (
          /** @type {import("../../render.js").State} */
          {
            context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation
          }
        );
        const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        let feature;
        let x, y, currentGeometry;
        while (i < ii) {
          const instruction = instructions[i];
          const type = (
            /** @type {import("./Instruction.js").default} */
            instruction[0]
          );
          switch (type) {
            case Instruction_default.BEGIN_GEOMETRY:
              feature = /** @type {import("../../Feature.js").FeatureLike} */
              instruction[1];
              currentGeometry = instruction[3];
              if (!feature.getGeometry()) {
                i = /** @type {number} */
                instruction[2];
              } else if (hitExtent !== void 0 && !intersects(hitExtent, currentGeometry.getExtent())) {
                i = /** @type {number} */
                instruction[2] + 1;
              } else {
                ++i;
              }
              if (zIndexContext) {
                zIndexContext.zIndex = instruction[4];
              }
              break;
            case Instruction_default.BEGIN_PATH:
              if (pendingFill > batchSize) {
                this.fill_(context);
                pendingFill = 0;
              }
              if (pendingStroke > batchSize) {
                context.stroke();
                pendingStroke = 0;
              }
              if (!pendingFill && !pendingStroke) {
                context.beginPath();
                prevX = NaN;
                prevY = NaN;
              }
              ++i;
              break;
            case Instruction_default.CIRCLE:
              d = /** @type {number} */
              instruction[1];
              const x1 = pixelCoordinates[d];
              const y1 = pixelCoordinates[d + 1];
              const x2 = pixelCoordinates[d + 2];
              const y2 = pixelCoordinates[d + 3];
              const dx = x2 - x1;
              const dy = y2 - y1;
              const r = Math.sqrt(dx * dx + dy * dy);
              context.moveTo(x1 + r, y1);
              context.arc(x1, y1, r, 0, 2 * Math.PI, true);
              ++i;
              break;
            case Instruction_default.CLOSE_PATH:
              context.closePath();
              ++i;
              break;
            case Instruction_default.CUSTOM:
              d = /** @type {number} */
              instruction[1];
              dd = instruction[2];
              const geometry = (
                /** @type {import("../../geom/SimpleGeometry.js").default} */
                instruction[3]
              );
              const renderer = instruction[4];
              const fn = instruction[5];
              state.geometry = geometry;
              state.feature = feature;
              if (!(i in coordinateCache)) {
                coordinateCache[i] = [];
              }
              const coords = coordinateCache[i];
              if (fn) {
                fn(pixelCoordinates, d, dd, 2, coords);
              } else {
                coords[0] = pixelCoordinates[d];
                coords[1] = pixelCoordinates[d + 1];
                coords.length = 2;
              }
              if (zIndexContext) {
                zIndexContext.zIndex = instruction[6];
              }
              renderer(coords, state);
              ++i;
              break;
            case Instruction_default.DRAW_IMAGE:
              d = /** @type {number} */
              instruction[1];
              dd = /** @type {number} */
              instruction[2];
              image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
              instruction[3];
              anchorX = /** @type {number} */
              instruction[4];
              anchorY = /** @type {number} */
              instruction[5];
              let height = (
                /** @type {number} */
                instruction[6]
              );
              const opacity = (
                /** @type {number} */
                instruction[7]
              );
              const originX = (
                /** @type {number} */
                instruction[8]
              );
              const originY = (
                /** @type {number} */
                instruction[9]
              );
              const rotateWithView = (
                /** @type {boolean} */
                instruction[10]
              );
              let rotation = (
                /** @type {number} */
                instruction[11]
              );
              const scale5 = (
                /** @type {import("../../size.js").Size} */
                instruction[12]
              );
              let width = (
                /** @type {number} */
                instruction[13]
              );
              declutterMode = instruction[14] || "declutter";
              const declutterImageWithText = (
                /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
                instruction[15]
              );
              if (!image && instruction.length >= 20) {
                text = /** @type {string} */
                instruction[19];
                textKey = /** @type {string} */
                instruction[20];
                strokeKey = /** @type {string} */
                instruction[21];
                fillKey = /** @type {string} */
                instruction[22];
                const labelWithAnchor = this.drawLabelWithPointPlacement_(
                  text,
                  textKey,
                  strokeKey,
                  fillKey
                );
                image = labelWithAnchor.label;
                instruction[3] = image;
                const textOffsetX = (
                  /** @type {number} */
                  instruction[23]
                );
                anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                instruction[4] = anchorX;
                const textOffsetY = (
                  /** @type {number} */
                  instruction[24]
                );
                anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                instruction[5] = anchorY;
                height = image.height;
                instruction[6] = height;
                width = image.width;
                instruction[13] = width;
              }
              let geometryWidths;
              if (instruction.length > 25) {
                geometryWidths = /** @type {number} */
                instruction[25];
              }
              let padding, backgroundFill, backgroundStroke;
              if (instruction.length > 17) {
                padding = /** @type {Array<number>} */
                instruction[16];
                backgroundFill = /** @type {boolean} */
                instruction[17];
                backgroundStroke = /** @type {boolean} */
                instruction[18];
              } else {
                padding = defaultPadding;
                backgroundFill = false;
                backgroundStroke = false;
              }
              if (rotateWithView && viewRotationFromTransform) {
                rotation += viewRotation;
              } else if (!rotateWithView && !viewRotationFromTransform) {
                rotation -= viewRotation;
              }
              let widthIndex = 0;
              for (; d < dd; d += 2) {
                if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                  continue;
                }
                const dimensions = this.calculateImageOrLabelDimensions_(
                  image.width,
                  image.height,
                  pixelCoordinates[d],
                  pixelCoordinates[d + 1],
                  width,
                  height,
                  anchorX,
                  anchorY,
                  originX,
                  originY,
                  rotation,
                  scale5,
                  snapToPixel,
                  padding,
                  backgroundFill || backgroundStroke,
                  feature
                );
                const args = [
                  context,
                  scaledCanvasSize,
                  image,
                  dimensions,
                  opacity,
                  backgroundFill ? (
                    /** @type {Array<*>} */
                    lastFillInstruction
                  ) : null,
                  backgroundStroke ? (
                    /** @type {Array<*>} */
                    lastStrokeInstruction
                  ) : null
                ];
                if (declutterTree) {
                  let imageArgs, imageDeclutterMode, imageDeclutterBox;
                  if (declutterImageWithText) {
                    const index = dd - d;
                    if (!declutterImageWithText[index]) {
                      declutterImageWithText[index] = { args, declutterMode };
                      continue;
                    }
                    const imageDeclutter = declutterImageWithText[index];
                    imageArgs = imageDeclutter.args;
                    imageDeclutterMode = imageDeclutter.declutterMode;
                    delete declutterImageWithText[index];
                    imageDeclutterBox = getDeclutterBox(imageArgs);
                  }
                  let renderImage, renderText;
                  if (imageArgs && (imageDeclutterMode !== "declutter" || !declutterTree.collides(imageDeclutterBox))) {
                    renderImage = true;
                  }
                  if (declutterMode !== "declutter" || !declutterTree.collides(dimensions.declutterBox)) {
                    renderText = true;
                  }
                  if (imageDeclutterMode === "declutter" && declutterMode === "declutter") {
                    const render2 = renderImage && renderText;
                    renderImage = render2;
                    renderText = render2;
                  }
                  if (renderImage) {
                    if (imageDeclutterMode !== "none") {
                      declutterTree.insert(imageDeclutterBox);
                    }
                    this.replayImageOrLabel_.apply(this, imageArgs);
                  }
                  if (renderText) {
                    if (declutterMode !== "none") {
                      declutterTree.insert(dimensions.declutterBox);
                    }
                    this.replayImageOrLabel_.apply(this, args);
                  }
                } else {
                  this.replayImageOrLabel_.apply(this, args);
                }
              }
              ++i;
              break;
            case Instruction_default.DRAW_CHARS:
              const begin = (
                /** @type {number} */
                instruction[1]
              );
              const end = (
                /** @type {number} */
                instruction[2]
              );
              const baseline = (
                /** @type {number} */
                instruction[3]
              );
              const overflow = (
                /** @type {number} */
                instruction[4]
              );
              fillKey = /** @type {string} */
              instruction[5];
              const maxAngle = (
                /** @type {number} */
                instruction[6]
              );
              const measurePixelRatio = (
                /** @type {number} */
                instruction[7]
              );
              const offsetY = (
                /** @type {number} */
                instruction[8]
              );
              strokeKey = /** @type {string} */
              instruction[9];
              const strokeWidth = (
                /** @type {number} */
                instruction[10]
              );
              text = /** @type {string} */
              instruction[11];
              textKey = /** @type {string} */
              instruction[12];
              const pixelRatioScale = [
                /** @type {number} */
                instruction[13],
                /** @type {number} */
                instruction[13]
              ];
              declutterMode = instruction[14] || "declutter";
              const textState = this.textStates[textKey];
              const font = textState.font;
              const textScale = [
                textState.scale[0] * measurePixelRatio,
                textState.scale[1] * measurePixelRatio
              ];
              let cachedWidths;
              if (font in this.widths_) {
                cachedWidths = this.widths_[font];
              } else {
                cachedWidths = {};
                this.widths_[font] = cachedWidths;
              }
              const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
              const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);
              if (overflow || textLength <= pathLength) {
                const textAlign = this.textStates[textKey].textAlign;
                const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
                const parts = drawTextOnPath(
                  pixelCoordinates,
                  begin,
                  end,
                  2,
                  text,
                  startM,
                  maxAngle,
                  Math.abs(textScale[0]),
                  measureAndCacheTextWidth,
                  font,
                  cachedWidths,
                  viewRotationFromTransform ? 0 : this.viewRotation_
                );
                drawChars:
                  if (parts) {
                    const replayImageOrLabelArgs = [];
                    let c, cc, chars, label, part;
                    if (strokeKey) {
                      for (c = 0, cc = parts.length; c < cc; ++c) {
                        part = parts[c];
                        chars = /** @type {string} */
                        part[4];
                        label = this.createLabel(chars, textKey, "", strokeKey);
                        anchorX = /** @type {number} */
                        part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                        anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                        const dimensions = this.calculateImageOrLabelDimensions_(
                          label.width,
                          label.height,
                          part[0],
                          part[1],
                          label.width,
                          label.height,
                          anchorX,
                          anchorY,
                          0,
                          0,
                          part[3],
                          pixelRatioScale,
                          false,
                          defaultPadding,
                          false,
                          feature
                        );
                        if (declutterTree && declutterMode === "declutter" && declutterTree.collides(dimensions.declutterBox)) {
                          break drawChars;
                        }
                        replayImageOrLabelArgs.push([
                          context,
                          scaledCanvasSize,
                          label,
                          dimensions,
                          1,
                          null,
                          null
                        ]);
                      }
                    }
                    if (fillKey) {
                      for (c = 0, cc = parts.length; c < cc; ++c) {
                        part = parts[c];
                        chars = /** @type {string} */
                        part[4];
                        label = this.createLabel(chars, textKey, fillKey, "");
                        anchorX = /** @type {number} */
                        part[2];
                        anchorY = baseline * label.height - offsetY;
                        const dimensions = this.calculateImageOrLabelDimensions_(
                          label.width,
                          label.height,
                          part[0],
                          part[1],
                          label.width,
                          label.height,
                          anchorX,
                          anchorY,
                          0,
                          0,
                          part[3],
                          pixelRatioScale,
                          false,
                          defaultPadding,
                          false,
                          feature
                        );
                        if (declutterTree && declutterMode === "declutter" && declutterTree.collides(dimensions.declutterBox)) {
                          break drawChars;
                        }
                        replayImageOrLabelArgs.push([
                          context,
                          scaledCanvasSize,
                          label,
                          dimensions,
                          1,
                          null,
                          null
                        ]);
                      }
                    }
                    if (declutterTree && declutterMode !== "none") {
                      declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                    }
                    for (let i2 = 0, ii2 = replayImageOrLabelArgs.length; i2 < ii2; ++i2) {
                      this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i2]);
                    }
                  }
              }
              ++i;
              break;
            case Instruction_default.END_GEOMETRY:
              if (featureCallback !== void 0) {
                feature = /** @type {import("../../Feature.js").FeatureLike} */
                instruction[1];
                const result = featureCallback(
                  feature,
                  currentGeometry,
                  declutterMode
                );
                if (result) {
                  return result;
                }
              }
              ++i;
              break;
            case Instruction_default.FILL:
              if (batchSize) {
                pendingFill++;
              } else {
                this.fill_(context);
              }
              ++i;
              break;
            case Instruction_default.MOVE_TO_LINE_TO:
              d = /** @type {number} */
              instruction[1];
              dd = /** @type {number} */
              instruction[2];
              x = pixelCoordinates[d];
              y = pixelCoordinates[d + 1];
              context.moveTo(x, y);
              prevX = x + 0.5 | 0;
              prevY = y + 0.5 | 0;
              for (d += 2; d < dd; d += 2) {
                x = pixelCoordinates[d];
                y = pixelCoordinates[d + 1];
                roundX = x + 0.5 | 0;
                roundY = y + 0.5 | 0;
                if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                  context.lineTo(x, y);
                  prevX = roundX;
                  prevY = roundY;
                }
              }
              ++i;
              break;
            case Instruction_default.SET_FILL_STYLE:
              lastFillInstruction = instruction;
              this.alignAndScaleFill_ = instruction[2];
              if (pendingFill) {
                this.fill_(context);
                pendingFill = 0;
                if (pendingStroke) {
                  context.stroke();
                  pendingStroke = 0;
                }
              }
              context.fillStyle = instruction[1];
              ++i;
              break;
            case Instruction_default.SET_STROKE_STYLE:
              lastStrokeInstruction = instruction;
              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
              this.setStrokeStyle_(
                context,
                /** @type {Array<*>} */
                instruction
              );
              ++i;
              break;
            case Instruction_default.STROKE:
              if (batchSize) {
                pendingStroke++;
              } else {
                context.stroke();
              }
              ++i;
              break;
            default:
              ++i;
              break;
          }
        }
        if (pendingFill) {
          this.fill_(context);
        }
        if (pendingStroke) {
          context.stroke();
        }
        return void 0;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       */
      execute(context, scaledCanvasSize, transform2, viewRotation, snapToPixel, declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(
          context,
          scaledCanvasSize,
          transform2,
          this.instructions,
          snapToPixel,
          void 0,
          void 0,
          declutterTree
        );
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {FeatureCallback<T>} [featureCallback] Feature callback.
       * @param {import("../../extent.js").Extent} [hitExtent] Only check
       *     features that intersect this extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      executeHitDetection(context, transform2, viewRotation, featureCallback, hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(
          context,
          [context.canvas.width, context.canvas.height],
          transform2,
          this.hitDetectionInstructions,
          true,
          featureCallback,
          hitExtent
        );
      }
    };
    Executor_default = Executor;
  }
});

// node_modules/ol/render/canvas/ExecutorGroup.js
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i = 0; i <= radius; ++i) {
    for (let j = 0; j <= radius; ++j) {
      const distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance2 = distances[distanceSq];
      if (!distance2) {
        distance2 = [];
        distances[distanceSq] = distance2;
      }
      distance2.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance2.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance2.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance2.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }
  const pixelIndex = [];
  for (let i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push(...distances[i]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
var ALL, DECLUTTER, NON_DECLUTTER, ExecutorGroup, circlePixelIndexArrayCache, ExecutorGroup_default;
var init_ExecutorGroup = __esm({
  "node_modules/ol/render/canvas/ExecutorGroup.js"() {
    init_Executor();
    init_array();
    init_extent();
    init_transform();
    init_dom();
    init_obj();
    init_transform2();
    ALL = [
      "Polygon",
      "Circle",
      "LineString",
      "Image",
      "Text",
      "Default"
    ];
    DECLUTTER = ["Image", "Text"];
    NON_DECLUTTER = ALL.filter(
      (builderType) => !DECLUTTER.includes(builderType)
    );
    ExecutorGroup = class {
      /**
       * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
       * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
       * should be set here, unless the target context does not exceed that extent (which
       * can be the case when rendering to tiles).
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The executor group can have overlapping geometries.
       * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
       * The serializable instructions.
       * @param {number} [renderBuffer] Optional rendering buffer.
       * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
       */
      constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer, deferredRendering) {
        this.maxExtent_ = maxExtent;
        this.overlaps_ = overlaps;
        this.pixelRatio_ = pixelRatio;
        this.resolution_ = resolution;
        this.renderBuffer_ = renderBuffer;
        this.executorsByZIndex_ = {};
        this.hitDetectionContext_ = null;
        this.hitDetectionTransform_ = create();
        this.renderedContext_ = null;
        this.deferredZIndexContexts_ = {};
        this.createExecutors_(allInstructions, deferredRendering);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      clip(context, transform2) {
        const flatClipCoords = this.getClipCoords(transform2);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
      }
      /**
       * Create executors and populate them using the provided instructions.
       * @private
       * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
       * @param {boolean} deferredRendering Enable deferred rendering.
       */
      createExecutors_(allInstructions, deferredRendering) {
        for (const zIndex in allInstructions) {
          let executors = this.executorsByZIndex_[zIndex];
          if (executors === void 0) {
            executors = {};
            this.executorsByZIndex_[zIndex] = executors;
          }
          const instructionByZindex = allInstructions[zIndex];
          for (const builderType in instructionByZindex) {
            const instructions = instructionByZindex[builderType];
            executors[builderType] = new Executor_default(
              this.resolution_,
              this.pixelRatio_,
              this.overlaps_,
              instructions,
              deferredRendering
            );
          }
        }
      }
      /**
       * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
       * @return {boolean} Has executors of the provided types.
       */
      hasExecutors(executors) {
        for (const zIndex in this.executorsByZIndex_) {
          const candidates = this.executorsByZIndex_[zIndex];
          for (let i = 0, ii = executors.length; i < ii; ++i) {
            if (executors[i] in candidates) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        const contextSize = hitTolerance * 2 + 1;
        const transform2 = compose(
          this.hitDetectionTransform_,
          hitTolerance + 0.5,
          hitTolerance + 0.5,
          1 / resolution,
          -1 / resolution,
          -rotation,
          -coordinate[0],
          -coordinate[1]
        );
        const newContext = !this.hitDetectionContext_;
        if (newContext) {
          this.hitDetectionContext_ = createCanvasContext2D(
            contextSize,
            contextSize,
            void 0,
            { willReadFrequently: true }
          );
        }
        const context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
          context.canvas.width = contextSize;
          context.canvas.height = contextSize;
        } else if (!newContext) {
          context.clearRect(0, 0, contextSize, contextSize);
        }
        let hitExtent;
        if (this.renderBuffer_ !== void 0) {
          hitExtent = createEmpty();
          extendCoordinate(hitExtent, coordinate);
          buffer(
            hitExtent,
            resolution * (this.renderBuffer_ + hitTolerance),
            hitExtent
          );
        }
        const indexes = getPixelIndexArray(hitTolerance);
        let builderType;
        function featureCallback(feature, geometry, declutterMode) {
          const imageData = context.getImageData(
            0,
            0,
            contextSize,
            contextSize
          ).data;
          for (let i2 = 0, ii = indexes.length; i2 < ii; i2++) {
            if (imageData[indexes[i2]] > 0) {
              if (!declutteredFeatures || declutterMode === "none" || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
                const idx = (indexes[i2] - 3) / 4;
                const x = hitTolerance - idx % contextSize;
                const y = hitTolerance - (idx / contextSize | 0);
                const result2 = callback(feature, geometry, x * x + y * y);
                if (result2) {
                  return result2;
                }
              }
              context.clearRect(0, 0, contextSize, contextSize);
              break;
            }
          }
          return void 0;
        }
        const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(ascending);
        let i, j, executors, executor, result;
        for (i = zs.length - 1; i >= 0; --i) {
          const zIndexKey = zs[i].toString();
          executors = this.executorsByZIndex_[zIndexKey];
          for (j = ALL.length - 1; j >= 0; --j) {
            builderType = ALL[j];
            executor = executors[builderType];
            if (executor !== void 0) {
              result = executor.executeHitDetection(
                context,
                transform2,
                rotation,
                featureCallback,
                hitExtent
              );
              if (result) {
                return result;
              }
            }
          }
        }
        return void 0;
      }
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       * @return {Array<number>|null} Clip coordinates.
       */
      getClipCoords(transform2) {
        const maxExtent = this.maxExtent_;
        if (!maxExtent) {
          return null;
        }
        const minX = maxExtent[0];
        const minY = maxExtent[1];
        const maxX = maxExtent[2];
        const maxY = maxExtent[3];
        const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
        transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
        return flatClipCoords;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return isEmpty(this.executorsByZIndex_);
      }
      /**
       * @param {CanvasRenderingContext2D} targetContext Context.
       * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
       * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
       *     Default is {@link module:ol/render/replay~ALL}
       * @param {import("rbush").default|null} [declutterTree] Declutter tree.
       *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
       */
      execute(targetContext, scaledCanvasSize, transform2, viewRotation, snapToPixel, builderTypes, declutterTree) {
        const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(ascending);
        builderTypes = builderTypes ? builderTypes : ALL;
        const maxBuilderTypes = ALL.length;
        let i, ii, j, jj, replays;
        if (declutterTree) {
          zs.reverse();
        }
        for (i = 0, ii = zs.length; i < ii; ++i) {
          const zIndexKey = zs[i].toString();
          replays = this.executorsByZIndex_[zIndexKey];
          for (j = 0, jj = builderTypes.length; j < jj; ++j) {
            const builderType = builderTypes[j];
            const replay = replays[builderType];
            if (replay !== void 0) {
              const zIndexContext = declutterTree === null ? void 0 : replay.getZIndexContext();
              const context = zIndexContext ? zIndexContext.getContext() : targetContext;
              const requireClip = this.maxExtent_ && builderType !== "Image" && builderType !== "Text";
              if (requireClip) {
                context.save();
                this.clip(context, transform2);
              }
              if (!zIndexContext || builderType === "Text" || builderType === "Image") {
                replay.execute(
                  context,
                  scaledCanvasSize,
                  transform2,
                  viewRotation,
                  snapToPixel,
                  declutterTree
                );
              } else {
                zIndexContext.pushFunction(
                  (context2) => replay.execute(
                    context2,
                    scaledCanvasSize,
                    transform2,
                    viewRotation,
                    snapToPixel,
                    declutterTree
                  )
                );
              }
              if (requireClip) {
                context.restore();
              }
              if (zIndexContext) {
                zIndexContext.offset();
                const index = zs[i] * maxBuilderTypes + j;
                if (!this.deferredZIndexContexts_[index]) {
                  this.deferredZIndexContexts_[index] = [];
                }
                this.deferredZIndexContexts_[index].push(zIndexContext);
              }
            }
          }
        }
        this.renderedContext_ = targetContext;
      }
      getDeferredZIndexContexts() {
        return this.deferredZIndexContexts_;
      }
      getRenderedContext() {
        return this.renderedContext_;
      }
      renderDeferred() {
        const deferredZIndexContexts = this.deferredZIndexContexts_;
        const zs = Object.keys(deferredZIndexContexts).map(Number).sort(ascending);
        for (let i = 0, ii = zs.length; i < ii; ++i) {
          deferredZIndexContexts[zs[i]].forEach((zIndexContext) => {
            zIndexContext.draw(this.renderedContext_);
            zIndexContext.clear();
          });
          deferredZIndexContexts[zs[i]].length = 0;
        }
      }
    };
    circlePixelIndexArrayCache = {};
    ExecutorGroup_default = ExecutorGroup;
  }
});

// node_modules/ol/render/canvas/Immediate.js
var CanvasImmediateRenderer, Immediate_default;
var init_Immediate = __esm({
  "node_modules/ol/render/canvas/Immediate.js"() {
    init_VectorContext();
    init_colorlike();
    init_transform();
    init_canvas();
    init_array();
    init_extent();
    init_math();
    init_transform2();
    init_SimpleGeometry();
    CanvasImmediateRenderer = class extends VectorContext_default {
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
       * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
       */
      constructor(context, pixelRatio, extent, transform2, viewRotation, squaredTolerance, userTransform) {
        super();
        this.context_ = context;
        this.pixelRatio_ = pixelRatio;
        this.extent_ = extent;
        this.transform_ = transform2;
        this.transformRotation_ = transform2 ? toFixed(Math.atan2(transform2[1], transform2[0]), 10) : 0;
        this.viewRotation_ = viewRotation;
        this.squaredTolerance_ = squaredTolerance;
        this.userTransform_ = userTransform;
        this.contextFillState_ = null;
        this.contextStrokeState_ = null;
        this.contextTextState_ = null;
        this.fillState_ = null;
        this.strokeState_ = null;
        this.image_ = null;
        this.imageAnchorX_ = 0;
        this.imageAnchorY_ = 0;
        this.imageHeight_ = 0;
        this.imageOpacity_ = 0;
        this.imageOriginX_ = 0;
        this.imageOriginY_ = 0;
        this.imageRotateWithView_ = false;
        this.imageRotation_ = 0;
        this.imageScale_ = [0, 0];
        this.imageWidth_ = 0;
        this.text_ = "";
        this.textOffsetX_ = 0;
        this.textOffsetY_ = 0;
        this.textRotateWithView_ = false;
        this.textRotation_ = 0;
        this.textScale_ = [0, 0];
        this.textFillState_ = null;
        this.textStrokeState_ = null;
        this.textState_ = null;
        this.pixelCoordinates_ = [];
        this.tmpLocalTransform_ = create();
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      drawImages_(flatCoordinates, offset2, end, stride) {
        if (!this.image_) {
          return;
        }
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset2,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        const context = this.context_;
        const localTransform = this.tmpLocalTransform_;
        const alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha * this.imageOpacity_;
        }
        let rotation = this.imageRotation_;
        if (this.transformRotation_ === 0) {
          rotation -= this.viewRotation_;
        }
        if (this.imageRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (let i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
          const x = pixelCoordinates[i] - this.imageAnchorX_;
          const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
          if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
            const centerX = x + this.imageAnchorX_;
            const centerY = y + this.imageAnchorY_;
            compose(
              localTransform,
              centerX,
              centerY,
              1,
              1,
              rotation,
              -centerX,
              -centerY
            );
            context.save();
            context.transform.apply(context, localTransform);
            context.translate(centerX, centerY);
            context.scale(this.imageScale_[0], this.imageScale_[1]);
            context.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              -this.imageAnchorX_,
              -this.imageAnchorY_,
              this.imageWidth_,
              this.imageHeight_
            );
            context.restore();
          } else {
            context.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              x,
              y,
              this.imageWidth_,
              this.imageHeight_
            );
          }
        }
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha;
        }
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      drawText_(flatCoordinates, offset2, end, stride) {
        if (!this.textState_ || this.text_ === "") {
          return;
        }
        if (this.textFillState_) {
          this.setContextFillState_(this.textFillState_);
        }
        if (this.textStrokeState_) {
          this.setContextStrokeState_(this.textStrokeState_);
        }
        this.setContextTextState_(this.textState_);
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset2,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        const context = this.context_;
        let rotation = this.textRotation_;
        if (this.transformRotation_ === 0) {
          rotation -= this.viewRotation_;
        }
        if (this.textRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (; offset2 < end; offset2 += stride) {
          const x = pixelCoordinates[offset2] + this.textOffsetX_;
          const y = pixelCoordinates[offset2 + 1] + this.textOffsetY_;
          if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
            context.save();
            context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
            context.rotate(rotation);
            context.translate(this.textOffsetX_, this.textOffsetY_);
            context.scale(this.textScale_[0], this.textScale_[1]);
            if (this.textStrokeState_) {
              context.strokeText(this.text_, 0, 0);
            }
            if (this.textFillState_) {
              context.fillText(this.text_, 0, 0);
            }
            context.restore();
          } else {
            if (this.textStrokeState_) {
              context.strokeText(this.text_, x, y);
            }
            if (this.textFillState_) {
              context.fillText(this.text_, x, y);
            }
          }
        }
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} close Close.
       * @private
       * @return {number} end End.
       */
      moveToLineTo_(flatCoordinates, offset2, end, stride, close) {
        const context = this.context_;
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset2,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        let length = pixelCoordinates.length;
        if (close) {
          length -= 2;
        }
        for (let i = 2; i < length; i += 2) {
          context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        }
        if (close) {
          context.closePath();
        }
        return end;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      drawRings_(flatCoordinates, offset2, ends, stride) {
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          offset2 = this.moveToLineTo_(
            flatCoordinates,
            offset2,
            ends[i],
            stride,
            true
          );
        }
        return offset2;
      }
      /**
       * Render a circle geometry into the canvas.  Rendering is immediate and uses
       * the current fill and stroke styles.
       *
       * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
       * @api
       */
      drawCircle(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Circle.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.fillState_ || this.strokeState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const pixelCoordinates = transformGeom2D(
            geometry,
            this.transform_,
            this.pixelCoordinates_
          );
          const dx = pixelCoordinates[2] - pixelCoordinates[0];
          const dy = pixelCoordinates[3] - pixelCoordinates[1];
          const radius = Math.sqrt(dx * dx + dy * dy);
          const context = this.context_;
          context.beginPath();
          context.arc(
            pixelCoordinates[0],
            pixelCoordinates[1],
            radius,
            0,
            2 * Math.PI
          );
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          this.drawText_(geometry.getCenter(), 0, 2, 2);
        }
      }
      /**
       * Set the rendering style.  Note that since this is an immediate rendering API,
       * any `zIndex` on the provided style will be ignored.
       *
       * @param {import("../../style/Style.js").default} style The rendering style.
       * @api
       */
      setStyle(style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
      }
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      setTransform(transform2) {
        this.transform_ = transform2;
      }
      /**
       * Render a geometry into the canvas.  Call
       * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
       *
       * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
       * @api
       */
      drawGeometry(geometry) {
        const type = geometry.getType();
        switch (type) {
          case "Point":
            this.drawPoint(
              /** @type {import("../../geom/Point.js").default} */
              geometry
            );
            break;
          case "LineString":
            this.drawLineString(
              /** @type {import("../../geom/LineString.js").default} */
              geometry
            );
            break;
          case "Polygon":
            this.drawPolygon(
              /** @type {import("../../geom/Polygon.js").default} */
              geometry
            );
            break;
          case "MultiPoint":
            this.drawMultiPoint(
              /** @type {import("../../geom/MultiPoint.js").default} */
              geometry
            );
            break;
          case "MultiLineString":
            this.drawMultiLineString(
              /** @type {import("../../geom/MultiLineString.js").default} */
              geometry
            );
            break;
          case "MultiPolygon":
            this.drawMultiPolygon(
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry
            );
            break;
          case "GeometryCollection":
            this.drawGeometryCollection(
              /** @type {import("../../geom/GeometryCollection.js").default} */
              geometry
            );
            break;
          case "Circle":
            this.drawCircle(
              /** @type {import("../../geom/Circle.js").default} */
              geometry
            );
            break;
          default:
        }
      }
      /**
       * Render a feature into the canvas.  Note that any `zIndex` on the provided
       * style will be ignored - features are rendered immediately in the order that
       * this method is called.  If you need `zIndex` support, you should be using an
       * {@link module:ol/layer/Vector~VectorLayer} instead.
       *
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {import("../../style/Style.js").default} style Style.
       * @api
       */
      drawFeature(feature, style) {
        const geometry = style.getGeometryFunction()(feature);
        if (!geometry) {
          return;
        }
        this.setStyle(style);
        this.drawGeometry(geometry);
      }
      /**
       * Render a GeometryCollection to the canvas.  Rendering is immediate and
       * uses the current styles appropriate for each geometry in the collection.
       *
       * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
       */
      drawGeometryCollection(geometry) {
        const geometries = geometry.getGeometriesArray();
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          this.drawGeometry(geometries[i]);
        }
      }
      /**
       * Render a Point geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
       */
      drawPoint(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Point.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== "") {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      }
      /**
       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
       * uses the current style.
       *
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
       */
      drawMultiPoint(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiPoint.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== "") {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      }
      /**
       * Render a LineString into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
       */
      drawLineString(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/LineString.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          context.beginPath();
          this.moveToLineTo_(
            flatCoordinates,
            0,
            flatCoordinates.length,
            geometry.getStride(),
            false
          );
          context.stroke();
        }
        if (this.text_ !== "") {
          const flatMidpoint = geometry.getFlatMidpoint();
          this.drawText_(flatMidpoint, 0, 2, 2);
        }
      }
      /**
       * Render a MultiLineString geometry into the canvas.  Rendering is immediate
       * and uses the current style.
       *
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
       */
      drawMultiLineString(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const geometryExtent = geometry.getExtent();
        if (!intersects(this.extent_, geometryExtent)) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          let offset2 = 0;
          const ends = (
            /** @type {Array<number>} */
            geometry.getEnds()
          );
          const stride = geometry.getStride();
          context.beginPath();
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            offset2 = this.moveToLineTo_(
              flatCoordinates,
              offset2,
              ends[i],
              stride,
              false
            );
          }
          context.stroke();
        }
        if (this.text_ !== "") {
          const flatMidpoints = geometry.getFlatMidpoints();
          this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
      }
      /**
       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
       */
      drawPolygon(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Polygon.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const context = this.context_;
          context.beginPath();
          this.drawRings_(
            geometry.getOrientedFlatCoordinates(),
            0,
            /** @type {Array<number>} */
            geometry.getEnds(),
            geometry.getStride()
          );
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          const flatInteriorPoint = geometry.getFlatInteriorPoint();
          this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
      }
      /**
       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
       * uses the current style.
       * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
       */
      drawMultiPolygon(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const context = this.context_;
          const flatCoordinates = geometry.getOrientedFlatCoordinates();
          let offset2 = 0;
          const endss = geometry.getEndss();
          const stride = geometry.getStride();
          context.beginPath();
          for (let i = 0, ii = endss.length; i < ii; ++i) {
            const ends = endss[i];
            offset2 = this.drawRings_(flatCoordinates, offset2, ends, stride);
          }
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          const flatInteriorPoints = geometry.getFlatInteriorPoints();
          this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
      }
      /**
       * @param {import("../canvas.js").FillState} fillState Fill state.
       * @private
       */
      setContextFillState_(fillState) {
        const context = this.context_;
        const contextFillState = this.contextFillState_;
        if (!contextFillState) {
          context.fillStyle = fillState.fillStyle;
          this.contextFillState_ = {
            fillStyle: fillState.fillStyle
          };
        } else {
          if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = fillState.fillStyle;
            context.fillStyle = fillState.fillStyle;
          }
        }
      }
      /**
       * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
       * @private
       */
      setContextStrokeState_(strokeState) {
        const context = this.context_;
        const contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
          context.lineCap = strokeState.lineCap;
          context.setLineDash(strokeState.lineDash);
          context.lineDashOffset = strokeState.lineDashOffset;
          context.lineJoin = strokeState.lineJoin;
          context.lineWidth = strokeState.lineWidth;
          context.miterLimit = strokeState.miterLimit;
          context.strokeStyle = strokeState.strokeStyle;
          this.contextStrokeState_ = {
            lineCap: strokeState.lineCap,
            lineDash: strokeState.lineDash,
            lineDashOffset: strokeState.lineDashOffset,
            lineJoin: strokeState.lineJoin,
            lineWidth: strokeState.lineWidth,
            miterLimit: strokeState.miterLimit,
            strokeStyle: strokeState.strokeStyle
          };
        } else {
          if (contextStrokeState.lineCap != strokeState.lineCap) {
            contextStrokeState.lineCap = strokeState.lineCap;
            context.lineCap = strokeState.lineCap;
          }
          if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
            context.setLineDash(
              contextStrokeState.lineDash = strokeState.lineDash
            );
          }
          if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
            contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
            context.lineDashOffset = strokeState.lineDashOffset;
          }
          if (contextStrokeState.lineJoin != strokeState.lineJoin) {
            contextStrokeState.lineJoin = strokeState.lineJoin;
            context.lineJoin = strokeState.lineJoin;
          }
          if (contextStrokeState.lineWidth != strokeState.lineWidth) {
            contextStrokeState.lineWidth = strokeState.lineWidth;
            context.lineWidth = strokeState.lineWidth;
          }
          if (contextStrokeState.miterLimit != strokeState.miterLimit) {
            contextStrokeState.miterLimit = strokeState.miterLimit;
            context.miterLimit = strokeState.miterLimit;
          }
          if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
            contextStrokeState.strokeStyle = strokeState.strokeStyle;
            context.strokeStyle = strokeState.strokeStyle;
          }
        }
      }
      /**
       * @param {import("../canvas.js").TextState} textState Text state.
       * @private
       */
      setContextTextState_(textState) {
        const context = this.context_;
        const contextTextState = this.contextTextState_;
        const textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
        if (!contextTextState) {
          context.font = textState.font;
          context.textAlign = textAlign;
          context.textBaseline = textState.textBaseline;
          this.contextTextState_ = {
            font: textState.font,
            textAlign,
            textBaseline: textState.textBaseline
          };
        } else {
          if (contextTextState.font != textState.font) {
            contextTextState.font = textState.font;
            context.font = textState.font;
          }
          if (contextTextState.textAlign != textAlign) {
            contextTextState.textAlign = textAlign;
            context.textAlign = textAlign;
          }
          if (contextTextState.textBaseline != textState.textBaseline) {
            contextTextState.textBaseline = textState.textBaseline;
            context.textBaseline = textState.textBaseline;
          }
        }
      }
      /**
       * Set the fill and stroke style for subsequent draw operations.  To clear
       * either fill or stroke styles, pass null for the appropriate parameter.
       *
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
        if (!fillStyle) {
          this.fillState_ = null;
        } else {
          const fillStyleColor = fillStyle.getColor();
          this.fillState_ = {
            fillStyle: asColorLike(
              fillStyleColor ? fillStyleColor : defaultFillStyle
            )
          };
        }
        if (!strokeStyle) {
          this.strokeState_ = null;
        } else {
          const strokeStyleColor = strokeStyle.getColor();
          const strokeStyleLineCap = strokeStyle.getLineCap();
          const strokeStyleLineDash = strokeStyle.getLineDash();
          const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          const strokeStyleLineJoin = strokeStyle.getLineJoin();
          const strokeStyleWidth = strokeStyle.getWidth();
          const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          const lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
          this.strokeState_ = {
            lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
            lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n) => n * this.pixelRatio_),
            lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
            lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
            lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
            miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
            strokeStyle: asColorLike(
              strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
            )
          };
        }
      }
      /**
       * Set the image style for subsequent draw operations.  Pass null to remove
       * the image style.
       *
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       */
      setImageStyle(imageStyle) {
        let imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
          this.image_ = null;
          return;
        }
        const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
        const imageAnchor = imageStyle.getAnchor();
        const imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
        this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
        this.imageHeight_ = imageSize[1] * imagePixelRatio;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        const imageScale = imageStyle.getScaleArray();
        this.imageScale_ = [
          imageScale[0] * this.pixelRatio_ / imagePixelRatio,
          imageScale[1] * this.pixelRatio_ / imagePixelRatio
        ];
        this.imageWidth_ = imageSize[0] * imagePixelRatio;
      }
      /**
       * Set the text style for subsequent draw operations.  Pass null to
       * remove the text style.
       *
       * @param {import("../../style/Text.js").default} textStyle Text style.
       */
      setTextStyle(textStyle) {
        if (!textStyle) {
          this.text_ = "";
        } else {
          const textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            this.textFillState_ = null;
          } else {
            const textFillStyleColor = textFillStyle.getColor();
            this.textFillState_ = {
              fillStyle: asColorLike(
                textFillStyleColor ? textFillStyleColor : defaultFillStyle
              )
            };
          }
          const textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            this.textStrokeState_ = null;
          } else {
            const textStrokeStyleColor = textStrokeStyle.getColor();
            const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
            const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
            const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
            const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
            const textStrokeStyleWidth = textStrokeStyle.getWidth();
            const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
            this.textStrokeState_ = {
              lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
              lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
              lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
              lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
              lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
              miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
              strokeStyle: asColorLike(
                textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle
              )
            };
          }
          const textFont = textStyle.getFont();
          const textOffsetX = textStyle.getOffsetX();
          const textOffsetY = textStyle.getOffsetY();
          const textRotateWithView = textStyle.getRotateWithView();
          const textRotation = textStyle.getRotation();
          const textScale = textStyle.getScaleArray();
          const textText = textStyle.getText();
          const textTextAlign = textStyle.getTextAlign();
          const textTextBaseline = textStyle.getTextBaseline();
          this.textState_ = {
            font: textFont !== void 0 ? textFont : defaultFont,
            textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
            textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
          };
          this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce((acc, t, i) => acc += i % 2 ? " " : t, "") : textText : "";
          this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
          this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
          this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
          this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
          this.textScale_ = [
            this.pixelRatio_ * textScale[0],
            this.pixelRatio_ * textScale[1]
          ];
        }
      }
    };
    Immediate_default = CanvasImmediateRenderer;
  }
});

// node_modules/ol/style.js
var init_style2 = __esm({
  "node_modules/ol/style.js"() {
    init_Circle();
    init_Fill();
    init_Icon();
    init_IconImage();
    init_Image();
    init_RegularShape();
    init_Stroke();
    init_Style();
    init_Text();
  }
});

// node_modules/ol/render/canvas/hitdetect.js
function createHitDetectionImageData(size, transforms2, features, styleFunction, extent, resolution, rotation, squaredTolerance, projection) {
  const userExtent = projection ? toUserExtent(extent, projection) : extent;
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context = createCanvasContext2D(width, height);
  context.imageSmoothingEnabled = false;
  const canvas = context.canvas;
  const renderer = new Immediate_default(
    context,
    HIT_DETECT_RESOLUTION,
    extent,
    null,
    rotation,
    squaredTolerance,
    projection ? getTransformFromProjections(getUserProjection(), projection) : null
  );
  const featureCount = features.length;
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i = 1; i <= featureCount; ++i) {
    const feature = features[i - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!featureStyleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index = i * indexFactor;
    const color = index.toString(16).padStart(7, "#00000");
    for (let j = 0, jj = styles.length; j < jj; ++j) {
      const originalStyle = styles[j];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !intersects(userExtent, geometry.getExtent())) {
        continue;
      }
      const style = originalStyle.clone();
      const fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      const stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(void 0);
      const image = originalStyle.getImage();
      if (image) {
        const imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }
        const imgContext = createCanvasContext2D(
          imgSize[0],
          imgSize[1],
          void 0,
          { alpha: false }
        );
        const img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(
          new Icon_default({
            img,
            anchor: image.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: image.getOrigin(),
            opacity: 1,
            size: image.getSize(),
            scale: image.getScale(),
            rotation: image.getRotation(),
            rotateWithView: image.getRotateWithView()
          })
        );
      }
      const zIndex = style.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType["Polygon"] = [];
        byGeometryType["Circle"] = [];
        byGeometryType["LineString"] = [];
        byGeometryType["Point"] = [];
      }
      const type = geometry.getType();
      if (type === "GeometryCollection") {
        const geometries = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          geometry.getGeometriesArrayRecursive()
        );
        for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
          const geometry2 = geometries[i2];
          byGeometryType[geometry2.getType().replace("Multi", "")].push(
            geometry2,
            style
          );
        }
      } else {
        byGeometryType[type.replace("Multi", "")].push(geometry, style);
      }
    }
  }
  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ascending);
  for (let i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);
        for (let k = 0, kk = transforms2.length; k < kk; ++k) {
          renderer.setTransform(transforms2[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    const index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
    const r = imageData.data[index];
    const g = imageData.data[index + 1];
    const b = imageData.data[index + 2];
    const i = b + 256 * (g + 256 * r);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }
  return resultFeatures;
}
var HIT_DETECT_RESOLUTION;
var init_hitdetect = __esm({
  "node_modules/ol/render/canvas/hitdetect.js"() {
    init_Immediate();
    init_style2();
    init_array();
    init_math();
    init_dom();
    init_proj();
    init_extent();
    HIT_DETECT_RESOLUTION = 0.5;
  }
});

// node_modules/ol/renderer/vector.js
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style, feature, index) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform2, declutter, index) {
  const loadingPromises = [];
  const imageStyle = style.getImage();
  if (imageStyle) {
    let loading2 = true;
    const imageState = imageStyle.getImageState();
    if (imageState == ImageState_default.LOADED || imageState == ImageState_default.ERROR) {
      loading2 = false;
    } else {
      if (imageState == ImageState_default.IDLE) {
        imageStyle.load();
      }
    }
    if (loading2) {
      loadingPromises.push(imageStyle.ready());
    }
  }
  const fillStyle = style.getFill();
  if (fillStyle && fillStyle.loading()) {
    loadingPromises.push(fillStyle.ready());
  }
  const loading = loadingPromises.length > 0;
  if (loading) {
    Promise.all(loadingPromises).then(() => listener(null));
  }
  renderFeatureInternal(
    replayGroup,
    feature,
    style,
    squaredTolerance,
    transform2,
    declutter,
    index
  );
  return loading;
}
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform2, declutter, index) {
  const geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(
    squaredTolerance,
    transform2
  );
  const renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature, index);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(
      replayGroup,
      simplifiedGeometry,
      style,
      feature,
      index,
      declutter
    );
  }
}
function renderGeometry(replayGroup, geometry, style, feature, index) {
  if (geometry.getType() == "GeometryCollection") {
    const geometries = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      geometry.getGeometries()
    );
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature, index);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style.getZIndex(), "Default");
  replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    geometry,
    feature,
    style.getRenderer(),
    style.getHitDetectionRenderer(),
    index
  );
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup, index) {
  const geometries = geometry.getGeometriesArray();
  let i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(
      replayGroup,
      geometries[i],
      style,
      feature,
      declutterBuilderGroup,
      index
    );
  }
}
function renderLineStringGeometry(builderGroup, geometry, style, feature, index) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, index) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, index) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderPointGeometry(builderGroup, geometry, style, feature, index, declutter) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  const hasText = textStyle && textStyle.getText();
  const declutterImageWithText = declutter && imageStyle && hasText ? {} : void 0;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature, index);
  }
  if (hasText) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style, feature, index, declutter) {
  const imageStyle = style.getImage();
  const hasImage = imageStyle && imageStyle.getOpacity() !== 0;
  const textStyle = style.getText();
  const hasText = textStyle && textStyle.getText();
  const declutterImageWithText = declutter && hasImage && hasText ? {} : void 0;
  if (hasImage) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature, index);
  }
  if (hasText) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature, index);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style, feature, index) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature, index);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = builderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature, index);
  }
}
var SIMPLIFY_TOLERANCE, GEOMETRY_RENDERERS;
var init_vector = __esm({
  "node_modules/ol/renderer/vector.js"() {
    init_ImageState();
    init_util();
    SIMPLIFY_TOLERANCE = 0.5;
    GEOMETRY_RENDERERS = {
      "Point": renderPointGeometry,
      "LineString": renderLineStringGeometry,
      "Polygon": renderPolygonGeometry,
      "MultiPoint": renderMultiPointGeometry,
      "MultiLineString": renderMultiLineStringGeometry,
      "MultiPolygon": renderMultiPolygonGeometry,
      "GeometryCollection": renderGeometryCollectionGeometry,
      "Circle": renderCircleGeometry
    };
  }
});

// node_modules/ol/renderer/canvas/VectorLayer.js
var CanvasVectorLayerRenderer, VectorLayer_default;
var init_VectorLayer = __esm({
  "node_modules/ol/renderer/canvas/VectorLayer.js"() {
    init_BuilderGroup();
    init_Layer3();
    init_ExecutorGroup();
    init_EventType2();
    init_ViewHint();
    init_hitdetect();
    init_extent();
    init_dom();
    init_vector();
    init_array();
    init_proj();
    init_util();
    init_coordinate();
    CanvasVectorLayerRenderer = class extends Layer_default3 {
      /**
       * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
       */
      constructor(vectorLayer) {
        super(vectorLayer);
        this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        this.animatingOrInteracting_;
        this.hitDetectionImageData_ = null;
        this.clipped_ = false;
        this.renderedFeatures_ = null;
        this.renderedRevision_ = -1;
        this.renderedResolution_ = NaN;
        this.renderedExtent_ = createEmpty();
        this.wrappedRenderedExtent_ = createEmpty();
        this.renderedRotation_;
        this.renderedCenter_ = null;
        this.renderedProjection_ = null;
        this.renderedPixelRatio_ = 1;
        this.renderedRenderOrder_ = null;
        this.renderedFrameDeclutter_;
        this.replayGroup_ = null;
        this.replayGroupChanged = true;
        this.clipping = true;
        this.targetContext_ = null;
        this.opacity_ = 1;
      }
      /**
       * @param {ExecutorGroup} executorGroup Executor group.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {boolean} [declutterable] `true` to only render declutterable items,
       *     `false` to only render non-declutterable items, `undefined` to render all.
       */
      renderWorlds(executorGroup, frameState, declutterable) {
        const extent = frameState.extent;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const rotation = viewState.rotation;
        const projectionExtent = projection.getExtent();
        const vectorSource = this.getLayer().getSource();
        const declutter = this.getLayer().getDeclutter();
        const pixelRatio = frameState.pixelRatio;
        const viewHints = frameState.viewHints;
        const snapToPixel = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
        const context = this.context;
        const width = Math.round(getWidth(extent) / resolution * pixelRatio);
        const height = Math.round(getHeight(extent) / resolution * pixelRatio);
        const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
        const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
          let transform2 = this.getRenderTransform(
            center,
            resolution,
            0,
            pixelRatio,
            width,
            height,
            world * worldWidth
          );
          if (frameState.declutter) {
            transform2 = transform2.slice(0);
          }
          executorGroup.execute(
            context,
            [context.canvas.width, context.canvas.height],
            transform2,
            rotation,
            snapToPixel,
            declutterable === void 0 ? ALL : declutterable ? DECLUTTER : NON_DECLUTTER,
            declutterable ? declutter && frameState.declutter[declutter] : void 0
          );
        } while (++world < endWorld);
      }
      /**
       * @private
       */
      setDrawContext_() {
        if (this.opacity_ !== 1) {
          this.targetContext_ = this.context;
          this.context = createCanvasContext2D(
            this.context.canvas.width,
            this.context.canvas.height,
            canvasPool2
          );
        }
      }
      /**
       * @private
       */
      resetDrawContext_() {
        if (this.opacity_ !== 1) {
          const alpha = this.targetContext_.globalAlpha;
          this.targetContext_.globalAlpha = this.opacity_;
          this.targetContext_.drawImage(this.context.canvas, 0, 0);
          this.targetContext_.globalAlpha = alpha;
          releaseCanvas(this.context);
          canvasPool2.push(this.context.canvas);
          this.context = this.targetContext_;
          this.targetContext_ = null;
        }
      }
      /**
       * Render declutter items for this layer
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeclutter(frameState) {
        if (!this.replayGroup_ || !this.getLayer().getDeclutter()) {
          return;
        }
        this.renderWorlds(this.replayGroup_, frameState, true);
      }
      /**
       * Render deferred instructions.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeferredInternal(frameState) {
        if (!this.replayGroup_) {
          return;
        }
        this.replayGroup_.renderDeferred();
        if (this.clipped_) {
          this.context.restore();
        }
        this.resetDrawContext_();
      }
      /**
       * Render the layer.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement|null} The rendered element.
       */
      renderFrame(frameState, target) {
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        this.opacity_ = layerState.opacity;
        const viewState = frameState.viewState;
        this.prepareContainer(frameState, target);
        const context = this.context;
        const replayGroup = this.replayGroup_;
        let render2 = replayGroup && !replayGroup.isEmpty();
        if (!render2) {
          const hasRenderListeners = this.getLayer().hasListener(EventType_default2.PRERENDER) || this.getLayer().hasListener(EventType_default2.POSTRENDER);
          if (!hasRenderListeners) {
            return null;
          }
        }
        this.setDrawContext_();
        this.preRender(context, frameState);
        const projection = viewState.projection;
        this.clipped_ = false;
        if (render2 && layerState.extent && this.clipping) {
          const layerExtent = fromUserExtent(layerState.extent, projection);
          render2 = intersects(layerExtent, frameState.extent);
          this.clipped_ = render2 && !containsExtent(layerExtent, frameState.extent);
          if (this.clipped_) {
            this.clipUnrotated(context, frameState, layerExtent);
          }
        }
        if (render2) {
          this.renderWorlds(
            replayGroup,
            frameState,
            this.getLayer().getDeclutter() ? false : void 0
          );
        }
        if (!frameState.declutter && this.clipped_) {
          context.restore();
        }
        this.postRender(context, frameState);
        if (this.renderedRotation_ !== viewState.rotation) {
          this.renderedRotation_ = viewState.rotation;
          this.hitDetectionImageData_ = null;
        }
        if (!frameState.declutter) {
          this.resetDrawContext_();
        }
        return this.container;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../../Feature").default>>} Promise
       * that resolves with an array of features.
       */
      getFeatures(pixel) {
        return new Promise((resolve) => {
          if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
            const size = this.frameState.size.slice();
            const center = this.renderedCenter_;
            const resolution = this.renderedResolution_;
            const rotation = this.renderedRotation_;
            const projection = this.renderedProjection_;
            const extent = this.wrappedRenderedExtent_;
            const layer = this.getLayer();
            const transforms2 = [];
            const width = size[0] * HIT_DETECT_RESOLUTION;
            const height = size[1] * HIT_DETECT_RESOLUTION;
            transforms2.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                HIT_DETECT_RESOLUTION,
                width,
                height,
                0
              ).slice()
            );
            const source = layer.getSource();
            const projectionExtent = projection.getExtent();
            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
              let startX = extent[0];
              const worldWidth = getWidth(projectionExtent);
              let world = 0;
              let offsetX;
              while (startX < projectionExtent[0]) {
                --world;
                offsetX = worldWidth * world;
                transforms2.push(
                  this.getRenderTransform(
                    center,
                    resolution,
                    rotation,
                    HIT_DETECT_RESOLUTION,
                    width,
                    height,
                    offsetX
                  ).slice()
                );
                startX += worldWidth;
              }
              world = 0;
              startX = extent[2];
              while (startX > projectionExtent[2]) {
                ++world;
                offsetX = worldWidth * world;
                transforms2.push(
                  this.getRenderTransform(
                    center,
                    resolution,
                    rotation,
                    HIT_DETECT_RESOLUTION,
                    width,
                    height,
                    offsetX
                  ).slice()
                );
                startX -= worldWidth;
              }
            }
            const userProjection2 = getUserProjection();
            this.hitDetectionImageData_ = createHitDetectionImageData(
              size,
              transforms2,
              this.renderedFeatures_,
              layer.getStyleFunction(),
              extent,
              resolution,
              rotation,
              getSquaredTolerance(resolution, this.renderedPixelRatio_),
              userProjection2 ? projection : null
            );
          }
          resolve(
            hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
          );
        });
      }
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        if (!this.replayGroup_) {
          return void 0;
        }
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const layer = this.getLayer();
        const features = {};
        const featureCallback = function(feature, geometry, distanceSq) {
          const key = getUid(feature);
          const match = features[key];
          if (!match) {
            if (distanceSq === 0) {
              features[key] = true;
              return callback(feature, layer, geometry);
            }
            matches.push(
              features[key] = {
                feature,
                layer,
                geometry,
                distanceSq,
                callback
              }
            );
          } else if (match !== true && distanceSq < match.distanceSq) {
            if (distanceSq === 0) {
              features[key] = true;
              matches.splice(matches.lastIndexOf(match), 1);
              return callback(feature, layer, geometry);
            }
            match.geometry = geometry;
            match.distanceSq = distanceSq;
          }
          return void 0;
        };
        let result;
        const executorGroups = [this.replayGroup_];
        const declutter = this.getLayer().getDeclutter();
        executorGroups.some((executorGroup) => {
          return result = executorGroup.forEachFeatureAtCoordinate(
            coordinate,
            resolution,
            rotation,
            hitTolerance,
            featureCallback,
            declutter && frameState.declutter[declutter] ? frameState.declutter[declutter].all().map((item) => item.value) : null
          );
        });
        return result;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       */
      handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) {
          layer.changed();
        }
      }
      /**
       * Handle changes in image style state.
       * @param {import("../../events/Event.js").default} event Image style change event.
       * @private
       */
      handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
      }
      /**
       * Determine whether render should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        const vectorLayer = this.getLayer();
        const vectorSource = vectorLayer.getSource();
        if (!vectorSource) {
          return false;
        }
        const animating = frameState.viewHints[ViewHint_default.ANIMATING];
        const interacting = frameState.viewHints[ViewHint_default.INTERACTING];
        const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
          this.animatingOrInteracting_ = true;
          return true;
        }
        this.animatingOrInteracting_ = false;
        const frameStateExtent = frameState.extent;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const resolution = viewState.resolution;
        const pixelRatio = frameState.pixelRatio;
        const vectorLayerRevision = vectorLayer.getRevision();
        const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === void 0) {
          vectorLayerRenderOrder = defaultOrder;
        }
        const center = viewState.center.slice();
        const extent = buffer(
          frameStateExtent,
          vectorLayerRenderBuffer * resolution
        );
        const renderedExtent = extent.slice();
        const loadExtents = [extent.slice()];
        const projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
          const worldWidth = getWidth(projectionExtent);
          const gutter = Math.max(getWidth(extent) / 2, worldWidth);
          extent[0] = projectionExtent[0] - gutter;
          extent[2] = projectionExtent[2] + gutter;
          wrapX2(center, projection);
          const loadExtent = wrapX(loadExtents[0], projection);
          if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
            loadExtents.push([
              loadExtent[0] + worldWidth,
              loadExtent[1],
              loadExtent[2] + worldWidth,
              loadExtent[3]
            ]);
          } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
            loadExtents.push([
              loadExtent[0] - worldWidth,
              loadExtent[1],
              loadExtent[2] - worldWidth,
              loadExtent[3]
            ]);
          }
        }
        if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && this.renderedFrameDeclutter_ === !!frameState.declutter && containsExtent(this.wrappedRenderedExtent_, extent)) {
          if (!equals(this.renderedExtent_, renderedExtent)) {
            this.hitDetectionImageData_ = null;
            this.renderedExtent_ = renderedExtent;
          }
          this.renderedCenter_ = center;
          this.replayGroupChanged = false;
          return true;
        }
        this.replayGroup_ = null;
        const replayGroup = new BuilderGroup_default(
          getTolerance(resolution, pixelRatio),
          extent,
          resolution,
          pixelRatio
        );
        const userProjection2 = getUserProjection();
        let userTransform;
        if (userProjection2) {
          for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
            const extent2 = loadExtents[i];
            const userExtent2 = toUserExtent(extent2, projection);
            vectorSource.loadFeatures(
              userExtent2,
              toUserResolution(resolution, projection),
              userProjection2
            );
          }
          userTransform = getTransformFromProjections(userProjection2, projection);
        } else {
          for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
            vectorSource.loadFeatures(loadExtents[i], resolution, projection);
          }
        }
        const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
        let ready = true;
        const render2 = (
          /**
           * @param {import("../../Feature.js").default} feature Feature.
           * @param {number} index Index.
           */
          (feature, index) => {
            let styles;
            const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) {
              styles = styleFunction(feature, resolution);
            }
            if (styles) {
              const dirty = this.renderFeature(
                feature,
                squaredTolerance,
                styles,
                replayGroup,
                userTransform,
                this.getLayer().getDeclutter(),
                index
              );
              ready = ready && !dirty;
            }
          }
        );
        const userExtent = toUserExtent(extent, projection);
        const features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) {
          features.sort(vectorLayerRenderOrder);
        }
        for (let i = 0, ii = features.length; i < ii; ++i) {
          render2(features[i], i);
        }
        this.renderedFeatures_ = features;
        this.ready = ready;
        const replayGroupInstructions = replayGroup.finish();
        const executorGroup = new ExecutorGroup_default(
          extent,
          resolution,
          pixelRatio,
          vectorSource.getOverlaps(),
          replayGroupInstructions,
          vectorLayer.getRenderBuffer(),
          !!frameState.declutter
        );
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedFrameDeclutter_ = !!frameState.declutter;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.renderedPixelRatio_ = pixelRatio;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
      }
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} squaredTolerance Squared render tolerance.
       * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
       * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
       * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
       * @param {boolean} [declutter] Enable decluttering.
       * @param {number} [index] Render order index.
       * @return {boolean} `true` if an image is loading.
       */
      renderFeature(feature, squaredTolerance, styles, builderGroup, transform2, declutter, index) {
        if (!styles) {
          return false;
        }
        let loading = false;
        if (Array.isArray(styles)) {
          for (let i = 0, ii = styles.length; i < ii; ++i) {
            loading = renderFeature(
              builderGroup,
              feature,
              styles[i],
              squaredTolerance,
              this.boundHandleStyleImageChange_,
              transform2,
              declutter,
              index
            ) || loading;
          }
        } else {
          loading = renderFeature(
            builderGroup,
            feature,
            styles,
            squaredTolerance,
            this.boundHandleStyleImageChange_,
            transform2,
            declutter,
            index
          );
        }
        return loading;
      }
    };
    VectorLayer_default = CanvasVectorLayerRenderer;
  }
});

// node_modules/ol/layer/Vector.js
var Vector_exports = {};
__export(Vector_exports, {
  default: () => Vector_default
});
var VectorLayer, Vector_default;
var init_Vector = __esm({
  "node_modules/ol/layer/Vector.js"() {
    init_BaseVector();
    init_VectorLayer();
    VectorLayer = class extends BaseVector_default {
      /**
       * @param {Options<FeatureType>} [options] Options.
       */
      constructor(options) {
        super(options);
      }
      createRenderer() {
        return new VectorLayer_default(this);
      }
    };
    Vector_default = VectorLayer;
  }
});

// node_modules/ol/structs/RBush.js
var RBush2, RBush_default;
var init_RBush = __esm({
  "node_modules/ol/structs/RBush.js"() {
    init_rbush();
    init_extent();
    init_util();
    init_obj();
    RBush2 = class {
      /**
       * @param {number} [maxEntries] Max entries.
       */
      constructor(maxEntries) {
        this.rbush_ = new RBush(maxEntries);
        this.items_ = {};
      }
      /**
       * Insert a value into the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      insert(extent, value) {
        const item = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3],
          value
        };
        this.rbush_.insert(item);
        this.items_[getUid(value)] = item;
      }
      /**
       * Bulk-insert values into the RBush.
       * @param {Array<import("../extent.js").Extent>} extents Extents.
       * @param {Array<T>} values Values.
       */
      load(extents, values) {
        const items = new Array(values.length);
        for (let i = 0, l = values.length; i < l; i++) {
          const extent = extents[i];
          const value = values[i];
          const item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value
          };
          items[i] = item;
          this.items_[getUid(value)] = item;
        }
        this.rbush_.load(items);
      }
      /**
       * Remove a value from the RBush.
       * @param {T} value Value.
       * @return {boolean} Removed.
       */
      remove(value) {
        const uid = getUid(value);
        const item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
      }
      /**
       * Update the extent of a value in the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      update(extent, value) {
        const item = this.items_[getUid(value)];
        const bbox2 = [item.minX, item.minY, item.maxX, item.maxY];
        if (!equals2(bbox2, extent)) {
          this.remove(value);
          this.insert(extent, value);
        }
      }
      /**
       * Return all values in the RBush.
       * @return {Array<T>} All.
       */
      getAll() {
        const items = this.rbush_.all();
        return items.map(function(item) {
          return item.value;
        });
      }
      /**
       * Return all values in the given extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {Array<T>} All in extent.
       */
      getInExtent(extent) {
        const bbox2 = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3]
        };
        const items = this.rbush_.search(bbox2);
        return items.map(function(item) {
          return item.value;
        });
      }
      /**
       * Calls a callback function with each value in the tree.
       * If the callback returns a truthy value, this value is returned without
       * checking the rest of the tree.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      forEach(callback) {
        return this.forEach_(this.getAll(), callback);
      }
      /**
       * Calls a callback function with each value in the provided extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      forEachInExtent(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
      }
      /**
       * @param {Array<T>} values Values.
       * @param {function(T): *} callback Callback.
       * @private
       * @return {*} Callback return value.
       */
      forEach_(values, callback) {
        let result;
        for (let i = 0, l = values.length; i < l; i++) {
          result = callback(values[i]);
          if (result) {
            return result;
          }
        }
        return result;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return isEmpty(this.items_);
      }
      /**
       * Remove all values from the RBush.
       */
      clear() {
        this.rbush_.clear();
        this.items_ = {};
      }
      /**
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} Extent.
       */
      getExtent(extent) {
        const data = this.rbush_.toJSON();
        return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);
      }
      /**
       * @param {RBush} rbush R-Tree.
       */
      concat(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for (const i in rbush.items_) {
          this.items_[i] = rbush.items_[i];
        }
      }
    };
    RBush_default = RBush2;
  }
});

// node_modules/ol/geom/Circle.js
var Circle, Circle_default2;
var init_Circle2 = __esm({
  "node_modules/ol/geom/Circle.js"() {
    init_SimpleGeometry();
    init_extent();
    init_deflate();
    init_transform2();
    Circle = class _Circle extends SimpleGeometry_default {
      /**
       * @param {!import("../coordinate.js").Coordinate} center Center.
       *     For internal use, flat coordinates in combination with `layout` and no
       *     `radius` are also accepted.
       * @param {number} [radius] Radius in units of the projection.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(center, radius, layout) {
        super();
        if (layout !== void 0 && radius === void 0) {
          this.setFlatCoordinates(layout, center);
        } else {
          radius = radius ? radius : 0;
          this.setCenterAndRadius(center, radius, layout);
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Circle} Clone.
       * @api
       */
      clone() {
        const circle = new _Circle(
          this.flatCoordinates.slice(),
          void 0,
          this.layout
        );
        circle.applyProperties(this);
        return circle;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x - flatCoordinates[0];
        const dy = y - flatCoordinates[1];
        const squaredDistance3 = dx * dx + dy * dy;
        if (squaredDistance3 < minSquaredDistance) {
          if (squaredDistance3 === 0) {
            for (let i = 0; i < this.stride; ++i) {
              closestPoint[i] = flatCoordinates[i];
            }
          } else {
            const delta = this.getRadius() / Math.sqrt(squaredDistance3);
            closestPoint[0] = flatCoordinates[0] + delta * dx;
            closestPoint[1] = flatCoordinates[1] + delta * dy;
            for (let i = 2; i < this.stride; ++i) {
              closestPoint[i] = flatCoordinates[i];
            }
          }
          closestPoint.length = this.stride;
          return squaredDistance3;
        }
        return minSquaredDistance;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x - flatCoordinates[0];
        const dy = y - flatCoordinates[1];
        return dx * dx + dy * dy <= this.getRadiusSquared_();
      }
      /**
       * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @return {import("../coordinate.js").Coordinate} Center.
       * @api
       */
      getCenter() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const radius = flatCoordinates[this.stride] - flatCoordinates[0];
        return createOrUpdate(
          flatCoordinates[0] - radius,
          flatCoordinates[1] - radius,
          flatCoordinates[0] + radius,
          flatCoordinates[1] + radius,
          extent
        );
      }
      /**
       * Return the radius of the circle.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return Math.sqrt(this.getRadiusSquared_());
      }
      /**
       * @private
       * @return {number} Radius squared.
       */
      getRadiusSquared_() {
        const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
        const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return dx * dx + dy * dy;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "Circle";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        const circleExtent = this.getExtent();
        if (intersects(extent, circleExtent)) {
          const center = this.getCenter();
          if (extent[0] <= center[0] && extent[2] >= center[0]) {
            return true;
          }
          if (extent[1] <= center[1] && extent[3] >= center[1]) {
            return true;
          }
          return forEachCorner(extent, this.intersectsCoordinate.bind(this));
        }
        return false;
      }
      /**
       * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} center Center.
       * @api
       */
      setCenter(center) {
        const stride = this.stride;
        const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
        const flatCoordinates = center.slice();
        flatCoordinates[stride] = flatCoordinates[0] + radius;
        for (let i = 1; i < stride; ++i) {
          flatCoordinates[stride + i] = center[i];
        }
        this.setFlatCoordinates(this.layout, flatCoordinates);
        this.changed();
      }
      /**
       * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
       * number) of the circle.
       * @param {!import("../coordinate.js").Coordinate} center Center.
       * @param {number} radius Radius.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCenterAndRadius(center, radius, layout) {
        this.setLayout(layout, center, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const flatCoordinates = this.flatCoordinates;
        let offset2 = deflateCoordinate(flatCoordinates, 0, center, this.stride);
        flatCoordinates[offset2++] = flatCoordinates[0] + radius;
        for (let i = 1, ii = this.stride; i < ii; ++i) {
          flatCoordinates[offset2++] = flatCoordinates[i];
        }
        flatCoordinates.length = offset2;
        this.changed();
      }
      getCoordinates() {
        return null;
      }
      setCoordinates(coordinates2, layout) {
      }
      /**
       * Set the radius of the circle. The radius is in the units of the projection.
       * @param {number} radius Radius.
       * @api
       */
      setRadius(radius) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
        this.changed();
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        const center = this.getCenter();
        const stride = this.getStride();
        this.setCenter(
          rotate3(center, 0, center.length, stride, angle, anchor, center)
        );
        this.changed();
      }
    };
    Circle.prototype.transform;
    Circle_default2 = Circle;
  }
});

// node_modules/ol/geom/GeometryCollection.js
var init_GeometryCollection = __esm({
  "node_modules/ol/geom/GeometryCollection.js"() {
  }
});

// node_modules/ol/geom/MultiLineString.js
var MultiLineString, MultiLineString_default;
var init_MultiLineString = __esm({
  "node_modules/ol/geom/MultiLineString.js"() {
    init_LineString();
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_simplify();
    init_array();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    MultiLineString = class _MultiLineString extends SimpleGeometry_default {
      /**
       * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
       *     Coordinates or LineString geometries. (For internal use, flat coordinates in
       *     combination with `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Flat coordinate ends for internal use.
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates2[0])) {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        } else if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          const lineStrings = (
            /** @type {Array<LineString>} */
            coordinates2
          );
          const flatCoordinates = [];
          const ends2 = [];
          for (let i = 0, ii = lineStrings.length; i < ii; ++i) {
            const lineString = lineStrings[i];
            extend(flatCoordinates, lineString.getFlatCoordinates());
            ends2.push(flatCoordinates.length);
          }
          const layout2 = lineStrings.length === 0 ? this.getLayout() : lineStrings[0].getLayout();
          this.setFlatCoordinates(layout2, flatCoordinates);
          this.ends_ = ends2;
        }
      }
      /**
       * Append the passed linestring to the multilinestring.
       * @param {LineString} lineString LineString.
       * @api
       */
      appendLineString(lineString) {
        extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       */
      clone() {
        const multiLineString = new _MultiLineString(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        multiLineString.applyProperties(this);
        return multiLineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          false,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @param {boolean} [interpolate] Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m, extrapolate, interpolate) {
        if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        interpolate = interpolate !== void 0 ? interpolate : false;
        return lineStringsCoordinateAtM(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          m,
          extrapolate,
          interpolate
        );
      }
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinatesArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */
      getLineString(index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }
        return new LineString_default(
          this.flatCoordinates.slice(
            index === 0 ? 0 : this.ends_[index - 1],
            this.ends_[index]
          ),
          this.layout
        );
      }
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */
      getLineStrings() {
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const layout = this.layout;
        const lineStrings = [];
        let offset2 = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const lineString = new LineString_default(
            flatCoordinates.slice(offset2, end),
            layout
          );
          lineStrings.push(lineString);
          offset2 = end;
        }
        return lineStrings;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        const midpoints = [];
        const flatCoordinates = this.flatCoordinates;
        let offset2 = 0;
        const ends = this.ends_;
        const stride = this.stride;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const midpoint = interpolatePoint(
            flatCoordinates,
            offset2,
            end,
            stride,
            0.5
          );
          extend(midpoints, midpoint);
          offset2 = end;
        }
        return midpoints;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = douglasPeuckerArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _MultiLineString(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "MultiLineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLineStringArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    MultiLineString_default = MultiLineString;
  }
});

// node_modules/ol/geom/MultiPoint.js
var MultiPoint, MultiPoint_default;
var init_MultiPoint = __esm({
  "node_modules/ol/geom/MultiPoint.js"() {
    init_Point();
    init_SimpleGeometry();
    init_extent();
    init_deflate();
    init_array();
    init_inflate();
    init_math();
    MultiPoint = class _MultiPoint extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        if (layout && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed point to this multipoint.
       * @param {Point} point Point.
       * @api
       */
      appendPoint(point) {
        extend(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       */
      clone() {
        const multiPoint = new _MultiPoint(
          this.flatCoordinates.slice(),
          this.layout
        );
        multiPoint.applyProperties(this);
        return multiPoint;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const squaredDistance3 = squaredDistance(
            x,
            y,
            flatCoordinates[i],
            flatCoordinates[i + 1]
          );
          if (squaredDistance3 < minSquaredDistance) {
            minSquaredDistance = squaredDistance3;
            for (let j = 0; j < stride; ++j) {
              closestPoint[j] = flatCoordinates[i + j];
            }
            closestPoint.length = stride;
          }
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */
      getPoint(index) {
        const n = this.flatCoordinates.length / this.stride;
        if (index < 0 || n <= index) {
          return null;
        }
        return new Point_default(
          this.flatCoordinates.slice(
            index * this.stride,
            (index + 1) * this.stride
          ),
          this.layout
        );
      }
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */
      getPoints() {
        const flatCoordinates = this.flatCoordinates;
        const layout = this.layout;
        const stride = this.stride;
        const points = [];
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const point = new Point_default(flatCoordinates.slice(i, i + stride), layout);
          points.push(point);
        }
        return points;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "MultiPoint";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const x = flatCoordinates[i];
          const y = flatCoordinates[i + 1];
          if (containsXY(extent, x, y)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    MultiPoint_default = MultiPoint;
  }
});

// node_modules/ol/geom/flat/center.js
function linearRingss2(flatCoordinates, offset2, endss, stride) {
  const flatCenters = [];
  let extent = createEmpty();
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    extent = createOrUpdateFromFlatCoordinates(
      flatCoordinates,
      offset2,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset2 = ends[ends.length - 1];
  }
  return flatCenters;
}
var init_center = __esm({
  "node_modules/ol/geom/flat/center.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/MultiPolygon.js
var MultiPolygon, MultiPolygon_default;
var init_MultiPolygon = __esm({
  "node_modules/ol/geom/MultiPolygon.js"() {
    init_MultiPoint();
    init_Polygon();
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_array();
    init_interiorpoint();
    init_inflate();
    init_intersectsextent();
    init_orient();
    init_area();
    init_center();
    init_contains();
    init_simplify();
    MultiPolygon = class _MultiPolygon extends SimpleGeometry_default {
      /**
       * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
       */
      constructor(coordinates2, layout, endss) {
        super();
        this.endss_ = [];
        this.flatInteriorPointsRevision_ = -1;
        this.flatInteriorPoints_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (!endss && !Array.isArray(coordinates2[0])) {
          const polygons = (
            /** @type {Array<Polygon>} */
            coordinates2
          );
          const flatCoordinates = [];
          const thisEndss = [];
          for (let i = 0, ii = polygons.length; i < ii; ++i) {
            const polygon = polygons[i];
            const offset2 = flatCoordinates.length;
            const ends = polygon.getEnds();
            for (let j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] += offset2;
            }
            extend(flatCoordinates, polygon.getFlatCoordinates());
            thisEndss.push(ends);
          }
          layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();
          coordinates2 = flatCoordinates;
          endss = thisEndss;
        }
        if (layout !== void 0 && endss) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.endss_ = endss;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed polygon to this multipolygon.
       * @param {Polygon} polygon Polygon.
       * @api
       */
      appendPolygon(polygon) {
        let ends;
        if (!this.flatCoordinates) {
          this.flatCoordinates = polygon.getFlatCoordinates().slice();
          ends = polygon.getEnds().slice();
          this.endss_.push();
        } else {
          const offset2 = this.flatCoordinates.length;
          extend(this.flatCoordinates, polygon.getFlatCoordinates());
          ends = polygon.getEnds().slice();
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] += offset2;
          }
        }
        this.endss_.push(ends);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       */
      clone() {
        const len = this.endss_.length;
        const newEndss = new Array(len);
        for (let i = 0; i < len; ++i) {
          newEndss[i] = this.endss_[i].slice();
        }
        const multiPolygon = new _MultiPolygon(
          this.flatCoordinates.slice(),
          this.layout,
          newEndss
        );
        multiPolygon.applyProperties(this);
        return multiPolygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            multiArrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.endss_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestMultiArrayPoint(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        return linearRingssContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          x,
          y
        );
      }
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRingss(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRingsArray(
            flatCoordinates,
            0,
            this.endss_,
            this.stride,
            right
          );
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateMultiCoordinatesArray(
          flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * @return {Array<Array<number>>} Endss.
       */
      getEndss() {
        return this.endss_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
          const flatCenters = linearRingss2(
            this.flatCoordinates,
            0,
            this.endss_,
            this.stride
          );
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.endss_,
            this.stride,
            flatCenters
          );
          this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatInteriorPoints_
        );
      }
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoints() {
        return new MultiPoint_default(this.getFlatInteriorPoints().slice(), "XYM");
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRingsArray(
              this.orientedFlatCoordinates_,
              0,
              this.endss_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEndss = [];
        simplifiedFlatCoordinates.length = quantizeMultiArray(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEndss
        );
        return new _MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
      }
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */
      getPolygon(index) {
        if (index < 0 || this.endss_.length <= index) {
          return null;
        }
        let offset2;
        if (index === 0) {
          offset2 = 0;
        } else {
          const prevEnds = this.endss_[index - 1];
          offset2 = prevEnds[prevEnds.length - 1];
        }
        const ends = this.endss_[index].slice();
        const end = ends[ends.length - 1];
        if (offset2 !== 0) {
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] -= offset2;
          }
        }
        return new Polygon_default(
          this.flatCoordinates.slice(offset2, end),
          this.layout,
          ends
        );
      }
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */
      getPolygons() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const endss = this.endss_;
        const polygons = [];
        let offset2 = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          const ends = endss[i].slice();
          const end = ends[ends.length - 1];
          if (offset2 !== 0) {
            for (let j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] -= offset2;
            }
          }
          const polygon = new Polygon_default(
            flatCoordinates.slice(offset2, end),
            layout,
            ends
          );
          polygons.push(polygon);
          offset2 = end;
        }
        return polygons;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "MultiPolygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLinearRingMultiArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 3);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const endss = deflateMultiCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.endss_
        );
        if (endss.length === 0) {
          this.flatCoordinates.length = 0;
        } else {
          const lastEnds = endss[endss.length - 1];
          this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
      }
    };
    MultiPolygon_default = MultiPolygon;
  }
});

// node_modules/ol/geom.js
var init_geom = __esm({
  "node_modules/ol/geom.js"() {
    init_Circle2();
    init_Geometry();
    init_GeometryCollection();
    init_LinearRing();
    init_LineString();
    init_MultiLineString();
    init_MultiPoint();
    init_MultiPolygon();
    init_Point();
    init_Polygon();
    init_SimpleGeometry();
  }
});

// node_modules/ol/render/Feature.js
function toGeometry(renderFeature2) {
  const geometryType = renderFeature2.getType();
  switch (geometryType) {
    case "Point":
      return new Point_default(renderFeature2.getFlatCoordinates());
    case "MultiPoint":
      return new MultiPoint_default(renderFeature2.getFlatCoordinates(), "XY");
    case "LineString":
      return new LineString_default(renderFeature2.getFlatCoordinates(), "XY");
    case "MultiLineString":
      return new MultiLineString_default(
        renderFeature2.getFlatCoordinates(),
        "XY",
        /** @type {Array<number>} */
        renderFeature2.getEnds()
      );
    case "Polygon":
      const flatCoordinates = renderFeature2.getFlatCoordinates();
      const ends = renderFeature2.getEnds();
      const endss = inflateEnds(flatCoordinates, ends);
      return endss.length > 1 ? new MultiPolygon_default(flatCoordinates, "XY", endss) : new Polygon_default(flatCoordinates, "XY", ends);
    default:
      throw new Error("Invalid geometry type:" + geometryType);
  }
}
function toFeature(renderFeature2, geometryName) {
  const id = renderFeature2.getId();
  const geometry = toGeometry(renderFeature2);
  const properties = renderFeature2.getProperties();
  const feature = new Feature_default();
  if (geometryName !== void 0) {
    feature.setGeometryName(geometryName);
  }
  feature.setGeometry(geometry);
  if (id !== void 0) {
    feature.setId(id);
  }
  feature.setProperties(properties, true);
  return feature;
}
var tmpTransform2, RenderFeature, Feature_default2;
var init_Feature2 = __esm({
  "node_modules/ol/render/Feature.js"() {
    init_Feature();
    init_geom();
    init_transform();
    init_extent();
    init_simplify();
    init_array();
    init_interiorpoint();
    init_proj();
    init_orient();
    init_interpolate();
    init_center();
    init_functions();
    init_transform2();
    tmpTransform2 = create();
    RenderFeature = class _RenderFeature {
      /**
       * @param {Type} type Geometry type.
       * @param {Array<number>} flatCoordinates Flat coordinates. These always need
       *     to be right-handed for polygons.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Object<string, *>} properties Properties.
       * @param {number|string|undefined} id Feature id.
       */
      constructor(type, flatCoordinates, ends, stride, properties, id) {
        this.styleFunction;
        this.extent_;
        this.id_ = id;
        this.type_ = type;
        this.flatCoordinates_ = flatCoordinates;
        this.flatInteriorPoints_ = null;
        this.flatMidpoints_ = null;
        this.ends_ = ends || null;
        this.properties_ = properties;
        this.squaredTolerance_;
        this.stride_ = stride;
        this.simplifiedGeometry_;
      }
      /**
       * Get a feature property by its key.
       * @param {string} key Key
       * @return {*} Value for the requested key.
       * @api
       */
      get(key) {
        return this.properties_[key];
      }
      /**
       * Get the extent of this feature's geometry.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        if (!this.extent_) {
          this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2
          );
        }
        return this.extent_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoints_ = getInteriorPointOfArray(
            this.flatCoordinates_,
            0,
            this.ends_,
            2,
            flatCenter,
            0
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
          const ends = inflateEnds(this.flatCoordinates_, this.ends_);
          const flatCenters = linearRingss2(this.flatCoordinates_, 0, ends, 2);
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.flatCoordinates_,
            0,
            ends,
            2,
            flatCenters
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = interpolatePoint(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            0.5
          );
        }
        return this.flatMidpoints_;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = [];
          const flatCoordinates = this.flatCoordinates_;
          let offset2 = 0;
          const ends = (
            /** @type {Array<number>} */
            this.ends_
          );
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            const end = ends[i];
            const midpoint = interpolatePoint(flatCoordinates, offset2, end, 2, 0.5);
            extend(this.flatMidpoints_, midpoint);
            offset2 = end;
          }
        }
        return this.flatMidpoints_;
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is set when reading data from a remote source.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
      }
      /**
       * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
       * determining the geometry type in style function (see {@link #getType}).
       * @return {RenderFeature} Feature.
       * @api
       */
      getGeometry() {
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {RenderFeature} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {RenderFeature} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform2) {
        return this;
      }
      /**
       * Get the feature properties.
       * @return {Object<string, *>} Feature properties.
       * @api
       */
      getProperties() {
        return this.properties_;
      }
      /**
       * Get an object of all property names and values.  This has the same behavior as getProperties,
       * but is here to conform with the {@link module:ol/Feature~Feature} interface.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.properties_;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride_;
      }
      /**
       * @return {import('../style/Style.js').StyleFunction|undefined} Style
       */
      getStyleFunction() {
        return this.styleFunction;
      }
      /**
       * Get the type of this feature's geometry.
       * @return {Type} Geometry type.
       * @api
       */
      getType() {
        return this.type_;
      }
      /**
       * Transform geometry coordinates from tile pixel space to projected.
       *
       * @param {import("../proj.js").ProjectionLike} projection The data projection
       */
      transform(projection) {
        projection = get3(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
          const scale5 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform2,
            projectedExtent[0],
            projectedExtent[3],
            scale5,
            -scale5,
            0,
            0,
            0
          );
          transform2D(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            tmpTransform2,
            this.flatCoordinates_
          );
        }
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       */
      applyTransform(transformFn) {
        transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
      }
      /**
       * @return {RenderFeature} A cloned render feature.
       */
      clone() {
        return new _RenderFeature(
          this.type_,
          this.flatCoordinates_.slice(),
          this.ends_?.slice(),
          this.stride_,
          Object.assign({}, this.properties_),
          this.id_
        );
      }
      /**
       * @return {Array<number>|null} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Add transform and resolution based geometry simplification to this instance.
       * @return {RenderFeature} This render feature.
       */
      enableSimplifyTransformed() {
        this.simplifyTransformed = memoizeOne((squaredTolerance, transform2) => {
          if (squaredTolerance === this.squaredTolerance_) {
            return this.simplifiedGeometry_;
          }
          this.simplifiedGeometry_ = this.clone();
          if (transform2) {
            this.simplifiedGeometry_.applyTransform(transform2);
          }
          const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
          let simplifiedEnds;
          switch (this.type_) {
            case "LineString":
              simplifiedFlatCoordinates.length = douglasPeucker(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.flatCoordinates_.length,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0
              );
              simplifiedEnds = [simplifiedFlatCoordinates.length];
              break;
            case "MultiLineString":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = douglasPeuckerArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            case "Polygon":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = quantizeArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                Math.sqrt(squaredTolerance),
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            default:
          }
          if (simplifiedEnds) {
            this.simplifiedGeometry_ = new _RenderFeature(
              this.type_,
              simplifiedFlatCoordinates,
              simplifiedEnds,
              2,
              this.properties_,
              this.id_
            );
          }
          this.squaredTolerance_ = squaredTolerance;
          return this.simplifiedGeometry_;
        });
        return this;
      }
    };
    RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
    Feature_default2 = RenderFeature;
  }
});

// node_modules/ol/source/VectorEventType.js
var VectorEventType_default;
var init_VectorEventType = __esm({
  "node_modules/ol/source/VectorEventType.js"() {
    VectorEventType_default = {
      /**
       * Triggered when a feature is added to the source.
       * @event module:ol/source/Vector.VectorSourceEvent#addfeature
       * @api
       */
      ADDFEATURE: "addfeature",
      /**
       * Triggered when a feature is updated.
       * @event module:ol/source/Vector.VectorSourceEvent#changefeature
       * @api
       */
      CHANGEFEATURE: "changefeature",
      /**
       * Triggered when the clear method is called on the source.
       * @event module:ol/source/Vector.VectorSourceEvent#clear
       * @api
       */
      CLEAR: "clear",
      /**
       * Triggered when a feature is removed from the source.
       * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
       * @event module:ol/source/Vector.VectorSourceEvent#removefeature
       * @api
       */
      REMOVEFEATURE: "removefeature",
      /**
       * Triggered when features starts loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
       * @api
       */
      FEATURESLOADSTART: "featuresloadstart",
      /**
       * Triggered when features finishes loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
       * @api
       */
      FEATURESLOADEND: "featuresloadend",
      /**
       * Triggered if feature loading results in an error.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
       * @api
       */
      FEATURESLOADERROR: "featuresloaderror"
    };
  }
});

// node_modules/ol/loadingstrategy.js
function all2(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
function bbox(extent, resolution) {
  return [extent];
}
function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function(extent, resolution, projection) {
      const z = tileGrid.getZForResolution(
        fromUserResolution(resolution, projection)
      );
      const tileRange = tileGrid.getTileRangeForExtentAndZ(
        fromUserExtent(extent, projection),
        z
      );
      const extents = [];
      const tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(
            toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection)
          );
        }
      }
      return extents;
    }
  );
}
var init_loadingstrategy = __esm({
  "node_modules/ol/loadingstrategy.js"() {
    init_proj();
  }
});

// node_modules/ol/featureloader.js
function loadFeaturesXhr(url, format2, extent, resolution, projection, success, failure) {
  const xhr2 = new XMLHttpRequest();
  xhr2.open(
    "GET",
    typeof url === "function" ? url(extent, resolution, projection) : url,
    true
  );
  if (format2.getType() == "arraybuffer") {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      const type = format2.getType();
      try {
        let source;
        if (type == "text" || type == "json") {
          source = xhr2.responseText;
        } else if (type == "xml") {
          source = xhr2.responseXML || xhr2.responseText;
        } else if (type == "arraybuffer") {
          source = /** @type {ArrayBuffer} */
          xhr2.response;
        }
        if (source) {
          success(
            /** @type {Array<FeatureType>} */
            format2.readFeatures(source, {
              extent,
              featureProjection: projection
            }),
            format2.readProjection(source)
          );
        } else {
          failure();
        }
      } catch {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format2) {
  return function(extent, resolution, projection, success, failure) {
    const source = (
      /** @type {import("./source/Vector").default<FeatureType>} */
      this
    );
    loadFeaturesXhr(
      url,
      format2,
      extent,
      resolution,
      projection,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(features, dataProjection) {
        source.addFeatures(features);
        if (success !== void 0) {
          success(features);
        }
      },
      /* FIXME handle error */
      failure ? failure : VOID
    );
  };
}
function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}
var withCredentials;
var init_featureloader = __esm({
  "node_modules/ol/featureloader.js"() {
    init_functions();
    withCredentials = false;
  }
});

// node_modules/ol/source/Vector.js
var Vector_exports2 = {};
__export(Vector_exports2, {
  VectorSourceEvent: () => VectorSourceEvent,
  default: () => Vector_default2
});
var VectorSourceEvent, VectorSource, Vector_default2;
var init_Vector2 = __esm({
  "node_modules/ol/source/Vector.js"() {
    init_Collection();
    init_CollectionEventType();
    init_Event();
    init_EventType();
    init_ObjectEventType();
    init_RBush();
    init_Feature2();
    init_Source();
    init_VectorEventType();
    init_functions();
    init_loadingstrategy();
    init_asserts();
    init_extent();
    init_array();
    init_util();
    init_obj();
    init_events();
    init_featureloader();
    VectorSourceEvent = class extends Event_default {
      /**
       * @param {string} type Type.
       * @param {FeatureClass} [feature] Feature.
       * @param {Array<FeatureClass>} [features] Features.
       */
      constructor(type, feature, features) {
        super(type);
        this.feature = feature;
        this.features = features;
      }
    };
    VectorSource = class extends Source_default {
      /**
       * @param {Options<FeatureType>} [options] Vector source options.
       */
      constructor(options) {
        options = options || {};
        super({
          attributions: options.attributions,
          interpolate: true,
          projection: void 0,
          state: "ready",
          wrapX: options.wrapX !== void 0 ? options.wrapX : true
        });
        this.on;
        this.once;
        this.un;
        this.loader_ = VOID;
        this.format_ = options.format;
        this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
        this.url_ = options.url;
        if (options.loader !== void 0) {
          this.loader_ = options.loader;
        } else if (this.url_ !== void 0) {
          assert(this.format_, "`format` must be set when `url` is set");
          this.loader_ = xhr(this.url_, this.format_);
        }
        this.strategy_ = options.strategy !== void 0 ? options.strategy : all2;
        const useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
        this.featuresRtree_ = useSpatialIndex ? new RBush_default() : null;
        this.loadedExtentsRtree_ = new RBush_default();
        this.loadingExtentsCount_ = 0;
        this.nullGeometryFeatures_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
        this.featureChangeKeys_ = {};
        this.featuresCollection_ = null;
        let collection;
        let features;
        if (Array.isArray(options.features)) {
          features = options.features;
        } else if (options.features) {
          collection = options.features;
          features = collection.getArray();
        }
        if (!useSpatialIndex && collection === void 0) {
          collection = new Collection_default(features);
        }
        if (features !== void 0) {
          this.addFeaturesInternal(features);
        }
        if (collection !== void 0) {
          this.bindFeaturesCollection_(collection);
        }
      }
      /**
       * Add a single feature to the source.  If you want to add a batch of features
       * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
       * instead. A feature will not be added to the source if feature with
       * the same id is already there. The reason for this behavior is to avoid
       * feature duplication when using bbox or tile loading strategies.
       * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
       * meaning that if a feature with a duplicate id is added in the collection, it will
       * be removed from it right away.
       * @param {FeatureType} feature Feature to add.
       * @api
       */
      addFeature(feature) {
        this.addFeatureInternal(feature);
        this.changed();
      }
      /**
       * Add a feature without firing a `change` event.
       * @param {FeatureType} feature Feature.
       * @protected
       */
      addFeatureInternal(feature) {
        const featureKey = getUid(feature);
        if (!this.addToIndex_(featureKey, feature)) {
          if (this.featuresCollection_) {
            this.featuresCollection_.remove(feature);
          }
          return;
        }
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
          const extent = geometry.getExtent();
          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent, feature);
          }
        } else {
          this.nullGeometryFeatures_[featureKey] = feature;
        }
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.ADDFEATURE, feature)
        );
      }
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {FeatureType} feature The feature.
       * @private
       */
      setupChangeEvents_(featureKey, feature) {
        if (feature instanceof Feature_default2) {
          return;
        }
        this.featureChangeKeys_[featureKey] = [
          listen(feature, EventType_default.CHANGE, this.handleFeatureChange_, this),
          listen(
            feature,
            ObjectEventType_default.PROPERTYCHANGE,
            this.handleFeatureChange_,
            this
          )
        ];
      }
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {FeatureType} feature The feature.
       * @return {boolean} The feature is "valid", in the sense that it is also a
       *     candidate for insertion into the Rtree.
       * @private
       */
      addToIndex_(featureKey, feature) {
        let valid = true;
        if (feature.getId() !== void 0) {
          const id = String(feature.getId());
          if (!(id in this.idIndex_)) {
            this.idIndex_[id] = feature;
          } else if (feature instanceof Feature_default2) {
            const indexedFeature = this.idIndex_[id];
            if (!(indexedFeature instanceof Feature_default2)) {
              valid = false;
            } else {
              if (!Array.isArray(indexedFeature)) {
                this.idIndex_[id] = [indexedFeature, feature];
              } else {
                indexedFeature.push(feature);
              }
            }
          } else {
            valid = false;
          }
        }
        if (valid) {
          assert(
            !(featureKey in this.uidIndex_),
            "The passed `feature` was already added to the source"
          );
          this.uidIndex_[featureKey] = feature;
        }
        return valid;
      }
      /**
       * Add a batch of features to the source.
       * @param {Array<FeatureType>} features Features to add.
       * @api
       */
      addFeatures(features) {
        this.addFeaturesInternal(features);
        this.changed();
      }
      /**
       * Add features without firing a `change` event.
       * @param {Array<FeatureType>} features Features.
       * @protected
       */
      addFeaturesInternal(features) {
        const extents = [];
        const newFeatures = [];
        const geometryFeatures = [];
        for (let i = 0, length = features.length; i < length; i++) {
          const feature = features[i];
          const featureKey = getUid(feature);
          if (this.addToIndex_(featureKey, feature)) {
            newFeatures.push(feature);
          }
        }
        for (let i = 0, length = newFeatures.length; i < length; i++) {
          const feature = newFeatures[i];
          const featureKey = getUid(feature);
          this.setupChangeEvents_(featureKey, feature);
          const geometry = feature.getGeometry();
          if (geometry) {
            const extent = geometry.getExtent();
            extents.push(extent);
            geometryFeatures.push(feature);
          } else {
            this.nullGeometryFeatures_[featureKey] = feature;
          }
        }
        if (this.featuresRtree_) {
          this.featuresRtree_.load(extents, geometryFeatures);
        }
        if (this.hasListener(VectorEventType_default.ADDFEATURE)) {
          for (let i = 0, length = newFeatures.length; i < length; i++) {
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.ADDFEATURE, newFeatures[i])
            );
          }
        }
      }
      /**
       * @param {!Collection<FeatureType>} collection Collection.
       * @private
       */
      bindFeaturesCollection_(collection) {
        let modifyingCollection = false;
        this.addEventListener(
          VectorEventType_default.ADDFEATURE,
          /**
           * @param {VectorSourceEvent<FeatureType>} evt The vector source event
           */
          function(evt) {
            if (!modifyingCollection) {
              modifyingCollection = true;
              collection.push(evt.feature);
              modifyingCollection = false;
            }
          }
        );
        this.addEventListener(
          VectorEventType_default.REMOVEFEATURE,
          /**
           * @param {VectorSourceEvent<FeatureType>} evt The vector source event
           */
          function(evt) {
            if (!modifyingCollection) {
              modifyingCollection = true;
              collection.remove(evt.feature);
              modifyingCollection = false;
            }
          }
        );
        collection.addEventListener(
          CollectionEventType_default.ADD,
          /**
           * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
           */
          (evt) => {
            if (!modifyingCollection) {
              modifyingCollection = true;
              this.addFeature(evt.element);
              modifyingCollection = false;
            }
          }
        );
        collection.addEventListener(
          CollectionEventType_default.REMOVE,
          /**
           * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
           */
          (evt) => {
            if (!modifyingCollection) {
              modifyingCollection = true;
              this.removeFeature(evt.element);
              modifyingCollection = false;
            }
          }
        );
        this.featuresCollection_ = collection;
      }
      /**
       * Remove all features from the source.
       * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
       * @api
       */
      clear(fast) {
        if (fast) {
          for (const featureId in this.featureChangeKeys_) {
            const keys = this.featureChangeKeys_[featureId];
            keys.forEach(unlistenByKey);
          }
          if (!this.featuresCollection_) {
            this.featureChangeKeys_ = {};
            this.idIndex_ = {};
            this.uidIndex_ = {};
          }
        } else {
          if (this.featuresRtree_) {
            const removeAndIgnoreReturn = (feature) => {
              this.removeFeatureInternal(feature);
            };
            this.featuresRtree_.forEach(removeAndIgnoreReturn);
            for (const id in this.nullGeometryFeatures_) {
              this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
            }
          }
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.clear();
        }
        if (this.featuresRtree_) {
          this.featuresRtree_.clear();
        }
        this.nullGeometryFeatures_ = {};
        const clearEvent = new VectorSourceEvent(VectorEventType_default.CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
      }
      /**
       * Iterate through all features on the source, calling the provided callback
       * with each one.  If the callback returns any "truthy" value, iteration will
       * stop and the function will return the same value.
       * Note: this function only iterate through the feature that have a defined geometry.
       *
       * @param {function(FeatureType): T} callback Called with each feature
       *     on the source.  Return a truthy value to stop iteration.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeature(callback) {
        if (this.featuresRtree_) {
          return this.featuresRtree_.forEach(callback);
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.forEach(callback);
        }
      }
      /**
       * Iterate through all features whose geometries contain the provided
       * coordinate, calling the callback with each feature.  If the callback returns
       * a "truthy" value, iteration will stop and the function will return the same
       * value.
       *
       * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
       * called for all features.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(FeatureType): T} callback Called with each feature
       *     whose goemetry contains the provided coordinate.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       */
      forEachFeatureAtCoordinateDirect(coordinate, callback) {
        const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
        return this.forEachFeatureInExtent(extent, function(feature) {
          const geometry = feature.getGeometry();
          if (geometry instanceof Feature_default2 || geometry.intersectsCoordinate(coordinate)) {
            return callback(feature);
          }
          return void 0;
        });
      }
      /**
       * Iterate through all features whose bounding box intersects the provided
       * extent (note that the feature's geometry may not intersect the extent),
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you are interested in features whose geometry intersects an extent, call
       * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
       *
       * When `useSpatialIndex` is set to false, this method will loop through all
       * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(FeatureType): T} callback Called with each feature
       *     whose bounding box intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeatureInExtent(extent, callback) {
        if (this.featuresRtree_) {
          return this.featuresRtree_.forEachInExtent(extent, callback);
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.forEach(callback);
        }
      }
      /**
       * Iterate through all features whose geometry intersects the provided extent,
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you only want to test for bounding box intersection, call the
       * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(FeatureType): T} callback Called with each feature
       *     whose geometry intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeatureIntersectingExtent(extent, callback) {
        return this.forEachFeatureInExtent(
          extent,
          /**
           * @param {FeatureType} feature Feature.
           * @return {T|undefined} The return value from the last call to the callback.
           */
          function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof Feature_default2 || geometry.intersectsExtent(extent)) {
              const result = callback(feature);
              if (result) {
                return result;
              }
            }
          }
        );
      }
      /**
       * Get the features collection associated with this source. Will be `null`
       * unless the source was configured with `useSpatialIndex` set to `false`, or
       * with an {@link module:ol/Collection~Collection} as `features`.
       * @return {Collection<FeatureType>|null} The collection of features.
       * @api
       */
      getFeaturesCollection() {
        return this.featuresCollection_;
      }
      /**
       * Get a snapshot of the features currently on the source in random order. The returned array
       * is a copy, the features are references to the features in the source.
       * @return {Array<FeatureType>} Features.
       * @api
       */
      getFeatures() {
        let features;
        if (this.featuresCollection_) {
          features = this.featuresCollection_.getArray().slice(0);
        } else if (this.featuresRtree_) {
          features = this.featuresRtree_.getAll();
          if (!isEmpty(this.nullGeometryFeatures_)) {
            extend(features, Object.values(this.nullGeometryFeatures_));
          }
        }
        return features;
      }
      /**
       * Get all features whose geometry intersects the provided coordinate.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {Array<import("../Feature.js").default>} Features.
       * @api
       */
      getFeaturesAtCoordinate(coordinate) {
        const features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
          features.push(feature);
        });
        return features;
      }
      /**
       * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
       * all features intersecting the given extent in random order (so it may include
       * features whose geometries do not intersect the extent).
       *
       * When `useSpatialIndex` is set to false, this method will return all
       * features.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {import("../proj/Projection.js").default} [projection] Include features
       * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
       * @return {Array<FeatureType>} Features.
       * @api
       */
      getFeaturesInExtent(extent, projection) {
        if (this.featuresRtree_) {
          const multiWorld = projection && projection.canWrapX() && this.getWrapX();
          if (!multiWorld) {
            return this.featuresRtree_.getInExtent(extent);
          }
          const extents = wrapAndSliceX(extent, projection);
          return [].concat(
            ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
          );
        }
        if (this.featuresCollection_) {
          return this.featuresCollection_.getArray().slice(0);
        }
        return [];
      }
      /**
       * Get the closest feature to the provided coordinate.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false` and the features in this source are of type
       * {@link module:ol/Feature~Feature}.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(FeatureType):boolean} [filter] Feature filter function.
       *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
       *     and it should return a boolean value. By default, no filtering is made.
       * @return {FeatureType} Closest feature.
       * @api
       */
      getClosestFeatureToCoordinate(coordinate, filter) {
        const x = coordinate[0];
        const y = coordinate[1];
        let closestFeature = null;
        const closestPoint = [NaN, NaN];
        let minSquaredDistance = Infinity;
        const extent = [-Infinity, -Infinity, Infinity, Infinity];
        filter = filter ? filter : TRUE;
        this.featuresRtree_.forEachInExtent(
          extent,
          /**
           * @param {FeatureType} feature Feature.
           */
          function(feature) {
            if (filter(feature)) {
              const geometry = feature.getGeometry();
              const previousMinSquaredDistance = minSquaredDistance;
              minSquaredDistance = geometry instanceof Feature_default2 ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
              if (minSquaredDistance < previousMinSquaredDistance) {
                closestFeature = feature;
                const minDistance = Math.sqrt(minSquaredDistance);
                extent[0] = x - minDistance;
                extent[1] = y - minDistance;
                extent[2] = x + minDistance;
                extent[3] = y + minDistance;
              }
            }
          }
        );
        return closestFeature;
      }
      /**
       * Get the extent of the features currently in the source.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false`.
       * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
       *     will be created. Instead, that extent's coordinates will be overwritten.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent(extent) {
        return this.featuresRtree_.getExtent(extent);
      }
      /**
       * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
       * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
       * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
       * `GeometryCollection` member.
       * Note that the index treats string and numeric identifiers as the same.  So
       * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
       *
       * @param {string|number} id Feature identifier.
       * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
       * @api
       */
      getFeatureById(id) {
        const feature = this.idIndex_[id.toString()];
        return feature !== void 0 ? (
          /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
          feature
        ) : null;
      }
      /**
       * Get a feature by its internal unique identifier (using `getUid`).
       *
       * @param {string} uid Feature identifier.
       * @return {FeatureType|null} The feature (or `null` if not found).
       */
      getFeatureByUid(uid) {
        const feature = this.uidIndex_[uid];
        return feature !== void 0 ? feature : null;
      }
      /**
       * Get the format associated with this source.
       *
       * @return {import("../format/Feature.js").default<import('../format/Feature.js').FeatureToFeatureClass<FeatureType>>|undefined} The feature format.
       * @api
       */
      getFormat() {
        return this.format_;
      }
      /**
       * @return {boolean} The source can have overlapping geometries.
       */
      getOverlaps() {
        return this.overlaps_;
      }
      /**
       * Get the url associated with this source.
       *
       * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
       * @api
       */
      getUrl() {
        return this.url_;
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      handleFeatureChange_(event) {
        const feature = (
          /** @type {FeatureType} */
          event.target
        );
        const featureKey = getUid(feature);
        const geometry = feature.getGeometry();
        if (!geometry) {
          if (!(featureKey in this.nullGeometryFeatures_)) {
            if (this.featuresRtree_) {
              this.featuresRtree_.remove(feature);
            }
            this.nullGeometryFeatures_[featureKey] = feature;
          }
        } else {
          const extent = geometry.getExtent();
          if (featureKey in this.nullGeometryFeatures_) {
            delete this.nullGeometryFeatures_[featureKey];
            if (this.featuresRtree_) {
              this.featuresRtree_.insert(extent, feature);
            }
          } else {
            if (this.featuresRtree_) {
              this.featuresRtree_.update(extent, feature);
            }
          }
        }
        const id = feature.getId();
        if (id !== void 0) {
          const sid = id.toString();
          if (this.idIndex_[sid] !== feature) {
            this.removeFromIdIndex_(feature);
            this.idIndex_[sid] = feature;
          }
        } else {
          this.removeFromIdIndex_(feature);
          this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.CHANGEFEATURE, feature)
        );
      }
      /**
       * Returns true if the feature is contained within the source.
       * @param {FeatureType} feature Feature.
       * @return {boolean} Has feature.
       * @api
       */
      hasFeature(feature) {
        const id = feature.getId();
        if (id !== void 0) {
          return id in this.idIndex_;
        }
        return getUid(feature) in this.uidIndex_;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        if (this.featuresRtree_) {
          return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
        }
        if (this.featuresCollection_) {
          return this.featuresCollection_.getLength() === 0;
        }
        return true;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      loadFeatures(extent, resolution, projection) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const extentsToLoad = this.strategy_(extent, resolution, projection);
        for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {
          const extentToLoad = extentsToLoad[i];
          const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
            extentToLoad,
            /**
             * @param {{extent: import("../extent.js").Extent}} object Object.
             * @return {boolean} Contains.
             */
            function(object) {
              return containsExtent(object.extent, extentToLoad);
            }
          );
          if (!alreadyLoaded) {
            ++this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.FEATURESLOADSTART)
            );
            this.loader_.call(
              this,
              extentToLoad,
              resolution,
              projection,
              (features) => {
                --this.loadingExtentsCount_;
                this.dispatchEvent(
                  new VectorSourceEvent(
                    VectorEventType_default.FEATURESLOADEND,
                    void 0,
                    features
                  )
                );
              },
              () => {
                --this.loadingExtentsCount_;
                this.dispatchEvent(
                  new VectorSourceEvent(VectorEventType_default.FEATURESLOADERROR)
                );
              }
            );
            loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
          }
        }
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
      }
      refresh() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        super.refresh();
      }
      /**
       * Remove an extent from the list of loaded extents.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      removeLoadedExtent(extent) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        let obj;
        loadedExtentsRtree.forEachInExtent(extent, function(object) {
          if (equals2(object.extent, extent)) {
            obj = object;
            return true;
          }
        });
        if (obj) {
          loadedExtentsRtree.remove(obj);
        }
      }
      /**
       * Batch remove features from the source.  If you want to remove all features
       * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
       * instead.
       * @param {Array<FeatureType>} features Features to remove.
       * @api
       */
      removeFeatures(features) {
        const removedFeatures = [];
        for (let i = 0, ii = features.length; i < ii; ++i) {
          const feature = features[i];
          const removedFeature = this.removeFeatureInternal(feature);
          if (removedFeature) {
            removedFeatures.push(removedFeature);
          }
        }
        if (removedFeatures.length > 0) {
          this.changed();
        }
      }
      /**
       * Remove a single feature from the source. If you want to batch remove
       * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
       * instead.
       * @param {FeatureType} feature Feature to remove.
       * @api
       */
      removeFeature(feature) {
        if (!feature) {
          return;
        }
        const result = this.removeFeatureInternal(feature);
        if (result) {
          this.changed();
        }
      }
      /**
       * Remove feature without firing a `change` event.
       * @param {FeatureType} feature Feature.
       * @return {FeatureType|undefined} The removed feature
       *     (or undefined if the feature was not found).
       * @protected
       */
      removeFeatureInternal(feature) {
        const featureKey = getUid(feature);
        if (!(featureKey in this.uidIndex_)) {
          return;
        }
        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }
        }
        const featureChangeKeys = this.featureChangeKeys_[featureKey];
        featureChangeKeys?.forEach(unlistenByKey);
        delete this.featureChangeKeys_[featureKey];
        const id = feature.getId();
        if (id !== void 0) {
          const idString = id.toString();
          const indexedFeature = this.idIndex_[idString];
          if (indexedFeature === feature) {
            delete this.idIndex_[idString];
          } else if (Array.isArray(indexedFeature)) {
            indexedFeature.splice(indexedFeature.indexOf(feature), 1);
            if (indexedFeature.length === 1) {
              this.idIndex_[idString] = indexedFeature[0];
            }
          }
        }
        delete this.uidIndex_[featureKey];
        if (this.hasListener(VectorEventType_default.REMOVEFEATURE)) {
          this.dispatchEvent(
            new VectorSourceEvent(VectorEventType_default.REMOVEFEATURE, feature)
          );
        }
        return feature;
      }
      /**
       * Remove a feature from the id index.  Called internally when the feature id
       * may have changed.
       * @param {FeatureType} feature The feature.
       * @return {boolean} Removed the feature from the index.
       * @private
       */
      removeFromIdIndex_(feature) {
        let removed = false;
        for (const id in this.idIndex_) {
          const indexedFeature = this.idIndex_[id];
          if (feature instanceof Feature_default2 && Array.isArray(indexedFeature) && indexedFeature.includes(feature)) {
            indexedFeature.splice(indexedFeature.indexOf(feature), 1);
          } else if (this.idIndex_[id] === feature) {
            delete this.idIndex_[id];
            removed = true;
            break;
          }
        }
        return removed;
      }
      /**
       * Set the new loader of the source. The next render cycle will use the
       * new loader.
       * @param {import("../featureloader.js").FeatureLoader<FeatureType>} loader The loader to set.
       * @api
       */
      setLoader(loader) {
        this.loader_ = loader;
      }
      /**
       * Points the source to a new url. The next render cycle will use the new url.
       * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
       * @api
       */
      setUrl(url) {
        assert(this.format_, "`format` must be set when `url` is set");
        this.url_ = url;
        this.setLoader(xhr(url, this.format_));
      }
    };
    Vector_default2 = VectorSource;
  }
});

// node_modules/ol-geocoder/dist/ol-geocoder.js
var require_ol_geocoder = __commonJS({
  "node_modules/ol-geocoder/dist/ol-geocoder.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t((init_Control(), __toCommonJS(Control_exports)), (init_Style(), __toCommonJS(Style_exports)), (init_Icon(), __toCommonJS(Icon_exports)), (init_Vector(), __toCommonJS(Vector_exports)), (init_Vector2(), __toCommonJS(Vector_exports2)), (init_Point(), __toCommonJS(Point_exports)), (init_Feature(), __toCommonJS(Feature_exports)), (init_proj(), __toCommonJS(proj_exports))) : "function" == typeof define && define.amd ? define(["ol/control/Control", "ol/style/Style", "ol/style/Icon", "ol/layer/Vector", "ol/source/Vector", "ol/geom/Point", "ol/Feature", "ol/proj"], t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Geocoder = t(e.ol.control.Control, e.ol.style.Style, e.ol.style.Icon, e.ol.layer.Vector, e.ol.source.Vector, e.ol.geom.Point, e.ol.Feature, e.ol.proj);
    }(exports, function(e, t, s, r, n, o, a, i) {
      "use strict";
      function l(e2) {
        return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
      }
      function c(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var t2 = /* @__PURE__ */ Object.create(null);
        return e2 && Object.keys(e2).forEach(function(s2) {
          if ("default" !== s2) {
            var r2 = Object.getOwnPropertyDescriptor(e2, s2);
            Object.defineProperty(t2, s2, r2.get ? r2 : { enumerable: true, get: function() {
              return e2[s2];
            } });
          }
        }), t2.default = e2, Object.freeze(t2);
      }
      var d = l(e), u = l(t), p = l(s), h = l(r), m = l(n), g = l(o), y = l(a), f = c(i), b = "gcd-container", v = "gcd-button-control", w = "gcd-input-query", x = "gcd-input-label", $ = "gcd-input-search", k = { namespace: "ol-geocoder", spin: "gcd-pseudo-rotate", hidden: "gcd-hidden", address: "gcd-address", country: "gcd-country", city: "gcd-city", road: "gcd-road", olControl: "ol-control", glass: { container: "gcd-gl-container", control: "gcd-gl-control", button: "gcd-gl-btn", input: "gcd-gl-input", expanded: "gcd-gl-expanded", search: "gcd-gl-search", result: "gcd-gl-result" }, inputText: { container: "gcd-txt-container", control: "gcd-txt-control", label: "gcd-txt-label", input: "gcd-txt-input", search: "gcd-txt-search", icon: "gcd-txt-glass", result: "gcd-txt-result" } }, S = { containerId: b, buttonControlId: v, inputQueryId: w, inputLabelId: x, inputSearchId: $, cssClasses: k };
      const q = Object.freeze({ __proto__: null, containerId: b, buttonControlId: v, inputQueryId: w, inputLabelId: x, inputSearchId: $, cssClasses: k, default: S }), L = "addresschosen", C = "nominatim", j = "reverse", E = "glass-button", T = "text-input", I = "osm", N = "mapquest", P = "photon", A = "bing", R = "opencage", F = { provider: I, label: "", placeholder: "Search for an address", featureStyle: null, targetType: E, lang: "en-US", limit: 5, keepOpen: false, preventDefault: false, preventPanning: false, preventMarker: false, defaultFlyResolution: 10, debug: false };
      function _(e2, t2 = "Assertion failed") {
        if (!e2) {
          if ("undefined" != typeof Error)
            throw new Error(t2);
          throw t2;
        }
      }
      function M(e2) {
        const t2 = function() {
          if ("performance" in window == 0 && (window.performance = {}), "now" in window.performance == 0) {
            let e3 = Date.now();
            performance.timing && performance.timing.navigationStart && (e3 = performance.timing.navigationStart), window.performance.now = () => Date.now() - e3;
          }
          return window.performance.now();
        }().toString(36);
        return e2 ? e2 + t2 : t2;
      }
      function O(e2) {
        return /^\d+$/u.test(e2);
      }
      function D(e2, t2, s2) {
        if (Array.isArray(e2))
          return void e2.forEach((e3) => D(e3, t2));
        const r2 = Array.isArray(t2) ? t2 : t2.split(/\s+/u);
        let n2 = r2.length;
        for (; n2--; )
          Q(e2, r2[n2]) || z(e2, r2[n2], s2);
      }
      function V(e2, t2, s2) {
        if (Array.isArray(e2))
          return void e2.forEach((e3) => V(e3, t2, s2));
        const r2 = Array.isArray(t2) ? t2 : t2.split(/\s+/u);
        let n2 = r2.length;
        for (; n2--; )
          Q(e2, r2[n2]) && H(e2, r2[n2], s2);
      }
      function Q(e2, t2) {
        return e2.classList ? e2.classList.contains(t2) : G(t2).test(e2.className);
      }
      function B(e2, t2) {
        return e2.replace(/\{\s*([\w-]+)\s*\}/gu, (e3, s2) => {
          const r2 = void 0 === t2[s2] ? "" : t2[s2];
          return String(r2).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
        });
      }
      function U(e2, t2) {
        let s2;
        if (Array.isArray(e2)) {
          if (s2 = document.createElement(e2[0]), e2[1].id && (s2.id = e2[1].id), e2[1].classname && (s2.className = e2[1].classname), e2[1].attr) {
            const { attr: t3 } = e2[1];
            if (Array.isArray(t3)) {
              let e3 = -1;
              for (; ++e3 < t3.length; )
                s2.setAttribute(t3[e3].name, t3[e3].value);
            } else
              s2.setAttribute(t3.name, t3.value);
          }
        } else
          s2 = document.createElement(e2);
        s2.innerHTML = t2;
        const r2 = document.createDocumentFragment();
        for (; s2.childNodes[0]; )
          r2.append(s2.childNodes[0]);
        return s2.append(r2), s2;
      }
      function G(e2) {
        return new RegExp(`(^|\\s+) ${e2} (\\s+|$)`, "u");
      }
      function z(e2, t2, s2) {
        e2.classList ? e2.classList.add(t2) : e2.className = `${e2.className} ${t2}`.trim(), s2 && O(s2) && window.setTimeout(() => H(e2, t2), s2);
      }
      function H(e2, t2, s2) {
        e2.classList ? e2.classList.remove(t2) : e2.className = e2.className.replace(G(t2), " ").trim(), s2 && O(s2) && window.setTimeout(() => z(e2, t2), s2);
      }
      const K = q.cssClasses;
      class J {
        constructor(e2) {
          this.options = e2, this.els = this.createControl();
        }
        createControl() {
          let e2, t2, s2;
          return this.options.targetType === T ? (t2 = `${K.namespace} ${K.inputText.container}`, e2 = U(["div", { id: q.containerId, classname: t2 }], J.input), s2 = { container: e2, control: e2.querySelector(`.${K.inputText.control}`), label: e2.querySelector(`.${K.inputText.label}`), input: e2.querySelector(`.${K.inputText.input}`), search: e2.querySelector(`.${K.inputText.search}`), result: e2.querySelector(`.${K.inputText.result}`) }, s2.label.innerHTML = this.options.label) : (t2 = `${K.namespace} ${K.glass.container}`, e2 = U(["div", { id: q.containerId, classname: t2 }], J.glass), s2 = { container: e2, control: e2.querySelector(`.${K.glass.control}`), button: e2.querySelector(`.${K.glass.button}`), input: e2.querySelector(`.${K.glass.input}`), search: e2.querySelector(`.${K.glass.search}`), result: e2.querySelector(`.${K.glass.result}`) }), s2.input.placeholder = this.options.placeholder, s2;
        }
      }
      function W(e2) {
        return new Promise((t2, s2) => {
          const r2 = function(e3, t3) {
            t3 && "object" == typeof t3 && (e3 += (/\?/u.test(e3) ? "&" : "?") + X(t3));
            return e3;
          }(e2.url, e2.data), n2 = { method: "GET", mode: "cors", credentials: "same-origin" };
          e2.jsonp ? function(e3, t3, s3) {
            const { head: r3 } = document, n3 = document.createElement("script"), o2 = `f${Math.round(Math.random() * Date.now())}`;
            n3.setAttribute("src", `${e3 + (e3.indexOf("?") > 0 ? "&" : "?") + t3}=${o2}`), window[o2] = (e4) => {
              window[o2] = void 0, setTimeout(() => r3.removeChild(n3), 0), s3(e4);
            }, r3.append(n3);
          }(r2, e2.callbackName, t2) : fetch(r2, n2).then((e3) => e3.json()).then(t2).catch(s2);
        });
      }
      function X(e2) {
        return Object.keys(e2).reduce((t2, s2) => (t2.push("object" == typeof e2[s2] ? X(e2[s2]) : `${encodeURIComponent(s2)}=${encodeURIComponent(e2[s2])}`), t2), []).join("&");
      }
      J.glass = `
  <div class="${K.glass.control} ${K.olControl}">
    <button type="button" id="${q.buttonControlId}" class="${K.glass.button}"></button>
    <input type="text" id="${q.inputQueryId}" class="${K.glass.input}" autocomplete="off" placeholder="Search ...">
    <a id="${q.inputSearchId}" class="${K.glass.search} ${K.hidden}"></a>
  </div>
  <ul class="${K.glass.result}"></ul>
`, J.input = `
  <div class="${K.inputText.control}">
    <label type="button" id="${q.inputSearchId}" class="${K.inputText.label}"></label>
    <input type="text" id="${q.inputQueryId}" class="${K.inputText.input}" autocomplete="off" placeholder="Search ...">
    <span class="${K.inputText.icon}"></span>
    <button type="button" id="${q.inputSearchId}" class="${K.inputText.search} ${K.hidden}"></button>
  </div>
  <ul class="${K.inputText.result}"></ul>
`;
      class Y {
        constructor() {
          this.settings = { url: "https://photon.komoot.io/api/", params: { q: "", limit: 10, lang: "en" }, langs: ["de", "it", "fr", "en"] };
        }
        getParameters(e2) {
          return e2.lang = e2.lang.toLowerCase(), { url: this.settings.url, params: { q: e2.query, limit: e2.limit || this.settings.params.limit, lang: this.settings.langs.includes(e2.lang) ? e2.lang : this.settings.params.lang } };
        }
        handleResponse(e2) {
          return 0 === e2.features.length ? [] : e2.features.map((e3) => ({ lon: e3.geometry.coordinates[0], lat: e3.geometry.coordinates[1], address: { name: e3.properties.name, postcode: e3.properties.postcode, city: e3.properties.city, state: e3.properties.state, country: e3.properties.country }, original: { formatted: e3.properties.name, details: e3.properties } }));
        }
      }
      class Z {
        constructor(e2) {
          this.settings = { url: "https://nominatim.openstreetmap.org/search", ...e2, params: { q: "", format: "json", addressdetails: 1, limit: 10, countrycodes: "", viewbox: "", "accept-language": "en-US" } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, format: this.settings.params.format, addressdetails: this.settings.params.addressdetails, limit: e2.limit || this.settings.params.limit, countrycodes: e2.countrycodes || this.settings.params.countrycodes, viewbox: e2.viewbox || this.settings.params.viewbox, "accept-language": e2.lang || this.settings.params["accept-language"] } };
        }
        handleResponse(e2) {
          return 0 === e2.length ? [] : e2.map((e3) => ({ lon: e3.lon, lat: e3.lat, bbox: e3.boundingbox, address: { name: e3.display_name, road: e3.address.road || "", houseNumber: e3.address.house_number || "", postcode: e3.address.postcode, city: e3.address.city || e3.address.town, state: e3.address.state, country: e3.address.country }, original: { formatted: e3.display_name, details: e3.address } }));
        }
      }
      class ee {
        constructor() {
          this.settings = { url: "https://open.mapquestapi.com/nominatim/v1/search.php", params: { q: "", key: "", format: "json", addressdetails: 1, limit: 10, countrycodes: "", "accept-language": "en-US" } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, key: e2.key, format: "json", addressdetails: 1, limit: e2.limit || this.settings.params.limit, countrycodes: e2.countrycodes || this.settings.params.countrycodes, "accept-language": e2.lang || this.settings.params["accept-language"] } };
        }
        handleResponse(e2) {
          return 0 === e2.length ? [] : e2.map((e3) => ({ lon: e3.lon, lat: e3.lat, address: { name: e3.address.neighbourhood || "", road: e3.address.road || "", postcode: e3.address.postcode, city: e3.address.city || e3.address.town, state: e3.address.state, country: e3.address.country }, original: { formatted: e3.display_name, details: e3.address } }));
        }
      }
      class te {
        constructor() {
          this.settings = { url: "https://dev.virtualearth.net/REST/v1/Locations", callbackName: "jsonp", params: { query: "", key: "", includeNeighborhood: 0, maxResults: 10 } };
        }
        getParameters(e2) {
          return { url: this.settings.url, callbackName: this.settings.callbackName, params: { query: e2.query, key: e2.key, includeNeighborhood: e2.includeNeighborhood || this.settings.params.includeNeighborhood, maxResults: e2.maxResults || this.settings.params.maxResults } };
        }
        handleResponse(e2) {
          const { resources: t2 } = e2.resourceSets[0];
          return 0 === t2.length ? [] : t2.map((e3) => ({ lon: e3.point.coordinates[1], lat: e3.point.coordinates[0], address: { name: e3.name }, original: { formatted: e3.address.formattedAddress, details: e3.address } }));
        }
      }
      class se {
        constructor() {
          this.settings = { url: "https://api.opencagedata.com/geocode/v1/json?", params: { q: "", key: "", limit: 10, countrycode: "", pretty: 1, no_annotations: 1 } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, key: e2.key, limit: e2.limit || this.settings.params.limit, countrycode: e2.countrycodes || this.settings.params.countrycodes } };
        }
        handleResponse(e2) {
          return 0 === e2.results.length ? [] : e2.results.map((e3) => ({ lon: e3.geometry.lng, lat: e3.geometry.lat, address: { name: e3.components.house_number || "", road: e3.components.road || "", postcode: e3.components.postcode, city: e3.components.city || e3.components.town, state: e3.components.state, country: e3.components.country }, original: { formatted: e3.formatted, details: e3.components } }));
        }
      }
      const re = q.cssClasses;
      class ne {
        constructor(e2, t2) {
          this.Base = e2, this.layerName = M("geocoder-layer-"), this.layer = new h.default({ name: this.layerName, source: new m.default(), displayInLayerSwitcher: false }), this.options = e2.options, this.options.provider = "string" == typeof this.options.provider ? this.options.provider.toLowerCase() : this.options.provider, this.provider = this.newProvider(), this.els = t2, this.lastQuery = "", this.container = this.els.container, this.registeredListeners = { mapClick: false }, this.setListeners();
        }
        setListeners() {
          const e2 = (e3) => {
            e3.stopPropagation(), Q(this.els.control, re.glass.expanded) ? this.collapse() : this.expand();
          };
          this.els.input.addEventListener("keypress", (e3) => {
            const t2 = e3.target.value.trim();
            (e3.key ? "Enter" === e3.key : e3.which ? 13 === e3.which : !!e3.keyCode && 13 === e3.keyCode) && (e3.preventDefault(), this.query(t2));
          }, false), this.els.input.addEventListener("click", (e3) => e3.stopPropagation(), false), this.els.input.addEventListener("input", (e3) => {
            0 !== e3.target.value.trim().length ? V(this.els.search, re.hidden) : D(this.els.search, re.hidden);
          }, false), this.els.search.addEventListener("click", () => {
            this.els.input.focus(), this.query(this.els.input.value);
          }, false), this.options.targetType === E && this.els.button.addEventListener("click", e2, false);
        }
        query(e2) {
          this.provider || (this.provider = this.newProvider());
          const t2 = this.provider.getParameters({ query: e2, key: this.options.key, lang: this.options.lang, countrycodes: this.options.countrycodes, viewbox: this.options.viewbox, limit: this.options.limit });
          if (this.lastQuery === e2 && this.els.result.firstChild)
            return;
          this.lastQuery = e2, this.clearResults(), D(this.els.search, re.spin);
          const s2 = { url: t2.url, data: t2.params };
          t2.callbackName && (s2.jsonp = true, s2.callbackName = t2.callbackName), W(s2).then((e3) => {
            this.options.debug && console.info(e3), V(this.els.search, re.spin);
            const t3 = this.provider.handleResponse(e3);
            t3 && (this.createList(t3), this.listenMapClick());
          }).catch(() => {
            V(this.els.search, re.spin);
            const e3 = U("li", "<h5>Error! No internet connection?</h5>");
            this.els.result.append(e3);
          });
        }
        createList(e2) {
          const t2 = this.els.result;
          e2.forEach((s2) => {
            let r2;
            if (this.options.provider === I)
              r2 = `<span class="${re.road}">${s2.address.name}</span>`;
            else
              r2 = this.addressTemplate(s2.address);
            if (1 == e2.length)
              this.chosen(s2, r2, s2.address, s2.original);
            else {
              const e3 = U("li", `<a href="#">${r2}</a>`);
              e3.addEventListener("click", (e4) => {
                e4.preventDefault(), this.chosen(s2, r2, s2.address, s2.original);
              }, false), t2.append(e3);
            }
          });
        }
        chosen(e2, t2, s2, r2) {
          const n2 = this.Base.getMap(), o2 = [Number.parseFloat(e2.lon), Number.parseFloat(e2.lat)], a2 = n2.getView().getProjection(), i2 = f.transform(o2, "EPSG:4326", a2);
          let { bbox: l2 } = e2;
          l2 && (l2 = f.transformExtent([parseFloat(l2[2]), parseFloat(l2[0]), parseFloat(l2[3]), parseFloat(l2[1])], "EPSG:4326", a2));
          const c2 = { formatted: t2, details: s2, original: r2 };
          if (false === this.options.keepOpen && this.clearResults(true), true === this.options.preventDefault || true === this.options.preventMarker)
            this.Base.dispatchEvent({ type: L, address: c2, coordinate: i2, bbox: l2, place: e2 });
          else {
            const t3 = this.createFeature(i2, c2);
            this.Base.dispatchEvent({ type: L, address: c2, feature: t3, coordinate: i2, bbox: l2, place: e2 });
          }
          true !== this.options.preventDefault && true !== this.options.preventPanning && (l2 ? n2.getView().fit(l2, { duration: 500 }) : n2.getView().animate({ center: i2, resolution: this.options.defaultFlyResolution, duration: 500 }));
        }
        createFeature(e2) {
          const t2 = new y.default(new g.default(e2));
          return this.addLayer(), t2.setStyle(this.options.featureStyle), t2.setId(M("geocoder-ft-")), this.getSource().addFeature(t2), t2;
        }
        addressTemplate(e2) {
          const t2 = [];
          return e2.name && t2.push(['<span class="', re.road, '">{name}</span>'].join("")), (e2.road || e2.building || e2.house_number) && t2.push(['<span class="', re.road, '">{building} {road} {house_number}</span>'].join("")), (e2.city || e2.town || e2.village) && t2.push(['<span class="', re.city, '">{postcode} {city} {town} {village}</span>'].join("")), (e2.state || e2.country) && t2.push(['<span class="', re.country, '">{state} {country}</span>'].join("")), B(t2.join("<br>"), e2);
        }
        newProvider() {
          switch (this.options.provider) {
            case I:
              return new Z(this.options);
            case N:
              return new ee();
            case P:
              return new Y();
            case A:
              return new te();
            case R:
              return new se();
            default:
              return this.options.provider;
          }
        }
        expand() {
          V(this.els.input, re.spin), D(this.els.control, re.glass.expanded), window.setTimeout(() => this.els.input.focus(), 100), this.listenMapClick();
        }
        collapse() {
          this.els.input.value = "", this.els.input.blur(), D(this.els.search, re.hidden), V(this.els.control, re.glass.expanded), this.clearResults();
        }
        listenMapClick() {
          if (this.registeredListeners.mapClick)
            return;
          const e2 = this, t2 = this.Base.getMap().getTargetElement();
          this.registeredListeners.mapClick = true, t2.addEventListener("click", { handleEvent(s2) {
            e2.clearResults(true), t2.removeEventListener(s2.type, this, false), e2.registeredListeners.mapClick = false;
          } }, false);
        }
        clearResults(e2) {
          e2 && this.options.targetType === E ? this.collapse() : function(e3) {
            for (; e3.firstChild; )
              e3.firstChild.remove();
          }(this.els.result);
        }
        getSource() {
          return this.layer.getSource();
        }
        addLayer() {
          let e2 = false;
          const t2 = this.Base.getMap();
          t2.getLayers().forEach((t3) => {
            t3 === this.layer && (e2 = true);
          }), e2 || t2.addLayer(this.layer);
        }
      }
      class oe extends d.default {
        constructor(e2 = C, t2) {
          _("string" == typeof e2, "@param `type` should be string!"), _(e2 === C || e2 === j, `@param 'type' should be '${C}'
      or '${j}'!`);
          const s2 = { ...F, featureStyle: [new u.default({ image: new p.default({ scale: 0.7, src: "//cdn.rawgit.com/jonataswalker/map-utils/master/images/marker.png" }) })], ...t2 };
          let r2, n2;
          const o2 = new J(s2);
          if (e2 === C && (r2 = o2.els.container), super({ element: r2, ...s2 }), !(this instanceof oe))
            return new oe();
          this.options = s2, this.container = r2, e2 === C && (n2 = new ne(this, o2.els), this.layer = n2.layer);
        }
        getLayer() {
          return this.layer;
        }
        getSource() {
          return this.getLayer().getSource();
        }
        setProvider(e2) {
          this.options.provider = e2;
        }
        setProviderKey(e2) {
          this.options.key = e2;
        }
      }
      return oe;
    });
  }
});

// node_modules/ol/renderer/Map.js
init_Disposable();
init_functions();
init_util();
init_transform();
init_extent();
init_IconImageCache();
init_Layer();
init_coordinate();
var MapRenderer = class extends Disposable_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super();
    this.map_ = map;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1]
    );
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    let result;
    const viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }
    const projection = viewState.projection;
    const translatedCoordinate = wrapX2(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;
    const matches = (
      /** @type {Array<HitMatch<T>>} */
      []
    );
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            const callback2 = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed
            );
            tmpCoord[0] = coordinates2[0] + offsets[i][0];
            tmpCoord[1] = coordinates2[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback2,
              matches
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => m.distanceSq += i * order);
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      TRUE,
      this,
      layerFilter,
      thisArg
    );
    return hasFeature !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(frameState) {
    if (shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
};
function expireIconCache(map, frameState) {
  shared.expire();
}
var Map_default = MapRenderer;

// node_modules/ol/renderer/Composite.js
init_BaseVector();
init_ObjectEventType();
init_Event2();
init_EventType2();
init_css();
init_canvas();
init_Layer();
init_events();
init_dom();
var CompositeMapRenderer = class extends Map_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super(map);
    this.fontChangeListenerKey_ = listen(
      checkedFonts,
      ObjectEventType_default.PROPERTYCHANGE,
      map.redrawText.bind(map)
    );
    this.element_ = document.createElement("div");
    const style = this.element_.style;
    style.position = "absolute";
    style.width = "100%";
    style.height = "100%";
    style.zIndex = "0";
    this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);
    this.children_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new Event_default2(type, void 0, frameState);
      map.dispatchEvent(event);
    }
  }
  disposeInternal() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);
    super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(EventType_default2.PRECOMPOSE, frameState);
    const layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
      return a.zIndex - b.zIndex;
    });
    const declutter = layerStatesArray.some(
      (layerState) => layerState.layer instanceof BaseVector_default && layerState.layer.getDeclutter()
    );
    if (declutter) {
      frameState.declutter = {};
    }
    const viewState = frameState.viewState;
    this.children_.length = 0;
    const renderedLayerStates = [];
    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      renderedLayerStates.push(layerState);
    }
    this.declutter(frameState, renderedLayerStates);
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(EventType_default2.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(frameState, layerStates) {
    if (!frameState.declutter) {
      return;
    }
    for (let i = layerStates.length - 1; i >= 0; --i) {
      const layerState = layerStates[i];
      const layer = layerState.layer;
      if (layer.getDeclutter()) {
        layer.renderDeclutter(frameState, layerState);
      }
    }
    layerStates.forEach(
      (layerState) => layerState.layer.renderDeferred(frameState)
    );
  }
};
var Composite_default = CompositeMapRenderer;

// node_modules/ol/layer/Group.js
init_Base();
init_Collection();
init_CollectionEventType();
init_Event();
init_EventType();
init_ObjectEventType();
init_asserts();
init_obj();
init_extent();
init_util();
init_events();
var GroupEvent = class extends Event_default {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(type, layer) {
    super(type);
    this.layer = layer;
  }
};
var Property3 = {
  LAYERS: "layers"
};
var LayerGroup = class _LayerGroup extends Base_default {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(options) {
    options = options || {};
    const baseOptions = (
      /** @type {Options} */
      Object.assign({}, options)
    );
    delete baseOptions.layers;
    let layers = options.layers;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.layersListenerKeys_ = [];
    this.listenerKeys_ = {};
    this.addChangeListener(Property3.LAYERS, this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new Collection_default(layers.slice(), { unique: true });
      } else {
        assert(
          typeof /** @type {?} */
          layers.getArray === "function",
          "Expected `layers` to be an array or a `Collection`"
        );
      }
    } else {
      layers = new Collection_default(void 0, { unique: true });
    }
    this.setLayers(layers);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
      listen(
        layers,
        CollectionEventType_default.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear(this.listenerKeys_);
    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(layer) {
    const listenerKeys = [
      listen(
        layer,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof _LayerGroup) {
      listenerKeys.push(
        listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
        listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
      );
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Property3.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
      }
    }
    this.set(Property3.LAYERS, layers);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    array = array !== void 0 ? array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(dest) {
    const states = dest !== void 0 ? dest : [];
    const pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(
            layerState.extent,
            ownLayerState.extent
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
};
var Group_default = LayerGroup;

// node_modules/ol/MapEvent.js
init_Event();
var MapEvent = class extends Event_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(type, map, frameState) {
    super(type);
    this.map = map;
    this.frameState = frameState !== void 0 ? frameState : null;
  }
};
var MapEvent_default = MapEvent;

// node_modules/ol/MapBrowserEvent.js
var MapBrowserEvent = class extends MapEvent_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);
    this.originalEvent = originalEvent;
    this.pixel_ = null;
    this.coordinate_ = null;
    this.dragging = dragging !== void 0 ? dragging : false;
    this.activePointers = activePointers;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault();
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation();
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
};
var MapBrowserEvent_default = MapBrowserEvent;

// node_modules/ol/MapBrowserEventType.js
init_EventType();
var MapBrowserEventType_default = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: EventType_default.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: EventType_default.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/pointer/EventType.js
var EventType_default3 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/MapBrowserEventHandler.js
init_EventType();
init_Target();
init_has();
init_events();
var MapBrowserEventHandler = class extends Target_default {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(map, moveTolerance) {
    super(map);
    this.map_ = map;
    this.clickTimeoutId_;
    this.emulateClicks_ = false;
    this.dragging_ = false;
    this.dragListenerKeys_ = [];
    this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    this.down_ = null;
    const element = this.map_.getViewport();
    this.activePointers_ = [];
    this.trackedTouches_ = {};
    this.element_ = element;
    this.pointerdownListenerKey_ = listen(
      element,
      EventType_default3.POINTERDOWN,
      this.handlePointerDown_,
      this
    );
    this.originalPointerMoveEvent_;
    this.relayedListenerKey_ = listen(
      element,
      EventType_default3.POINTERMOVE,
      this.relayMoveEvent_,
      this
    );
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
    this.element_.addEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_,
      PASSIVE_EVENT_LISTENERS ? { passive: false } : false
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(pointerEvent) {
    let newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.CLICK,
      this.map_,
      pointerEvent
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.DBLCLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const newEvent2 = new MapBrowserEvent_default(
          MapBrowserEventType_default.SINGLECLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent2);
      }, 250);
    }
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;
    if (event.type == MapBrowserEventType_default.POINTERUP || event.type == MapBrowserEventType_default.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType_default.POINTERDOWN || event.type == MapBrowserEventType_default.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERUP,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERDOWN,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, "target", {
      writable: false,
      value: pointerEvent.target
    });
    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        listen(
          doc,
          MapBrowserEventType_default.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        listen(doc, MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        listen(
          this.element_,
          MapBrowserEventType_default.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          listen(
            this.element_.getRootNode(),
            MapBrowserEventType_default.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(event) {
    const originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_
    );
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    super.disposeInternal();
  }
};
var MapBrowserEventHandler_default = MapBrowserEventHandler;

// node_modules/ol/MapProperty.js
var MapProperty_default = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};

// node_modules/ol/structs/PriorityQueue.js
init_asserts();
init_obj();
var DROP = Infinity;
var PriorityQueue = class {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = /** @type {T} */
      elements.pop();
      priorities[0] = /** @type {number} */
      priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    assert(
      !(this.keyFunction_(element) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(index) {
    return index - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;
    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);
      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }
    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];
    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
};
var PriorityQueue_default = PriorityQueue;

// node_modules/ol/TileState.js
var TileState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/TileQueue.js
init_EventType();
var TileQueue = class extends PriorityQueue_default {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (
          /** @type {import("./Tile.js").default} */
          element[0].getKey()
        );
      }
    );
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);
    this.tileChangeCallback_ = tileChangeCallback;
    this.tilesLoading_ = 0;
    this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile2 = element[0];
      tile2.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile2 = (
      /** @type {import("./Tile.js").default} */
      event.target
    );
    const state = tile2.getState();
    if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
      if (state !== TileState_default.ERROR) {
        tile2.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile2.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    let state, tile2, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile2 = /** @type {import("./Tile.js").default} */
      this.dequeue()[0];
      tileKey = tile2.getKey();
      state = tile2.getState();
      if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile2.load();
      }
    }
  }
};
var TileQueue_default = TileQueue;
function getTilePriority(frameState, tile2, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile2.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

// node_modules/ol/control/Attribution.js
init_Control();
init_EventType();
init_css();
init_array();
init_dom();
init_functions();
var Attribution = class extends Control_default {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.ulElement_ = document.createElement("ul");
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.userCollapsed_ = this.collapsed_;
    this.overrideCollapsible_ = options.collapsible !== void 0;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    const className = options.className !== void 0 ? options.className : "ol-attribution";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button");
    this.toggleButton_.setAttribute("type", "button");
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);
    this.toggleButton_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);
    this.renderedAttributions_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(frameState) {
    const visibleAttributions = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((layer) => layer.getAttributions(frameState))
      )
    );
    const collapsible = !this.getMap().getAllLayers().some(
      (layer) => layer.getSource() && layer.getSource().getAttributionsCollapsible() === false
    );
    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }
    return visibleAttributions;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const attributions = await Promise.all(
      this.collectSourceAttributions_(frameState).map(
        (attribution) => toPromise(() => attribution)
      )
    );
    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement("li");
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
};
var Attribution_default = Attribution;

// node_modules/ol/control/Rotate.js
init_Control();
init_EventType();
init_css();
init_easing();
var Rotate = class extends Control_default {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-rotate";
    const label = options.label !== void 0 ? options.label : "\u21E7";
    const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    this.label_ = null;
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }
    const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    const button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(this.label_);
    button.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    this.rotation_ = void 0;
    if (this.autoHide_) {
      this.element.classList.add(CLASS_HIDDEN);
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }
  /**
   * @private
   */
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        const contains2 = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains2 && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains2 && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  }
};
var Rotate_default = Rotate;

// node_modules/ol/control/Zoom.js
init_Control();
init_EventType();
init_css();
init_easing();
var Zoom = class extends Control_default {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-zoom";
    const delta = options.delta !== void 0 ? options.delta : 1;
    const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    const inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel
    );
    inElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, delta),
      false
    );
    const outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );
    outElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, -delta),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
};
var Zoom_default = Zoom;

// node_modules/ol/control/defaults.js
init_Collection();
function defaults(options) {
  options = options ? options : {};
  const controls = new Collection_default();
  const zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom_default(options.zoomOptions));
  }
  const rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate_default(options.rotateOptions));
  }
  const attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution_default(options.attributionOptions));
  }
  return controls;
}

// node_modules/ol/interaction/Property.js
var Property_default2 = {
  ACTIVE: "active"
};

// node_modules/ol/interaction/Interaction.js
init_Object();
init_easing();
var Interaction = class extends Object_default {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }
    this.map_ = null;
    this.setActive(true);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Property_default2.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    return true;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    this.set(Property_default2.ACTIVE, active);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    this.map_ = map;
  }
};
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== void 0 ? duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor,
    duration: duration !== void 0 ? duration : 250,
    easing: easeOut
  });
}
var Interaction_default = Interaction;

// node_modules/ol/interaction/DoubleClickZoom.js
var DoubleClickZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK) {
      const browserEvent = (
        /** @type {MouseEvent} */
        mapBrowserEvent.originalEvent
      );
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
};
var DoubleClickZoom_default = DoubleClickZoom;

// node_modules/ol/interaction/Pointer.js
var PointerInteraction = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }
    this.handlingDownUpSequence = false;
    this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(mapBrowserEvent) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(mapBrowserEvent) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
};
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return { clientX: clientX / length, clientY: clientY / length };
}
var Pointer_default = PointerInteraction;

// node_modules/ol/events/condition.js
init_functions();
init_has();
init_asserts();
function all(var_args) {
  const conditions = arguments;
  return function(event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
var altKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var altShiftKeysOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var focus = function(event) {
  const targetElement = event.map.getTargetElement();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};
var focusWithTabindex = function(event) {
  return event.map.getTargetElement().hasAttribute("tabindex") ? focus(event) : true;
};
var always2 = TRUE;
var click = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType_default.CLICK;
};
var mouseActionButton = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {MouseEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
var never = FALSE;
var pointerMove = function(mapBrowserEvent) {
  return mapBrowserEvent.type == "pointermove";
};
var singleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType_default.SINGLECLICK;
};
var doubleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK;
};
var noModifierKeys = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKey = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};
var shiftKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var targetNotEditable = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  const tagName = (
    /** @type {Element} */
    originalEvent.target.tagName
  );
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !originalEvent.target.isContentEditable;
};
var mouseOnly = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.pointerType == "mouse";
};
var touchOnly = function(mapBrowserEvent) {
  const pointerEvt = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvt !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvt.pointerType === "touch";
};
var penOnly = function(mapBrowserEvent) {
  const pointerEvt = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvt !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvt.pointerType === "pen";
};
var primaryAction = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

// node_modules/ol/interaction/DragPan.js
init_functions();
init_easing();
init_coordinate();
var DragPan = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super({
      stopDown: FALSE
    });
    options = options ? options : {};
    this.kinetic_ = options.kinetic;
    this.lastCentroid = null;
    this.lastPointersCount_;
    this.panning_ = false;
    const condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.noKinetic_ = false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid2 = map.getEventPixel(centroid(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid2[0], centroid2[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid2[0],
          centroid2[1] - this.lastCentroid[1]
        ];
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        scale(delta, view.getResolution());
        rotate(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid2;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance2 = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance2 * Math.cos(angle),
          centerpx[1] - distance2 * Math.sin(angle)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
};
var DragPan_default = DragPan;

// node_modules/ol/interaction/DragRotate.js
init_functions();
init_rotationconstraint();
var DragRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      stopDown: FALSE
    });
    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    this.lastAngle_ = void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const size = map.getSize();
    const offset2 = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset2[1], offset2[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    }
    return false;
  }
};
var DragRotate_default = DragRotate;

// node_modules/ol/render/Box.js
init_Disposable();
init_Polygon();
var RenderBox = class extends Disposable_default {
  /**
   * @param {string} className CSS class name.
   */
  constructor(className) {
    super();
    this.geometry_ = null;
    this.element_ = document.createElement("div");
    this.element_.style.position = "absolute";
    this.element_.style.pointerEvents = "auto";
    this.element_.className = "ol-box " + className;
    this.map_ = null;
    this.startPixel_ = null;
    this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = "px";
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = "inherit";
      style.top = "inherit";
      style.width = "inherit";
      style.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_) {
      return;
    }
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    const coordinates2 = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon_default([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
};
var Box_default = RenderBox;

// node_modules/ol/interaction/DragBox.js
init_Event();
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
var DragBoxEvent = class extends Event_default {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);
    this.coordinate = coordinate;
    this.mapBrowserEvent = mapBrowserEvent;
  }
};
var DragBox = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ? options : {};
    this.box_ = new Box_default(options.className || "ol-dragbox");
    this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }
    this.startPixel_ = null;
    this.condition_ = options.condition ? options.condition : mouseActionButton;
    this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return;
    }
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return false;
    }
    this.box_.setMap(null);
    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return true;
    }
    return false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    if (!active) {
      this.box_.setMap(null);
      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null)
        );
        this.startPixel_ = null;
      }
    }
    super.setActive(active);
  }
};
var DragBox_default = DragBox;

// node_modules/ol/interaction/DragZoom.js
init_easing();
var DragZoom = class extends DragBox_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const condition = options.condition ? options.condition : shiftKeyOnly;
    super({
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    });
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    this.out_ = options.out !== void 0 ? options.out : false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
    const map = this.getMap();
    const view = (
      /** @type {!import("../View.js").default} */
      map.getView()
    );
    let geometry = this.getGeometry();
    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  }
};
var DragZoom_default = DragZoom;

// node_modules/ol/events/Key.js
var Key_default = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};

// node_modules/ol/interaction/KeyboardPan.js
init_EventType();
init_coordinate();
var KeyboardPan = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
    this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key == Key_default.DOWN || key == Key_default.LEFT || key == Key_default.RIGHT || key == Key_default.UP)) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0, deltaY = 0;
        if (key == Key_default.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == Key_default.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == Key_default.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        rotate(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardPan_default = KeyboardPan;

// node_modules/ol/interaction/KeyboardZoom.js
init_EventType();
var KeyboardZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
      return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN || mapBrowserEvent.type == EventType_default.KEYPRESS) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === "+" || key === "-")) {
        const map = mapBrowserEvent.map;
        const delta = key === "+" ? this.delta_ : -this.delta_;
        const view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardZoom_default = KeyboardZoom;

// node_modules/ol/Kinetic.js
var Kinetic = class {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6) {
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration < 1e3 / 60) {
      return false;
    }
    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
};
var Kinetic_default = Kinetic;

// node_modules/ol/interaction/MouseWheelZoom.js
init_EventType();
init_has();
init_math();
var MouseWheelZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    this.totalDelta_ = 0;
    this.lastDelta_ = 0;
    this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    const condition = options.condition ? options.condition : always2;
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_;
    this.mode_ = void 0;
    this.trackpadEventGap_ = 400;
    this.trackpadTimeoutId_;
    this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== EventType_default.WHEEL) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const wheelEvent = (
      /** @type {WheelEvent} */
      mapBrowserEvent.originalEvent
    );
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }
    let delta;
    if (mapBrowserEvent.type == EventType_default.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;
    const now = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now;
    }
    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
    }
    const view = map.getView();
    if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      );
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }
    this.totalDelta_ += delta;
    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft
    );
    return false;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta = -clamp(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
};
var MouseWheelZoom_default = MouseWheelZoom;

// node_modules/ol/interaction/PinchRotate.js
init_functions();
init_rotationconstraint();
var PinchRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.lastAngle_ = void 0;
    this.rotating_ = false;
    this.rotationDelta_ = 0;
    this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchRotate_default = PinchRotate;

// node_modules/ol/interaction/PinchZoom.js
init_functions();
var PinchZoom = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
    this.lastDistance_ = void 0;
    this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance2;
    }
    this.lastDistance_ = distance2;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchZoom_default = PinchZoom;

// node_modules/ol/interaction/defaults.js
init_Collection();
function defaults2(options) {
  options = options ? options : {};
  const interactions = new Collection_default();
  const kinetic = new Kinetic_default(-5e-3, 0.05, 100);
  const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate_default());
  }
  const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new DoubleClickZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new DragPan_default({
        onFocusOnly: options.onFocusOnly,
        kinetic
      })
    );
  }
  const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate_default());
  }
  const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new PinchZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan_default());
    interactions.push(
      new KeyboardZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new MouseWheelZoom_default({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
      })
    );
  }
  const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new DragZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  return interactions;
}

// node_modules/ol/Map.js
init_Object();
init_Collection();
init_CollectionEventType();
init_EventType();
init_Layer();
init_MapEventType();
init_ObjectEventType();
init_EventType2();
init_View();
init_ViewHint();
init_has();
init_functions();
init_transform();
init_asserts();
init_extent();
init_array();
init_proj();
init_util();
init_size();
init_events();
init_dom();
init_console();
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof Group_default) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof Group_default) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
var Map = class extends Object_default {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.on;
    this.once;
    this.un;
    const optionsInternal = createOptionsInternal(options);
    this.renderComplete_;
    this.loaded_ = true;
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
    this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    this.postRenderTimeoutHandle_;
    this.animationDelayKey_;
    this.animationDelay_ = this.animationDelay_.bind(this);
    this.coordinateToPixelTransform_ = create();
    this.pixelToCoordinateTransform_ = create();
    this.frameIndex_ = 0;
    this.frameState_ = null;
    this.previousExtent_ = null;
    this.viewPropertyListenerKey_ = null;
    this.viewChangeListenerKey_ = null;
    this.layerGroupPropertyListenerKeys_ = null;
    this.viewport_ = document.createElement("div");
    this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    this.viewport_.style.position = "relative";
    this.viewport_.style.overflow = "hidden";
    this.viewport_.style.width = "100%";
    this.viewport_.style.height = "100%";
    this.overlayContainer_ = document.createElement("div");
    this.overlayContainer_.style.position = "absolute";
    this.overlayContainer_.style.zIndex = "0";
    this.overlayContainer_.style.width = "100%";
    this.overlayContainer_.style.height = "100%";
    this.overlayContainer_.style.pointerEvents = "none";
    this.overlayContainer_.className = "ol-overlaycontainer";
    this.viewport_.appendChild(this.overlayContainer_);
    this.overlayContainerStopEvent_ = document.createElement("div");
    this.overlayContainerStopEvent_.style.position = "absolute";
    this.overlayContainerStopEvent_.style.zIndex = "0";
    this.overlayContainerStopEvent_.style.width = "100%";
    this.overlayContainerStopEvent_.style.height = "100%";
    this.overlayContainerStopEvent_.style.pointerEvents = "none";
    this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    this.viewport_.appendChild(this.overlayContainerStopEvent_);
    this.mapBrowserEventHandler_ = null;
    this.moveTolerance_ = options.moveTolerance;
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    this.targetChangeHandlerKeys_ = null;
    this.targetElement_ = null;
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());
    this.controls = optionsInternal.controls || defaults();
    this.interactions = optionsInternal.interactions || defaults2({
      onFocusOnly: true
    });
    this.overlays_ = optionsInternal.overlays;
    this.overlayIdIndex_ = {};
    this.renderer_ = null;
    this.postRenderFunctions_ = [];
    this.tileQueue_ = new TileQueue_default(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    );
    this.addChangeListener(
      MapProperty_default.LAYERGROUP,
      this.handleLayerGroupChanged_
    );
    this.addChangeListener(MapProperty_default.VIEW, this.handleViewChanged_);
    this.addChangeListener(MapProperty_default.SIZE, this.handleSizeChanged_);
    this.addChangeListener(MapProperty_default.TARGET, this.handleTargetChanged_);
    this.setProperties(optionsInternal.values);
    const map = this;
    if (options.view && !(options.view instanceof View_default)) {
      options.view.then(function(viewOptions) {
        map.setView(new View_default(viewOptions));
      });
    }
    this.controls.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.controls.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        this.addOverlayInternal_(event.element);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        const id = event.element.getId();
        if (id !== void 0) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }
    );
    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (control) => {
        control.setMap(this);
      }
    );
    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (interaction) => {
        interaction.setMap(this);
      }
    );
    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(control) {
    this.getControls().push(control);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function(feature) {
        features.push(feature);
      },
      options
    );
    return features;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof Group_default) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in event ? (
        /** @type {TouchEvent} */
        event.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        event
      )
    );
    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(MapProperty_default.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(pixel) {
    return toUserCoordinate(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(MapProperty_default.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof Collection_default) {
      group.setLayers(layers);
      return;
    }
    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = fromUserCoordinate(
      coordinate,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2)
    );
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(MapProperty_default.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(MapProperty_default.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(tile2, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(
      this.frameState_,
      tile2,
      tileSourceKey,
      tileCenter,
      tileResolution
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent_default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    const originalEvent = (
      /** @type {PointerEvent} */
      mapBrowserEvent.originalEvent
    );
    const eventType = originalEvent.type;
    if (eventType === EventType_default3.POINTERDOWN || eventType === EventType_default.WHEEL || eventType === EventType_default.KEYDOWN) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      const target = (
        /** @type {Node} */
        originalEvent.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)
      ) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const frameState = this.frameState_;
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[ViewHint_default.ANIMATING] || hints[ViewHint_default.INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_ === true) {
        if (this.hasListener(EventType_default2.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            EventType_default2.RENDERCOMPLETE,
            frameState
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.LOADEND, this, frameState)
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.LOADSTART, this, frameState)
        );
      }
    }
    const postRenderFunctions = this.postRenderFunctions_;
    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        unlistenByKey(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      );
      this.viewport_.removeEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      removeNode(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(void 0);
    }
    const target = this.getTarget();
    const targetElement = typeof target === "string" ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new Composite_default(this);
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler_default(
        this,
        this.moveTolerance_
      );
      for (const key in MapBrowserEventType_default) {
        this.mapBrowserEventHandler_.addEventListener(
          MapBrowserEventType_default[key],
          this.handleMapBrowserEvent.bind(this)
        );
      }
      this.viewport_.addEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false
      );
      this.viewport_.addEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_,
        PASSIVE_EVENT_LISTENERS ? { passive: false } : false
      );
      const keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [
        listen(
          keyboardEventTarget,
          EventType_default.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        listen(
          keyboardEventTarget,
          EventType_default.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_(this.getSize());
      this.viewPropertyListenerKey_ = listen(
        view,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      this.viewChangeListenerKey_ = listen(
        view,
        EventType_default.CHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      view.resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType_default.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType_default.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0;
    this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(control) {
    return this.getControls().remove(control);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    let frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: getForViewAndSize(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size
        );
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions
      );
      if (previousFrameState) {
        const moveStart = !this.previousExtent_ || !isEmpty2(this.previousExtent_) && !equals2(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.MOVESTART, this, previousFrameState)
          );
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING] && !equals2(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.MOVEEND, this, frameState)
        );
        clone(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent_default(MapEventType_default.POSTRENDER, this, frameState));
    this.renderComplete_ = this.hasListener(MapEventType_default.LOADSTART) || this.hasListener(MapEventType_default.LOADEND) || this.hasListener(EventType_default2.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0;
        this.handlePostRender();
      }, 0);
    }
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty_default.LAYERGROUP, layerGroup);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(size) {
    this.set(MapProperty_default.SIZE, size);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(target) {
    this.set(MapProperty_default.TARGET, target);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(view) {
    if (!view || view instanceof View_default) {
      this.set(MapProperty_default.VIEW, view);
      return;
    }
    this.set(MapProperty_default.VIEW, new View_default());
    const map = this;
    view.then(function(viewOptions) {
      map.setView(new View_default(viewOptions));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const targetElement = this.getTargetElement();
    let size = void 0;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          warn(
            "No map visible because the map container's width or height are 0."
          );
        }
      }
    }
    const oldSize = this.getSize();
    if (size && (!oldSize || !equals(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_(size);
    }
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(size) {
    const view = this.getView();
    if (view) {
      view.setViewportSize(size);
    }
  }
};
function createOptionsInternal(options) {
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  const values = {};
  const layerGroup = options.layers && typeof /** @type {?} */
  options.layers.getLayers === "function" ? (
    /** @type {LayerGroup} */
    options.layers
  ) : new Group_default({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      options.layers
    )
  });
  values[MapProperty_default.LAYERGROUP] = layerGroup;
  values[MapProperty_default.TARGET] = options.target;
  values[MapProperty_default.VIEW] = options.view instanceof View_default ? options.view : new View_default();
  let controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection_default(options.controls.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.controls.getArray === "function",
        "Expected `controls` to be an array or an `ol/Collection.js`"
      );
      controls = options.controls;
    }
  }
  let interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection_default(options.interactions.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.interactions.getArray === "function",
        "Expected `interactions` to be an array or an `ol/Collection.js`"
      );
      interactions = options.interactions;
    }
  }
  let overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection_default(options.overlays.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.overlays.getArray === "function",
        "Expected `overlays` to be an array or an `ol/Collection.js`"
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection_default();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values
  };
}
var Map_default2 = Map;

// node_modules/ol/control/MousePosition.js
init_Control();
init_proj();
init_events();
init_coordinate();
var PROJECTION = "projection";
var COORDINATE_FORMAT = "coordinateFormat";
var MousePosition = class extends Control_default {
  /**
   * @param {Options} [options] Mouse position options.
   */
  constructor(options) {
    options = options ? options : {};
    const element = document.createElement("div");
    element.className = options.className !== void 0 ? options.className : "ol-mouse-position";
    super({
      element,
      render: options.render,
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    this.addChangeListener(PROJECTION, this.handleProjectionChanged_);
    if (options.coordinateFormat) {
      this.setCoordinateFormat(options.coordinateFormat);
    }
    if (options.projection) {
      this.setProjection(options.projection);
    }
    this.renderOnMouseOut_ = options.placeholder !== void 0;
    this.placeholder_ = this.renderOnMouseOut_ ? options.placeholder : "&#160;";
    this.renderedHTML_ = element.innerHTML;
    this.mapProjection_ = null;
    this.transform_ = null;
    this.wrapX_ = options.wrapX === false ? false : true;
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    this.transform_ = null;
  }
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */
  getCoordinateFormat() {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(COORDINATE_FORMAT)
    );
  }
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(PROJECTION)
    );
  }
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */
  handleMouseMove(event) {
    const map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  }
  /**
   * @param {Event} event Browser event.
   * @protected
   */
  handleMouseOut(event) {
    this.updateHTML_(null);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    super.setMap(map);
    if (map) {
      const viewport = map.getViewport();
      this.listenerKeys.push(
        listen(viewport, EventType_default3.POINTERMOVE, this.handleMouseMove, this)
      );
      if (this.renderOnMouseOut_) {
        this.listenerKeys.push(
          listen(viewport, EventType_default3.POINTEROUT, this.handleMouseOut, this)
        );
      }
      this.updateHTML_(null);
    }
  }
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */
  setCoordinateFormat(format2) {
    this.set(COORDINATE_FORMAT, format2);
  }
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  setProjection(projection) {
    this.set(PROJECTION, get3(projection));
  }
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */
  updateHTML_(pixel) {
    let html = this.placeholder_;
    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        const projection = this.getProjection();
        if (projection) {
          this.transform_ = getTransformFromProjections(
            this.mapProjection_,
            projection
          );
        } else {
          this.transform_ = identityTransform;
        }
      }
      const map = this.getMap();
      const coordinate = map.getCoordinateFromPixelInternal(pixel);
      if (coordinate) {
        const userProjection2 = getUserProjection();
        if (userProjection2) {
          this.transform_ = getTransformFromProjections(
            this.mapProjection_,
            userProjection2
          );
        }
        this.transform_(coordinate, coordinate);
        if (this.wrapX_) {
          const projection = userProjection2 || this.getProjection() || this.mapProjection_;
          wrapX2(coordinate, projection);
        }
        const coordinateFormat = this.getCoordinateFormat();
        if (coordinateFormat) {
          html = coordinateFormat(coordinate);
        } else {
          html = coordinate.toString();
        }
      }
    }
    if (!this.renderedHTML_ || html !== this.renderedHTML_) {
      this.element.innerHTML = html;
      this.renderedHTML_ = html;
    }
  }
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  }
};
var MousePosition_default = MousePosition;

// node_modules/ol/Tile.js
init_Target();
init_EventType();
init_util();
init_easing();
var Tile = class extends Target_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();
    options = options ? options : {};
    this.tileCoord = tileCoord;
    this.state = state;
    this.interimTile = null;
    this.key = "";
    this.transition_ = options.transition === void 0 ? 250 : options.transition;
    this.transitionStarts_ = {};
    this.interpolate = !!options.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    if (this.state === TileState_default.ERROR) {
      this.setState(TileState_default.EMPTY);
    }
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    let tile2 = this.interimTile;
    if (!tile2) {
      return this;
    }
    do {
      if (tile2.getState() == TileState_default.LOADED) {
        this.transition_ = 0;
        return tile2;
      }
      tile2 = tile2.interimTile;
    } while (tile2);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    let tile2 = this.interimTile;
    if (!tile2) {
      return;
    }
    let prev = this;
    do {
      if (tile2.getState() == TileState_default.LOADED) {
        tile2.interimTile = null;
        break;
      }
      if (tile2.getState() == TileState_default.LOADING) {
        prev = tile2;
      } else if (tile2.getState() == TileState_default.IDLE) {
        prev.interimTile = tile2.interimTile;
      } else {
        prev = tile2;
      }
      tile2 = prev.interimTile;
    } while (tile2);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state !== TileState_default.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    abstract();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }
    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }
    const delta = time - start + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
};
var Tile_default = Tile;

// node_modules/ol/ImageTile.js
init_dom();
init_Image2();
var ImageTile = class extends Tile_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);
    this.crossOrigin_ = crossOrigin;
    this.src_ = src;
    this.key = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.tileLoadFunction_ = tileLoadFunction;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = TileState_default.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = TileState_default.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    if (image.naturalWidth && image.naturalHeight) {
      this.state = TileState_default.LOADED;
    } else {
      this.state = TileState_default.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    if (this.state == TileState_default.ERROR) {
      this.state = TileState_default.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
};
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile_default = ImageTile;

// node_modules/ol/reproj/common.js
var ERROR_THRESHOLD = 0.5;

// node_modules/ol/reproj/Triangulation.js
init_extent();
init_proj();
init_math();
var MAX_SUBDIVISION = 10;
var MAX_TRIANGLE_WIDTH = 0.25;
var Triangulation = class {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    let transformInvCache = {};
    const transformInv = getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c) {
      const key = c[0] + "/" + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    const destinationTopLeft = getTopLeft(targetExtent);
    const destinationTopRight = getTopRight(targetExtent);
    const destinationBottomRight = getBottomRight(targetExtent);
    const destinationBottomLeft = getBottomLeft(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
        )
      )
    ) : 0);
    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );
    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function(triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });
      this.triangles_.forEach((triangle) => {
        if (Math.max(
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        ) - leftBound > this.sourceWorldWidth_ / 2) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    const sourceWorldWidth = (
      /** @type {number} */
      this.sourceWorldWidth_
    );
    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    let needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = boundingExtent([a, b, c, d]);
        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    let isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);
        let dx;
        if (wrapsX) {
          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);
          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);
          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = createEmpty();
    this.triangles_.forEach(function(triangle, i, arr) {
      const src = triangle.source;
      extendCoordinate(extent, src[0]);
      extendCoordinate(extent, src[1]);
      extendCoordinate(extent, src[2]);
    });
    return extent;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
};
var Triangulation_default = Triangulation;

// node_modules/ol/reproj.js
init_extent();
init_dom();
init_proj();
init_math();
var brokenDiagonalRendering_;
var canvasPool = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset2) {
  return Math.abs(data[offset2 * 4] - 210) > 2 || Math.abs(data[offset2 * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle, clipExtent) {
  const context = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend2(sourceDataExtent, src.extent);
  });
  let stitchContext;
  const stitchScale = pixelRatio / sourceResolution;
  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    stitchContext = createCanvasContext2D(
      Math.round(getWidth(sourceDataExtent) * stitchScale),
      Math.round(getHeight(sourceDataExtent) * stitchScale),
      canvasPool
    );
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    if (sourceExtent && clipExtent) {
      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;
      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;
      const width2 = getWidth(sourceExtent) * stitchScale;
      const height2 = getHeight(sourceExtent) * stitchScale;
      stitchContext.rect(xPos, yPos, width2, height2);
      stitchContext.clip();
    }
    sources.forEach(function(src, i, arr) {
      if (src.image.width > 0 && src.image.height > 0) {
        if (src.clipExtent) {
          stitchContext.save();
          const xPos2 = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;
          const yPos2 = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;
          const width2 = getWidth(src.clipExtent) * stitchScale;
          const height2 = getHeight(src.clipExtent) * stitchScale;
          stitchContext.rect(
            interpolate ? xPos2 : Math.round(xPos2),
            interpolate ? yPos2 : Math.round(yPos2),
            interpolate ? width2 : Math.round(xPos2 + width2) - Math.round(xPos2),
            interpolate ? height2 : Math.round(yPos2 + height2) - Math.round(yPos2)
          );
          stitchContext.clip();
        }
        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;
        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;
        const srcWidth = getWidth(src.extent) * stitchScale;
        const srcHeight = getHeight(src.extent) * stitchScale;
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          interpolate ? xPos : Math.round(xPos),
          interpolate ? yPos : Math.round(yPos),
          interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),
          interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos)
        );
        if (src.clipExtent) {
          stitchContext.restore();
        }
      }
    });
  }
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x2 = source[2][0], y2 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(inverseScale, -inverseScale);
    } else {
      const source2 = sources[0];
      const extent = source2.extent;
      image = source2.image;
      context.scale(
        getWidth(extent) / image.width,
        -getHeight(extent) / image.height
      );
    }
    context.drawImage(image, 0, 0);
    context.restore();
  });
  if (stitchContext) {
    releaseCanvas(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}

// node_modules/ol/reproj/Tile.js
init_EventType();
init_math();
init_extent();
init_events();
init_dom();
var ReprojTile = class extends Tile_default {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
    super(tileCoord, TileState_default.IDLE, options);
    this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.canvas_ = null;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : void 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation_default(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState_default.EMPTY;
    } else {
      let worldWidth = 0;
      let worldsAway = 0;
      if (sourceProj.canWrapX()) {
        worldWidth = getWidth(sourceProjExtent);
        worldsAway = Math.floor(
          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth
        );
      }
      const sourceExtents = wrapAndSliceX(
        sourceExtent.slice(),
        sourceProj,
        true
      );
      sourceExtents.forEach((extent) => {
        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
          extent,
          this.sourceZ_
        );
        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            const tile2 = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
            if (tile2) {
              const offset2 = worldsAway * worldWidth;
              this.sourceTiles_.push({ tile: tile2, offset: offset2 });
            }
          }
        }
        ++worldsAway;
      });
      if (this.sourceTiles_.length === 0) {
        this.state = TileState_default.EMPTY;
      }
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((source) => {
      const tile2 = source.tile;
      if (tile2 && tile2.getState() == TileState_default.LOADED) {
        const extent = this.sourceTileGrid_.getTileCoordExtent(tile2.tileCoord);
        extent[0] += source.offset;
        extent[2] += source.offset;
        const clipExtent = this.clipExtent_?.slice();
        if (clipExtent) {
          clipExtent[0] += source.offset;
          clipExtent[2] += source.offset;
        }
        sources.push({
          extent,
          clipExtent,
          image: tile2.getImage()
        });
      }
    });
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState_default.ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === "number" ? size : size[0];
      const height = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = render(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );
      this.state = TileState_default.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      let leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(({ tile: tile2 }) => {
        const state = tile2.getState();
        if (state == TileState_default.IDLE || state == TileState_default.LOADING) {
          leftToLoad++;
          const sourceListenKey = listen(
            tile2,
            EventType_default.CHANGE,
            function(e) {
              const state2 = tile2.getState();
              if (state2 == TileState_default.LOADED || state2 == TileState_default.ERROR || state2 == TileState_default.EMPTY) {
                unlistenByKey(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            },
            this
          );
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function({ tile: tile2 }, i, arr) {
          const state = tile2.getState();
          if (state == TileState_default.IDLE) {
            tile2.load();
          }
        });
      }
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    if (this.canvas_) {
      releaseCanvas(this.canvas_.getContext("2d"));
      canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
};
var Tile_default2 = ReprojTile;

// node_modules/ol/structs/LRUCache.js
init_asserts();
var LRUCache = class {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */
      entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(key) {
    return this.entries_[key]?.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */
    entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    assert(
      !(key in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
};
var LRUCache_default = LRUCache;

// node_modules/ol/tilecoord.js
function createOrUpdate2(z, x, y, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function getCacheKeyForTileKey(tileKey) {
  const [z, x, y] = tileKey.substring(tileKey.lastIndexOf("/") + 1, tileKey.length).split(",").map(Number);
  return getKeyZXY(z, x, y);
}
function fromKey(key) {
  return key.split("/").map(Number);
}
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}

// node_modules/ol/TileCache.js
var TileCache = class extends LRUCache_default {
  clear() {
    while (this.getCount() > 0) {
      this.pop().release();
    }
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(usedTiles) {
    while (this.canExpireCache()) {
      const tile2 = this.peekLast();
      if (tile2.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0) {
      return;
    }
    const key = this.peekFirstKey();
    const tileCoord = fromKey(key);
    const z = tileCoord[0];
    this.forEach((tile2) => {
      if (tile2.tileCoord[0] !== z) {
        this.remove(getKey(tile2.tileCoord));
        tile2.release();
      }
    });
  }
};
var TileCache_default = TileCache;

// node_modules/ol/source/TileEventType.js
var TileEventType_default = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};

// node_modules/ol/TileRange.js
var TileRange = class {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  }
};
function createOrUpdate3(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var TileRange_default = TileRange;

// node_modules/ol/tilegrid/TileGrid.js
init_common();
init_asserts();
init_math();
init_extent();
init_intersectsextent();
init_array();
init_size();
var tmpTileCoord = [0, 0, 0];
var DECIMALS = 5;
var TileGrid = class {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(
      isSorted(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (a, b) => b - a,
        true
      ),
      "`resolutions` must be sorted in descending order"
    );
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      );
    }
    const extent = options.extent;
    if (extent !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent);
    }
    assert(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    );
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      );
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    );
    this.extent_ = extent !== void 0 ? extent : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map((size, z) => {
        const tileRange = new TileRange_default(
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      });
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (x !== void 0 && y !== void 0) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = createOrUpdate3(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return createOrUpdate3(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }
    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];
    if (z === tileCoordZ) {
      return createOrUpdate3(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }
    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return createOrUpdate3(minX, minX, minY, minY, tempTileRange);
      }
      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate3(minX, maxX, minY, maxY, tempTileRange);
    }
    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return createOrUpdate3(minX, maxX, minY, maxY, tempTileRange);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    const z = this.getZForResolution(resolution);
    const scale5 = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = scale5 * (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = scale5 * (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate2(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate2(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    }
    return this.fullTileRanges_[z];
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = linearFindNearest(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return clamp(z, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return intersectsLinearRing(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
};
var TileGrid_default = TileGrid;

// node_modules/ol/tilegrid.js
init_common();
init_proj();
init_extent();
init_size();
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX3(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid_default({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function createXYZ(options) {
  const xyzOptions = options || {};
  const extent = xyzOptions.extent || get3("EPSG:3857").getExtent();
  const gridOptions = {
    extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    )
  };
  return new TileGrid_default(gridOptions);
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get3(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }
  return extent;
}

// node_modules/ol/source/Tile.js
init_Event();
init_Source();
init_util();
init_asserts();
init_proj();
init_size();
var TileSource = class extends Source_default {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tileCache = new TileCache_default(options.cacheSize || 0);
    this.tmpSize = [0, 0];
    this.key_ = options.key || "";
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(projection, z, tileRange, callback) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }
    let covered = true;
    let tile2, tileCoordKey, loaded;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = getKeyZXY(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile2 = /** @type {!import("../Tile.js").default} */
          tileCache.get(tileCoordKey);
          loaded = tile2.getState() === TileState_default.LOADED;
          if (loaded) {
            loaded = callback(tile2) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return abstract();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(projection) {
    const sourceProjection = this.getProjection();
    assert(
      sourceProjection === null || equivalent(sourceProjection, projection),
      "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
    );
    return this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale4(tileSize, tilePixelRatio, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX3(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear();
    super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(tileCount, projection) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(z, x, y, projection) {
  }
};
var TileSourceEvent = class extends Event_default {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile2) {
    super(type);
    this.tile = tile2;
  }
};
var Tile_default3 = TileSource;

// node_modules/ol/tileurlfunction.js
init_math();
function createFromTemplate(template, tileGrid) {
  const zRegEx = /\{z\}/g;
  const xRegEx = /\{x\}/g;
  const yRegEx = /\{y\}/g;
  const dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
        const z = tileCoord[0];
        const range = tileGrid.getFullTileRange(z);
        if (!range) {
          throw new Error(
            "The {-y} placeholder requires a tile grid with extent"
          );
        }
        const y = range.getHeight() - tileCoord[2] - 1;
        return y.toString();
      });
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const h = hash(tileCoord);
      const index = modulo(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return void 0;
}
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

// node_modules/ol/source/UrlTile.js
init_util();
var UrlTile = class _UrlTile extends Tile_default3 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.generateTileUrlFunction_ = this.tileUrlFunction === _UrlTile.prototype.tileUrlFunction;
    this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }
    this.urls = null;
    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile2 = (
      /** @type {import("../Tile.js").default} */
      event.target
    );
    const uid = getUid(tile2);
    const tileState = tile2.getState();
    let type;
    if (tileState == TileState_default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = TileEventType_default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile2));
    }
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return void 0;
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(z, x, y) {
    const tileCoordKey = getKeyZXY(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  }
};
var UrlTile_default = UrlTile;

// node_modules/ol/source/TileImage.js
init_EventType();
init_proj();
init_util();
var TileImage = class extends UrlTile_default {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile_default;
    this.tileCacheForProjection = {};
    this.tileGridForProjection = {};
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    this.renderReprojectionEdges_ = false;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache()) {
      return true;
    }
    for (const key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
    return false;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(
      this.tileCache == usedTileCache ? usedTiles : {}
    );
    for (const id in this.tileCacheForProjection) {
      const tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    }
    return this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return false;
    }
    return super.getOpaque(projection);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || equivalent(thisProj, projection)) {
      return this.tileCache;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new TileCache_default(
        this.tileCache.highWaterMark
      );
    }
    return this.tileCacheForProjection[projKey];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    const tile2 = new this.tileClass(
      tileCoord,
      tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY,
      tileUrl !== void 0 ? tileUrl : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile2.key = key;
    tile2.addEventListener(EventType_default.CHANGE, this.handleTileChange.bind(this));
    return tile2;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const cache3 = this.getTileCacheForProjection(projection);
    const tileCoord = [z, x, y];
    let tile2;
    const tileCoordKey = getKey(tileCoord);
    if (cache3.containsKey(tileCoordKey)) {
      tile2 = cache3.get(tileCoordKey);
    }
    const key = this.getKey();
    if (tile2 && tile2.key == key) {
      return tile2;
    }
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const newTile = new Tile_default2(
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z2, x2, y2, pixelRatio2) => this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    newTile.key = key;
    if (tile2) {
      newTile.interimTile = tile2;
      newTile.refreshInterimChain();
      cache3.replace(tileCoordKey, newTile);
    } else {
      cache3.set(tileCoordKey, newTile);
    }
    return newTile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    let tile2 = null;
    const tileCoordKey = getKeyZXY(z, x, y);
    const key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile2 = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile2);
    } else {
      tile2 = this.tileCache.get(tileCoordKey);
      if (tile2.key != key) {
        const interimTile = tile2;
        tile2 = this.createTile_(z, x, y, pixelRatio, projection, key);
        if (interimTile.getState() == TileState_default.IDLE) {
          tile2.interimTile = interimTile.interimTile;
        } else {
          tile2.interimTile = interimTile;
        }
        tile2.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile2);
      }
    }
    return tile2;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render2) {
    if (this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = get3(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
  clear() {
    super.clear();
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
  }
};
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage_default = TileImage;

// node_modules/ol/source/XYZ.js
var XYZ = class extends TileImage_default {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(options) {
    options = options || {};
    const projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
    const tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
      extent: extentFromProjection(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: options.opaque,
      projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
};
var XYZ_default = XYZ;

// node_modules/ol/source/OSM.js
var ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
var OSM = class extends XYZ_default {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(options) {
    options = options || {};
    let attributions;
    if (options.attributions !== void 0) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }
    const crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    const url = options.url !== void 0 ? options.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
      opaque: options.opaque !== void 0 ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    });
  }
};
var OSM_default = OSM;

// node_modules/ol/layer/TileProperty.js
var TileProperty_default = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

// node_modules/ol/layer/BaseTile.js
init_Layer();
var BaseTileLayer = class extends Layer_default {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.setPreload(options.preload !== void 0 ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(TileProperty_default.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(pixel) {
    return super.getData(pixel);
  }
};
var BaseTile_default = BaseTileLayer;

// node_modules/ol/renderer/canvas/TileLayer.js
init_Layer3();
init_transform();
init_array();
init_extent();
init_proj();
init_util();
init_size();
var CanvasTileLayerRenderer = class extends Layer_default3 {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(tileLayer) {
    super(tileLayer);
    this.extentChanged = true;
    this.renderedExtent_ = null;
    this.renderedPixelRatio;
    this.renderedProjection = null;
    this.renderedRevision;
    this.renderedTiles = [];
    this.newTiles_ = false;
    this.tmpExtent = createEmpty();
    this.tmpTileRange_ = new TileRange_default(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(tile2) {
    const tileLayer = this.getLayer();
    const tileState = tile2.getState();
    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState_default.LOADED || tileState == TileState_default.EMPTY || tileState == TileState_default.ERROR && !useInterimTilesOnError;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(z, x, y, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    let tile2 = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile2.getState() == TileState_default.ERROR) {
      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile2)) {
      tile2 = tile2.getInterimTile();
    }
    return tile2;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile2 = source.getTile(
        z,
        tileCoord[1],
        tileCoord[2],
        pixelRatio,
        projection
      );
      if (!(tile2 instanceof ImageTile_default || tile2 instanceof Tile_default2) || tile2 instanceof Tile_default2 && tile2.getState() === TileState_default.EMPTY) {
        return null;
      }
      if (tile2.getState() !== TileState_default.LOADED) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = toSize(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);
      const col = Math.floor(
        tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
      );
      const row = Math.floor(
        tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
      );
      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );
      return this.getImageData(tile2.getImage(), col + gutter, row + gutter);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(tiles, zoom, tile2) {
    if (this.isDrawableTile(tile2)) {
      return super.loadedTileCallback(tiles, zoom, tile2);
    }
    return false;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const rotation = viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);
    let extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    this.prepareContainer(frameState, target);
    const width = this.context.canvas.width;
    const height = this.context.canvas.height;
    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
    if (layerExtent) {
      extent = getIntersection(
        extent,
        fromUserExtent(layerState.extent, projection)
      );
    }
    const dx = tileResolution * width / 2 / tilePixelRatio;
    const dy = tileResolution * height / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    const tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    const findLoadedTiles = this.createLoadedTileFinder(
      tileSource,
      projection,
      tilesToDrawByZ
    );
    const tmpExtent2 = this.tmpExtent;
    const tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    const viewport = rotation ? getRotatedViewport(
      viewState.center,
      resolution,
      rotation,
      frameState.size
    ) : void 0;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
          continue;
        }
        const tile2 = this.getTile(z, x, y, frameState);
        if (this.isDrawableTile(tile2)) {
          const uid = getUid(this);
          if (tile2.getState() == TileState_default.LOADED) {
            tilesToDrawByZ[z][tile2.tileCoord.toString()] = tile2;
            let inTransition = tile2.inTransition(uid);
            if (inTransition && layerState.opacity !== 1) {
              tile2.endTransition(uid);
              inTransition = false;
            }
            if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile2))) {
              this.newTiles_ = true;
            }
          }
          if (tile2.getAlpha(uid, frameState.time) === 1) {
            continue;
          }
        }
        const childTileRange = tileGrid.getTileCoordChildTileRange(
          tile2.tileCoord,
          tmpTileRange,
          tmpExtent2
        );
        let covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile2.tileCoord,
            findLoadedTiles,
            tmpTileRange,
            tmpExtent2
          );
        }
      }
    }
    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
    const context = this.getRenderContext(frameState);
    compose(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );
    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }
    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    let zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(ascending);
    let clips, clipZs, currentClip;
    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        getTopLeft(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = apply(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      const tilesToDraw = tilesToDrawByZ[currentZ];
      for (const tileCoordKey in tilesToDraw) {
        const tile2 = (
          /** @type {import("../../ImageTile.js").default} */
          tilesToDraw[tileCoordKey]
        );
        const tileCoord = tile2.tileCoord;
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
        const x = Math.round(origin[0] - xIndex * dx2);
        const y = Math.round(origin[1] - yIndex * dy2);
        const w = nextX - x;
        const h = nextY - y;
        const transition = z === currentZ;
        const inTransition = transition && tile2.getAlpha(getUid(this), frameState.time) !== 1;
        let contextSaved = false;
        if (!inTransition) {
          if (clips) {
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
            for (let i2 = 0, ii = clips.length; i2 < ii; ++i2) {
              if (z !== currentZ && currentZ < clipZs[i2]) {
                const clip = clips[i2];
                if (intersects(
                  [x, y, x + w, y + h],
                  [clip[0], clip[3], clip[4], clip[7]]
                )) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }
                  context.beginPath();
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }
        this.drawTileImage(
          tile2,
          frameState,
          x,
          y,
          w,
          h,
          tileGutter,
          transition
        );
        if (clips && !inTransition) {
          if (contextSaved) {
            context.restore();
          }
          this.renderedTiles.unshift(tile2);
        } else {
          this.renderedTiles.push(tile2);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile2);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals2(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(
      frameState,
      tileSource,
      tileGrid,
      pixelRatio,
      projection,
      extent,
      z,
      tileLayer.getPreload()
    );
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(this.context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;
    return this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(tile2, frameState, x, y, w, h, gutter, transition) {
    const image = this.getTileImage(tile2);
    if (!image) {
      return;
    }
    const context = this.getRenderContext(frameState);
    const uid = getUid(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha = layerState.opacity * (transition ? tile2.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== context.globalAlpha;
    if (alphaChanged) {
      context.save();
      context.globalAlpha = alpha;
    }
    context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );
    if (alphaChanged) {
      context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile2.endTransition(uid);
    }
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile2) {
    return tile2.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      const postRenderFunction = function(tileSource2, map, frameState2) {
        const tileSourceKey = getUid(tileSource2);
        if (tileSourceKey in frameState2.usedTiles) {
          tileSource2.expireCache(
            frameState2.viewState.projection,
            frameState2.usedTiles[tileSourceKey]
          );
        }
      }.bind(null, tileSource);
      frameState.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        postRenderFunction
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile2) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile2.getKey()] = true;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const tileQueue = frameState.tileQueue;
    const minZoom = tileGrid.getMinZoom();
    const rotation = frameState.viewState.rotation;
    const viewport = rotation ? getRotatedViewport(
      frameState.viewState.center,
      frameState.viewState.resolution,
      rotation,
      frameState.size
    ) : void 0;
    let tileCount = 0;
    let tile2, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
            continue;
          }
          if (currentZ - z <= preload) {
            ++tileCount;
            tile2 = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile2.getState() == TileState_default.IDLE) {
              wantedTiles[tile2.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile2.getKey())) {
                tileQueue.enqueue([
                  tile2,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile2.tileCoord),
                  tileResolution
                ]);
              }
            }
            if (tileCallback !== void 0) {
              tileCallback(tile2);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  }
};
var TileLayer_default = CanvasTileLayerRenderer;

// node_modules/ol/layer/Tile.js
var TileLayer = class extends BaseTile_default {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }
  createRenderer() {
    return new TileLayer_default(this);
  }
};
var Tile_default4 = TileLayer;

// node_modules/ol/control.js
init_Control();

// node_modules/ol/index.js
init_Collection();
init_Disposable();
init_Feature();
init_Image2();
init_Image2();
init_Object();
init_Observable();
init_View();
init_util();

// resources/js/index.ts
init_View();
init_coordinate();
init_proj();
init_Vector2();
init_Vector();
init_geom();
var import_ol_geocoder = __toESM(require_ol_geocoder(), 1);
init_style2();
window["traineratwot"] = {};
var mPoint = class {
  constructor(view, projection) {
    this.view = view;
    this.projection = projection;
  }
  onChange(callback) {
    try {
      this.view.on("change", () => {
        const [lat, lon] = this.getCoordinates();
        callback(lat, lon);
      });
    } catch (e) {
      console.error(e);
    }
  }
  getCoordinates() {
    return this.view.getCenter();
  }
  setCoordinates(lat, lon) {
    this.view.setCenter(fromLonLat([lat, lon], this.projection));
  }
};
function GetPointMap(id, lat = 0, lon = 0, zoom = 10, lang = "en-US") {
  const projection = "EPSG:4326";
  const mousePositionControl = new MousePosition_default({
    coordinateFormat: createStringXY(4),
    projection,
    className: `mouse-position-${id}`,
    target: document.getElementById(`OSMap-${id}`)
  });
  let point = new Feature_default({
    projection,
    geometry: new Point_default(fromLonLat([lat, lon], projection))
  });
  const vectorSource = new Vector_default2({
    features: [point]
  });
  const vectorLayer = new Vector_default({
    source: vectorSource
  });
  const MapLayer = new Tile_default4({
    source: new OSM_default()
  });
  const target = document.getElementById(`OSMap-${id}`);
  const view = new View_default({
    projection,
    center: fromLonLat([lat, lon], projection),
    zoom
  });
  const map = new Map_default2({
    controls: defaults().extend([mousePositionControl]),
    layers: [
      MapLayer,
      vectorLayer
    ],
    target,
    view
  });
  const geocoder = new import_ol_geocoder.default("nominatim", {
    provider: "osm",
    lang,
    //en-US, fr-FR
    placeholder: "\u041F\u043E\u0438\u0441\u043A...",
    limit: 5,
    keepOpen: true
  });
  map.addControl(geocoder);
  try {
    geocoder.on("addresschosen", function(evt) {
      console.log(evt);
      const feature = evt.feature;
      const coordinate = evt.coordinate;
      feature.setStyle(new Style_default({
        image: new Icon_default({
          color: "rgba(0, 0, 0, 0)",
          crossOrigin: "anonymous",
          src: "https://openlayers.org/en/latest/examples/data/dot.png",
          scale: 0.01
        })
      }));
      view.setCenter(fromLonLat([coordinate[0], coordinate[1]], projection));
    });
  } catch (e) {
    console.error(e);
  }
  function updateCenter() {
    const [lat2, lon2] = map.getView().getCenter();
    point.getGeometry().setCoordinates([lat2, lon2]);
  }
  try {
    map.on("movestart", updateCenter);
    map.on("moveend", updateCenter);
  } catch (e) {
    console.warn(e);
  }
  target.classList.add("map-done");
  return new mPoint(view, projection);
}
window["traineratwot"].GetPointMap = GetPointMap;
/*! Bundled license information:

ol-geocoder/dist/ol-geocoder.js:
  (*!
   * ol-geocoder - v4.3.1
   * A geocoder extension compatible with OpenLayers v6.x, v7.x & v8.x
   * https://github.com/Dominique92/ol-geocoder
   * Built: 15/09/2023 16:57:41
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0RXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9EaXNwb3NhYmxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZnVuY3Rpb25zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9vYmouanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9UYXJnZXQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudFR5cGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JzZXJ2YWJsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvdXRpbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9Qcm9wZXJ0eS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvYXNzZXJ0cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbWF0aC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0V2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVmlld0hpbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL1ZpZXdQcm9wZXJ0eS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQvY29tbW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1VuaXRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1Byb2plY3Rpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzM4NTcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzQzMjYuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovcHJvamVjdGlvbnMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovdHJhbnNmb3Jtcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHJpbmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2Nvb3JkaW5hdGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NwaGVyZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29uc29sZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcHJvai5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY2VudGVyY29uc3RyYWludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVzb2x1dGlvbmNvbnN0cmFpbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JvdGF0aW9uY29uc3RyYWludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZWFzaW5nLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC90cmFuc2Zvcm0uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC90cmFuc2Zvcm0uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vR2VvbWV0cnkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vU2ltcGxlR2VvbWV0cnkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jbG9zZXN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2FyZWEuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vTGluZWFyUmluZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9Qb2ludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2NvbnRhaW5zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NlZ21lbnRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3JldmVyc2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9vcmllbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vUG9seWdvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVmlldy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yYnVzaC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VTdGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc2l6ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSW1hZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL3JnYi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3Itc3BhY2UveHl6LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9sdXYuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL2xjaHV2LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1wYXJzZS9ub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3ItcGFyc2UvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL2hzbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3ItcmdiYS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29sb3IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2hhcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZG9tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9JbWFnZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbkltYWdlQ2FjaGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ljb25JbWFnZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29sb3JsaWtlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jc3MuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1JlZ3VsYXJTaGFwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvQ2lyY2xlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9GaWxsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9TdHJva2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1N0eWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JY29uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9UZXh0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9leHByL2V4cHJlc3Npb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V4cHIvY3B1LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL3N0eWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9CYXNlVmVjdG9yLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvRXZlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcEV2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Db250cm9sLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU291cmNlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9MYXllci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9aSW5kZXhDb250ZXh0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9jYW52YXMvTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL0ZlYXR1cmUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9pbnRlcnBvbGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2xlbmd0aC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9MaW5lU3RyaW5nLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0luc3RydWN0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvVmVjdG9yQ29udGV4dC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9CdWlsZGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0ltYWdlQnVpbGRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9MaW5lU3RyaW5nQnVpbGRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9Qb2x5Z29uQnVpbGRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2xpbmVjaHVuay5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3N0cmFpZ2h0Y2h1bmsuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvVGV4dEJ1aWxkZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvdGV4dHBhdGguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvRXhlY3V0b3IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvRXhlY3V0b3JHcm91cC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL2hpdGRldGVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvdmVjdG9yLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1ZlY3Rvci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3RydWN0cy9SQnVzaC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9DaXJjbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL011bHRpTGluZVN0cmluZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9NdWx0aVBvaW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvY2VudGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL011bHRpUG9seWdvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0ZlYXR1cmUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9WZWN0b3JFdmVudFR5cGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xvYWRpbmdzdHJhdGVneS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZmVhdHVyZWxvYWRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1ZlY3Rvci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIva29uc3RhbnRzL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvaGVscGVycy9taXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9oZWxwZXJzL2RvbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL2h0bWwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9oZWxwZXJzL2FqYXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9wcm92aWRlcnMvcGhvdG9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvcHJvdmlkZXJzL29zbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL3Byb3ZpZGVycy9tYXBxdWVzdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL3Byb3ZpZGVycy9iaW5nLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvcHJvdmlkZXJzL29wZW5jYWdlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvbm9taW5hdGltLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvYmFzZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvTWFwLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9Db21wb3NpdGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0dyb3VwLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9NYXBFdmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL0V2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50SGFuZGxlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwUHJvcGVydHkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZVN0YXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9UaWxlUXVldWUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvQXR0cmlidXRpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvUm90YXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1pvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvZGVmYXVsdHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1Byb3BlcnR5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Qb2ludGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvY29uZGl0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvQm94LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnQm94LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnWm9vbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0tleS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW4uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvS2luZXRpYy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFpvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL2RlZmF1bHRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9NYXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvTW91c2VQb3NpdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VUaWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovY29tbW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVHJpYW5ndWxhdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVGlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3RydWN0cy9MUlVDYWNoZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvdGlsZWNvb3JkLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9UaWxlQ2FjaGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlRXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9UaWxlUmFuZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkL1RpbGVHcmlkLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3RpbGV1cmxmdW5jdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1VybFRpbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlSW1hZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9YWVouanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9PU00uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1RpbGVQcm9wZXJ0eS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZVRpbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1RpbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2luZGV4LmpzIiwgIi4uL2pzL2luZGV4LnRzIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlFTyxTQUFTLGdCQUFnQixLQUFLO0FBQ25DLE1BQUksZ0JBQWdCO0FBQ3RCO0FBS08sU0FBUyxlQUFlLEtBQUs7QUFDbEMsTUFBSSxlQUFlO0FBQ3JCO0FBMUVBLElBY00sV0E4REM7QUE1RVA7QUFBQTtBQWNBLElBQU0sWUFBTixNQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSWQsWUFBWSxNQUFNO0FBSWhCLGFBQUs7QUFLTCxhQUFLO0FBT0wsYUFBSyxPQUFPO0FBT1osYUFBSyxTQUFTO0FBQUEsTUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxpQkFBaUI7QUFDZixhQUFLLG1CQUFtQjtBQUFBLE1BQzFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGtCQUFrQjtBQUNoQixhQUFLLHFCQUFxQjtBQUFBLE1BQzVCO0FBQUEsSUFDRjtBQWdCQSxJQUFPLGdCQUFRO0FBQUE7QUFBQTs7O0FDNUVmLElBT087QUFQUDtBQUFBO0FBT0EsSUFBTywwQkFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1iLGdCQUFnQjtBQUFBLElBQ2xCO0FBQUE7QUFBQTs7O0FDZEEsSUFRTSxZQTJCQztBQW5DUDtBQUFBO0FBUUEsSUFBTSxhQUFOLE1BQWlCO0FBQUEsTUFDZixjQUFjO0FBTVosYUFBSyxXQUFXO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFVBQVU7QUFDUixZQUFJ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LEtBQUssR0FBRztBQUFBLE1BQzlCLGlCQUFpQixDQUFDLElBQUksSUFBSSxHQUFHO0FBQUEsTUFDN0IsaUJBQWlCLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFBQSxNQUM1QixpQkFBaUIsQ0FBQyxJQUFJLElBQUksRUFBRTtBQUFBLE1BQzVCLGlCQUFpQixDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDN0IsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHO0FBQUEsTUFDMUIsWUFBWSxDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDekIsZUFBZSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDM0IsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsY0FBYyxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDekIsZUFBZSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDN0IsZUFBZSxDQUFDLElBQUksS0FBSyxFQUFFO0FBQUEsTUFDM0IsV0FBVyxDQUFDLEtBQUssR0FBRyxHQUFHO0FBQUEsTUFDdkIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsUUFBUSxDQUFDLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFDcEIsYUFBYSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDMUIsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsU0FBUyxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQUEsTUFDbkIsZUFBZSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDNUIsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsYUFBYSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDekIsVUFBVSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsTUFDckIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsaUJBQWlCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUMvQixhQUFhLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxNQUN6QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLHdCQUF3QixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEMsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsZUFBZSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDN0IsaUJBQWlCLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxNQUM5QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGtCQUFrQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDaEMsa0JBQWtCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUNoQyxrQkFBa0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ2hDLGVBQWUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzdCLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztBQUFBLE1BQ2xCLGFBQWEsQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUFBLE1BQ3pCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3ZCLFdBQVcsQ0FBQyxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQ3ZCLFVBQVUsQ0FBQyxLQUFLLEdBQUcsQ0FBQztBQUFBLE1BQ3BCLG9CQUFvQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDbEMsY0FBYyxDQUFDLEdBQUcsR0FBRyxHQUFHO0FBQUEsTUFDeEIsZ0JBQWdCLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxNQUM3QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGtCQUFrQixDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDL0IsbUJBQW1CLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUNqQyxxQkFBcUIsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQ2pDLG1CQUFtQixDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDaEMsbUJBQW1CLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxNQUNoQyxnQkFBZ0IsQ0FBQyxJQUFJLElBQUksR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLFlBQVksQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzFCLGVBQWUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzdCLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztBQUFBLE1BQ2xCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3pCLFNBQVMsQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ3JCLGFBQWEsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQzFCLFVBQVUsQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ3RCLGFBQWEsQ0FBQyxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ3hCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3hCLGlCQUFpQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDL0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsaUJBQWlCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUMvQixpQkFBaUIsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQy9CLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQ3JCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLFVBQVUsQ0FBQyxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQ3RCLGlCQUFpQixDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDOUIsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDO0FBQUEsTUFDakIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDMUIsZUFBZSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDM0IsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsY0FBYyxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDM0IsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFO0FBQUEsTUFDeEIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDdEIsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsYUFBYSxDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDMUIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsZUFBZSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDMUIsT0FBTyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDckIsUUFBUSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDcEIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDdEIsYUFBYSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDMUIsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsVUFBVSxDQUFDLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFDdEIsZUFBZSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsSUFDN0I7QUFBQTtBQUFBOzs7QUM3SEEsU0FBUyxNQUFNLE1BQU07QUFDcEIsTUFBSSxHQUFHLFFBQVEsQ0FBQyxHQUFHLFFBQVEsR0FBRztBQUc5QixNQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzdCLFdBQU8sRUFBRSxPQUFPLE9BQU8sUUFBUSxDQUFDLFNBQVMsS0FBSyxPQUFPLFdBQWMsR0FBRyxPQUFPLEdBQVEsR0FBRyxPQUFPLEVBQUU7QUFBQSxFQUNsRztBQUNBLE1BQUksT0FBTyxTQUFTO0FBQVUsV0FBTyxFQUFFLE9BQU8sT0FBTyxRQUFRLENBQUMsU0FBUyxLQUFLLE9BQU8sV0FBYyxHQUFHLE9BQU8sR0FBUSxHQUFHLE9BQU8sRUFBRTtBQUUvSCxTQUFPLE9BQU8sSUFBSSxFQUFFLFlBQVk7QUFHaEMsTUFBSSxrQkFBQUMsUUFBTSxJQUFJLEdBQUc7QUFDaEIsWUFBUSxrQkFBQUEsUUFBTSxJQUFJLEVBQUUsTUFBTTtBQUMxQixZQUFRO0FBQUEsRUFDVCxXQUdTLFNBQVMsZUFBZTtBQUNoQyxZQUFRO0FBQ1IsWUFBUTtBQUNSLFlBQVEsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLEVBQ2pCLFdBR1MsS0FBSyxDQUFDLE1BQU0sS0FBSztBQUN6QixRQUFJLE9BQU8sS0FBSyxNQUFNLENBQUM7QUFDdkIsUUFBSSxPQUFPLEtBQUs7QUFDaEIsUUFBSSxVQUFVLFFBQVE7QUFDdEIsWUFBUTtBQUVSLFFBQUksU0FBUztBQUNaLGNBQVE7QUFBQSxRQUNQLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUFBLFFBQzlCLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUFBLFFBQzlCLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUFBLE1BQy9CO0FBQ0EsVUFBSSxTQUFTLEdBQUc7QUFDZixnQkFBUSxTQUFTLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSTtBQUFBLE1BQzNDO0FBQUEsSUFDRCxPQUNLO0FBQ0osY0FBUTtBQUFBLFFBQ1AsU0FBUyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQUEsUUFDOUIsU0FBUyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQUEsUUFDOUIsU0FBUyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQUEsTUFDL0I7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNmLGdCQUFRLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRSxJQUFJO0FBQUEsTUFDM0M7QUFBQSxJQUNEO0FBRUEsUUFBSSxDQUFDLE1BQU0sQ0FBQztBQUFHLFlBQU0sQ0FBQyxJQUFJO0FBQzFCLFFBQUksQ0FBQyxNQUFNLENBQUM7QUFBRyxZQUFNLENBQUMsSUFBSTtBQUMxQixRQUFJLENBQUMsTUFBTSxDQUFDO0FBQUcsWUFBTSxDQUFDLElBQUk7QUFFMUIsWUFBUTtBQUFBLEVBQ1QsV0FHUyxJQUFJLHlHQUF5RyxLQUFLLElBQUksR0FBRztBQUNqSSxRQUFJLE9BQU8sRUFBRSxDQUFDO0FBQ2QsWUFBUSxLQUFLLFFBQVEsTUFBTSxFQUFFO0FBQzdCLFFBQUksT0FBTyxVQUFVLFNBQVMsSUFBSSxVQUFVLFNBQVMsSUFBSTtBQUN6RCxZQUFRLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLGlCQUFpQjtBQUczQyxRQUFJLFVBQVU7QUFBUyxjQUFRLE1BQU0sTUFBTTtBQUUzQyxZQUFRLE1BQU0sSUFBSSxTQUFVLEdBQUcsR0FBRztBQUVqQyxVQUFJLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBTSxLQUFLO0FBQzVCLFlBQUksV0FBVyxDQUFDLElBQUk7QUFFcEIsWUFBSSxNQUFNO0FBQUcsaUJBQU87QUFFcEIsWUFBSSxVQUFVO0FBQU8saUJBQU8sSUFBSTtBQUVoQyxZQUFJLE1BQU0sQ0FBQyxNQUFNO0FBQUssaUJBQU8sSUFBSTtBQUVqQyxZQUFJLE1BQU0sQ0FBQyxNQUFNLE9BQU8sQ0FBQztBQUFHLGlCQUFPLElBQUk7QUFFdkMsWUFBSSxVQUFVO0FBQU8saUJBQU8sSUFBSTtBQUVoQyxZQUFJLFVBQVU7QUFBTyxpQkFBTyxJQUFJLElBQUksSUFBSSxNQUFNLElBQUk7QUFFbEQsWUFBSSxNQUFNLENBQUMsTUFBTSxPQUFPLENBQUM7QUFBRyxpQkFBTztBQUVuQyxZQUFJLFVBQVU7QUFBUyxpQkFBTyxJQUFJO0FBRWxDLFlBQUksVUFBVTtBQUFTLGlCQUFPLElBQUksSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUVwRCxlQUFPO0FBQUEsTUFDUjtBQUdBLFVBQUksTUFBTSxDQUFDLE1BQU0sT0FBUSxNQUFNLEtBQUssTUFBTSxNQUFNLFNBQVMsQ0FBQyxNQUFNLEtBQU07QUFFckUsWUFBSSxTQUFTLENBQUMsTUFBTTtBQUFXLGlCQUFPLFNBQVMsQ0FBQztBQUVoRCxZQUFJLEVBQUUsU0FBUyxLQUFLO0FBQUcsaUJBQU8sV0FBVyxDQUFDO0FBRTFDLFlBQUksRUFBRSxTQUFTLE1BQU07QUFBRyxpQkFBTyxXQUFXLENBQUMsSUFBSTtBQUMvQyxZQUFJLEVBQUUsU0FBUyxNQUFNO0FBQUcsaUJBQU8sV0FBVyxDQUFDLElBQUksTUFBTTtBQUNyRCxZQUFJLEVBQUUsU0FBUyxLQUFLO0FBQUcsaUJBQU8sV0FBVyxDQUFDLElBQUksTUFBTSxLQUFLO0FBQUEsTUFDMUQ7QUFDQSxVQUFJLE1BQU07QUFBUSxlQUFPO0FBQ3pCLGFBQU8sV0FBVyxDQUFDO0FBQUEsSUFDcEIsQ0FBQztBQUVELFlBQVEsTUFBTSxTQUFTLE9BQU8sTUFBTSxJQUFJLElBQUk7QUFBQSxFQUM3QyxXQUdTLG1CQUFtQixLQUFLLElBQUksR0FBRztBQUN2QyxZQUFRLEtBQUssTUFBTSxXQUFXLEVBQUUsSUFBSSxTQUFVLE9BQU87QUFDcEQsYUFBTyxXQUFXLEtBQUs7QUFBQSxJQUN4QixDQUFDO0FBRUQsWUFBUSxLQUFLLE1BQU0sV0FBVyxHQUFHLEtBQUssRUFBRSxHQUFHLFlBQVksS0FBSztBQUFBLEVBQzdEO0FBRUEsU0FBTztBQUFBLElBQ047QUFBQSxJQUNBLFFBQVE7QUFBQSxJQUNSO0FBQUEsRUFDRDtBQUNEO0FBekpBLElBR0EsbUJBRU8scUJBT0g7QUFaSjtBQUFBO0FBR0Esd0JBQWtCO0FBRWxCLElBQU8sc0JBQVE7QUFPZixJQUFJLFdBQVc7QUFBQSxNQUNkLEtBQUs7QUFBQSxNQUNMLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLE1BQU07QUFBQSxNQUNOLFFBQVE7QUFBQSxJQUNUO0FBQUE7QUFBQTs7O0FDbkJBLElBS087QUFMUDtBQUFBO0FBR0E7QUFFQSxJQUFPLGNBQVE7QUFBQSxNQUNkLE1BQU07QUFBQSxNQUNOLEtBQUssQ0FBQyxHQUFFLEdBQUUsQ0FBQztBQUFBLE1BQ1gsS0FBSyxDQUFDLEtBQUksS0FBSSxHQUFHO0FBQUEsTUFDakIsU0FBUyxDQUFDLE9BQU8sY0FBYyxXQUFXO0FBQUEsTUFDMUMsT0FBTyxDQUFDLEtBQUs7QUFBQSxNQUViLEtBQUssU0FBUyxLQUFLO0FBQ2xCLFlBQUksSUFBSSxJQUFJLENBQUMsSUFBRSxLQUFLLElBQUksSUFBSSxDQUFDLElBQUUsS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFFLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxLQUFLLElBQUU7QUFFNUUsWUFBSSxNQUFNO0FBQUcsaUJBQU8sTUFBTSxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssR0FBRztBQUVqRCxhQUFLLElBQUksTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJLElBQUksSUFBSTtBQUN6QyxhQUFLLElBQUksSUFBSTtBQUViLGNBQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNkLGVBQU0sSUFBRSxLQUFJO0FBQ1gsZUFBSyxJQUFJLElBQUksSUFBSSxFQUFHLElBQUk7QUFDeEIsZUFBSyxJQUFJLE9BQU8sS0FBSyxLQUFLO0FBQzFCLGdCQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksS0FDeEMsSUFBSSxLQUFLLElBQUksS0FDYixJQUFJLEtBQUssSUFBSyxNQUFNLEtBQUssT0FBTyxJQUFJLElBQUksTUFBTSxJQUM5QztBQUNBLGNBQUksR0FBRyxJQUFJLE1BQU07QUFBQSxRQUNsQjtBQUVBLGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRDtBQUlBLGdCQUFJLE1BQU0sU0FBUyxLQUFLO0FBQ3ZCLFVBQUksSUFBSSxJQUFJLENBQUMsSUFBRSxLQUNiLElBQUksSUFBSSxDQUFDLElBQUUsS0FDWCxJQUFJLElBQUksQ0FBQyxJQUFFLEtBQ1gsTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHLENBQUMsR0FDdEIsTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHLENBQUMsR0FDdEIsUUFBUSxNQUFNLEtBQ2QsR0FBRyxHQUFHO0FBRVIsVUFBSSxRQUFRLEtBQUs7QUFDaEIsWUFBSTtBQUFBLE1BQ0wsV0FDUyxNQUFNLEtBQUs7QUFDbkIsYUFBSyxJQUFJLEtBQUs7QUFBQSxNQUNmLFdBQ1MsTUFBTSxLQUFLO0FBQ25CLFlBQUksS0FBSyxJQUFJLEtBQUs7QUFBQSxNQUNuQixXQUNTLE1BQU0sS0FBSztBQUNuQixZQUFJLEtBQUssSUFBSSxLQUFJO0FBQUEsTUFDbEI7QUFFQSxVQUFJLEtBQUssSUFBSSxJQUFJLElBQUksR0FBRztBQUV4QixVQUFJLElBQUksR0FBRztBQUNWLGFBQUs7QUFBQSxNQUNOO0FBRUEsV0FBSyxNQUFNLE9BQU87QUFFbEIsVUFBSSxRQUFRLEtBQUs7QUFDaEIsWUFBSTtBQUFBLE1BQ0wsV0FDUyxLQUFLLEtBQUs7QUFDbEIsWUFBSSxTQUFTLE1BQU07QUFBQSxNQUNwQixPQUNLO0FBQ0osWUFBSSxTQUFTLElBQUksTUFBTTtBQUFBLE1BQ3hCO0FBRUEsYUFBTyxDQUFDLEdBQUcsSUFBSSxLQUFLLElBQUksR0FBRztBQUFBLElBQzVCO0FBQUE7QUFBQTs7O0FDekVlLFNBQVIsS0FBc0IsT0FBTztBQUVuQyxNQUFJLE1BQU0sUUFBUSxLQUFLLEtBQUssTUFBTTtBQUFLLFlBQVEsT0FBTyxJQUFJLEdBQUcsU0FBUztBQUN0RSxNQUFJLGlCQUFpQjtBQUFRLFlBQVEsQ0FBQztBQUV0QyxNQUFJLFFBQVEsR0FBRztBQUdmLE1BQUksU0FBUyxvQkFBTSxLQUFLO0FBRXhCLE1BQUksQ0FBQyxPQUFPO0FBQU8sV0FBTyxDQUFDO0FBRTNCLFFBQU0sTUFBTSxPQUFPLE1BQU0sQ0FBQyxNQUFNLE1BQU0sWUFBSSxNQUFNLFlBQUk7QUFDcEQsUUFBTSxNQUFNLE9BQU8sTUFBTSxDQUFDLE1BQU0sTUFBTSxZQUFJLE1BQU0sWUFBSTtBQUVwRCxXQUFTLE1BQU0sQ0FBQztBQUNoQixTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUMvRCxTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUMvRCxTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUUvRCxNQUFJLE9BQU8sTUFBTSxDQUFDLE1BQU0sS0FBSztBQUM1QixhQUFTLFlBQUksSUFBSSxNQUFNO0FBQUEsRUFDeEI7QUFFQSxTQUFPLEtBQUssS0FBSyxJQUFJLEtBQUssSUFBSSxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUVsRCxTQUFPO0FBQ1I7QUFoQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7OztBQ3FCTyxTQUFTLFNBQVMsT0FBTztBQUM5QixNQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBT0MsVUFBUyxLQUFLO0FBQ3ZCO0FBMEJPLFNBQVMsVUFBVSxPQUFPO0FBQy9CLE1BQUksTUFBTSxXQUFXLEdBQUc7QUFDdEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLFNBQVMsTUFBTSxNQUFNO0FBQzNCLFNBQU8sQ0FBQyxJQUFJO0FBQ1osU0FBTztBQUNUO0FBTU8sU0FBUyxXQUFXLE9BQU87QUFDaEMsUUFBTSxTQUFTLFlBQUksTUFBTSxZQUFJLElBQUksS0FBSyxDQUFDO0FBQ3ZDLFNBQU8sQ0FBQyxJQUFJLE1BQU0sQ0FBQztBQUNuQixTQUFPO0FBQ1Q7QUFNTyxTQUFTLFdBQVcsT0FBTztBQUNoQyxRQUFNLFNBQVMsWUFBSSxJQUFJLGNBQU0sSUFBSSxLQUFLLENBQUM7QUFDdkMsU0FBTyxDQUFDLElBQUksTUFBTSxDQUFDO0FBQ25CLFNBQU87QUFDVDtBQU1PLFNBQVMsV0FBVyxHQUFHO0FBQzVCLE1BQUlDLE9BQU0sZUFBZSxDQUFDLEdBQUc7QUFDM0IsV0FBT0EsT0FBTSxDQUFDO0FBQUEsRUFDaEI7QUFDQSxNQUFJLGFBQWEsZ0JBQWdCO0FBQy9CLFFBQUksSUFBSTtBQUNSLGVBQVcsT0FBT0EsUUFBTztBQUN2QixXQUFLLE1BQU0sT0FBTyxHQUFHO0FBQ25CLGVBQU9BLE9BQU0sR0FBRztBQUNoQixVQUFFO0FBQUEsTUFDSjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUEsUUFBTSxRQUFRLEtBQVUsQ0FBQztBQUN6QixNQUFJLE1BQU0sV0FBVyxHQUFHO0FBQ3RCLFVBQU0sSUFBSSxNQUFNLHNCQUFzQixJQUFJLFlBQVk7QUFBQSxFQUN4RDtBQUNBLGFBQVcsS0FBSyxPQUFPO0FBQ3JCLFFBQUksTUFBTSxDQUFDLEdBQUc7QUFDWixZQUFNLElBQUksTUFBTSxzQkFBc0IsSUFBSSxZQUFZO0FBQUEsSUFDeEQ7QUFBQSxFQUNGO0FBQ0EsWUFBVSxLQUFLO0FBQ2YsRUFBQUEsT0FBTSxDQUFDLElBQUk7QUFDWCxJQUFFO0FBQ0YsU0FBTztBQUNUO0FBU08sU0FBUyxRQUFRLE9BQU87QUFDN0IsTUFBSSxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ3hCLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTyxXQUFXLEtBQUs7QUFDekI7QUFPTyxTQUFTLFVBQVUsT0FBTztBQUMvQixRQUFNLENBQUMsSUFBSSxNQUFPLE1BQU0sQ0FBQyxJQUFJLE1BQU8sR0FBRyxHQUFHLEdBQUc7QUFDN0MsUUFBTSxDQUFDLElBQUksTUFBTyxNQUFNLENBQUMsSUFBSSxNQUFPLEdBQUcsR0FBRyxHQUFHO0FBQzdDLFFBQU0sQ0FBQyxJQUFJLE1BQU8sTUFBTSxDQUFDLElBQUksTUFBTyxHQUFHLEdBQUcsR0FBRztBQUM3QyxRQUFNLENBQUMsSUFBSSxNQUFNLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMvQixTQUFPO0FBQ1Q7QUFNTyxTQUFTRCxVQUFTLE9BQU87QUFDOUIsTUFBSSxJQUFJLE1BQU0sQ0FBQztBQUNmLE1BQUksTUFBTSxJQUFJLElBQUk7QUFDaEIsUUFBSyxJQUFJLE1BQU87QUFBQSxFQUNsQjtBQUNBLE1BQUksSUFBSSxNQUFNLENBQUM7QUFDZixNQUFJLE1BQU0sSUFBSSxJQUFJO0FBQ2hCLFFBQUssSUFBSSxNQUFPO0FBQUEsRUFDbEI7QUFDQSxNQUFJLElBQUksTUFBTSxDQUFDO0FBQ2YsTUFBSSxNQUFNLElBQUksSUFBSTtBQUNoQixRQUFLLElBQUksTUFBTztBQUFBLEVBQ2xCO0FBQ0EsUUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLFNBQVksSUFBSSxLQUFLLE1BQU0sTUFBTSxDQUFDLElBQUksR0FBSSxJQUFJO0FBQ3JFLFNBQU8sVUFBVSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJO0FBQ3JEO0FBTU8sU0FBUyxjQUFjLEdBQUc7QUFDL0IsTUFBSTtBQUNGLGVBQVcsQ0FBQztBQUNaLFdBQU87QUFBQSxFQUNULFNBQVMsR0FBRztBQUNWLFdBQU87QUFBQSxFQUNUO0FBQ0Y7QUFoTEEsSUFrQ00sZ0JBUUFDLFFBS0Y7QUEvQ0o7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEyQkEsSUFBTSxpQkFBaUI7QUFRdkIsSUFBTUEsU0FBUSxDQUFDO0FBS2YsSUFBSSxZQUFZO0FBQUE7QUFBQTs7O0FDL0NoQixJQUlNLElBU08sU0FNQSxRQU1BLG1CQVNBLFFBTUEsS0FTQSxvQkFRQSx5QkFTQSxjQU9BLHFCQUtBO0FBOUViO0FBQUE7QUFJQSxJQUFNLEtBQ0osT0FBTyxjQUFjLGVBQWUsT0FBTyxVQUFVLGNBQWMsY0FDL0QsVUFBVSxVQUFVLFlBQVksSUFDaEM7QUFNQyxJQUFNLFVBQVUsR0FBRyxTQUFTLFNBQVM7QUFNckMsSUFBTSxTQUFTLEdBQUcsU0FBUyxRQUFRLEtBQUssQ0FBQyxHQUFHLFNBQVMsT0FBTztBQU01RCxJQUFNLG9CQUNYLFdBQ0MsR0FBRyxTQUFTLGNBQWMsS0FDekIsd0NBQXdDLEtBQUssRUFBRTtBQU01QyxJQUFNLFNBQVMsR0FBRyxTQUFTLFFBQVEsS0FBSyxDQUFDLEdBQUcsU0FBUyxNQUFNO0FBTTNELElBQU0sTUFBTSxHQUFHLFNBQVMsV0FBVztBQVNuQyxJQUFNLHFCQUNYLE9BQU8scUJBQXFCLGNBQWMsbUJBQW1CO0FBT3hELElBQU0sMEJBQ1gsT0FBTyxzQkFBc0IsZUFDN0IsT0FBTyxvQkFBb0IsZUFDM0IsZ0JBQWdCO0FBTVgsSUFBTSxlQUNYLE9BQU8sVUFBVSxlQUFlLE1BQU0sVUFBVTtBQU0zQyxJQUFNLHNCQUFzQixPQUFPLHNCQUFzQjtBQUt6RCxJQUFNLDBCQUEyQixXQUFZO0FBQ2xELFVBQUksVUFBVTtBQUNkLFVBQUk7QUFDRixjQUFNLFVBQVUsT0FBTyxlQUFlLENBQUMsR0FBRyxXQUFXO0FBQUEsVUFDbkQsS0FBSyxXQUFZO0FBQ2Ysc0JBQVU7QUFBQSxVQUNaO0FBQUEsUUFDRixDQUFDO0FBR0QsZUFBTyxpQkFBaUIsS0FBSyxNQUFNLE9BQU87QUFFMUMsZUFBTyxvQkFBb0IsS0FBSyxNQUFNLE9BQU87QUFBQSxNQUMvQyxTQUFTQyxRQUFPO0FBQUEsTUFFaEI7QUFDQSxhQUFPO0FBQUEsSUFDVCxFQUFHO0FBQUE7QUFBQTs7O0FDaEZJLFNBQVMsc0JBQXNCLE9BQU8sUUFBUUMsYUFBWSxVQUFVO0FBRXpFLE1BQUk7QUFDSixNQUFJQSxlQUFjQSxZQUFXLFFBQVE7QUFDbkM7QUFBQSxJQUEyQ0EsWUFBVyxNQUFNO0FBQUEsRUFDOUQsV0FBVyx5QkFBeUI7QUFDbEMsYUFBUyxJQUFJLGdCQUFnQixTQUFTLEtBQUssVUFBVSxHQUFHO0FBQUEsRUFDMUQsT0FBTztBQUNMLGFBQVMsU0FBUyxjQUFjLFFBQVE7QUFBQSxFQUMxQztBQUNBLE1BQUksT0FBTztBQUNULFdBQU8sUUFBUTtBQUFBLEVBQ2pCO0FBQ0EsTUFBSSxRQUFRO0FBQ1YsV0FBTyxTQUFTO0FBQUEsRUFDbEI7QUFFQTtBQUFBO0FBQUEsSUFDRSxPQUFPLFdBQVcsTUFBTSxRQUFRO0FBQUE7QUFFcEM7QUFRTyxTQUFTLDJCQUEyQjtBQUN6QyxNQUFJLENBQUMscUJBQXFCO0FBQ3hCLDBCQUFzQixzQkFBc0IsR0FBRyxDQUFDO0FBQUEsRUFDbEQ7QUFDQSxTQUFPO0FBQ1Q7QUFPTyxTQUFTLGNBQWMsU0FBUztBQUNyQyxRQUFNLFNBQVMsUUFBUTtBQUN2QixTQUFPLFFBQVE7QUFDZixTQUFPLFNBQVM7QUFDaEIsVUFBUSxVQUFVLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDOUI7QUFTTyxTQUFTLFdBQVcsU0FBUztBQUNsQyxNQUFJLFFBQVEsUUFBUTtBQUNwQixRQUFNLFFBQVEsaUJBQWlCLE9BQU87QUFDdEMsV0FBUyxTQUFTLE1BQU0sWUFBWSxFQUFFLElBQUksU0FBUyxNQUFNLGFBQWEsRUFBRTtBQUV4RSxTQUFPO0FBQ1Q7QUFTTyxTQUFTLFlBQVksU0FBUztBQUNuQyxNQUFJLFNBQVMsUUFBUTtBQUNyQixRQUFNLFFBQVEsaUJBQWlCLE9BQU87QUFDdEMsWUFBVSxTQUFTLE1BQU0sV0FBVyxFQUFFLElBQUksU0FBUyxNQUFNLGNBQWMsRUFBRTtBQUV6RSxTQUFPO0FBQ1Q7QUFNTyxTQUFTLFlBQVksU0FBUyxTQUFTO0FBQzVDLFFBQU0sU0FBUyxRQUFRO0FBQ3ZCLE1BQUksUUFBUTtBQUNWLFdBQU8sYUFBYSxTQUFTLE9BQU87QUFBQSxFQUN0QztBQUNGO0FBTU8sU0FBUyxXQUFXLE1BQU07QUFDL0IsU0FBTyxRQUFRLEtBQUssYUFBYSxLQUFLLFdBQVcsWUFBWSxJQUFJLElBQUk7QUFDdkU7QUFLTyxTQUFTLGVBQWUsTUFBTTtBQUNuQyxTQUFPLEtBQUssV0FBVztBQUNyQixTQUFLLFlBQVksS0FBSyxTQUFTO0FBQUEsRUFDakM7QUFDRjtBQVVPLFNBQVMsZ0JBQWdCLE1BQU0sVUFBVTtBQUM5QyxRQUFNLGNBQWMsS0FBSztBQUV6QixXQUFTLElBQUksR0FBRyxNQUFNLEVBQUUsR0FBRztBQUN6QixVQUFNLFdBQVcsWUFBWSxDQUFDO0FBQzlCLFVBQU0sV0FBVyxTQUFTLENBQUM7QUFHM0IsUUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVO0FBQzFCO0FBQUEsSUFDRjtBQUdBLFFBQUksYUFBYSxVQUFVO0FBQ3pCO0FBQUEsSUFDRjtBQUdBLFFBQUksQ0FBQyxVQUFVO0FBQ2IsV0FBSyxZQUFZLFFBQVE7QUFDekI7QUFBQSxJQUNGO0FBR0EsUUFBSSxDQUFDLFVBQVU7QUFDYixXQUFLLFlBQVksUUFBUTtBQUN6QixRQUFFO0FBQ0Y7QUFBQSxJQUNGO0FBR0EsU0FBSyxhQUFhLFVBQVUsUUFBUTtBQUFBLEVBQ3RDO0FBQ0Y7QUFqS0EsSUFzQ0k7QUF0Q0o7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDNk5PLFNBQVMsWUFBWSxPQUFPLGFBQWEsY0FBYztBQUM1RCxRQUFNO0FBQUE7QUFBQSxJQUF1QztBQUFBO0FBQzdDLE1BQUksWUFBWTtBQUNoQixNQUFJLFdBQVc7QUFDZixNQUFJLFNBQVM7QUFFYixRQUFNLGVBQWU7QUFBQSxJQUNuQixXQUFXLEtBQUssa0JBQVUsTUFBTSxXQUFZO0FBQzFDLGVBQVM7QUFDVCxVQUFJLENBQUMsVUFBVTtBQUNiLG9CQUFZO0FBQUEsTUFDZDtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFFQSxNQUFJLElBQUksT0FBTyxjQUFjO0FBQzNCLGVBQVc7QUFDWCxRQUNHLE9BQU8sRUFDUCxLQUFLLFdBQVk7QUFDaEIsVUFBSSxXQUFXO0FBQ2Isb0JBQVk7QUFBQSxNQUNkO0FBQUEsSUFDRixDQUFDLEVBQ0EsTUFBTSxTQUFVQyxRQUFPO0FBQ3RCLFVBQUksV0FBVztBQUNiLFlBQUksUUFBUTtBQUNWLHNCQUFZO0FBQUEsUUFDZCxPQUFPO0FBQ0wsdUJBQWE7QUFBQSxRQUNmO0FBQUEsTUFDRjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0wsT0FBTztBQUNMLGlCQUFhLEtBQUssV0FBVyxLQUFLLGtCQUFVLE9BQU8sWUFBWSxDQUFDO0FBQUEsRUFDbEU7QUFFQSxTQUFPLFNBQVMsV0FBVztBQUN6QixnQkFBWTtBQUNaLGlCQUFhLFFBQVEsYUFBYTtBQUFBLEVBQ3BDO0FBQ0Y7QUFTTyxTQUFTLEtBQUssT0FBTyxLQUFLO0FBQy9CLFNBQU8sSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFXO0FBQ3RDLGFBQVMsYUFBYTtBQUNwQixlQUFTO0FBQ1QsY0FBUSxLQUFLO0FBQUEsSUFDZjtBQUNBLGFBQVMsY0FBYztBQUNyQixlQUFTO0FBQ1QsYUFBTyxJQUFJLE1BQU0sa0JBQWtCLENBQUM7QUFBQSxJQUN0QztBQUNBLGFBQVMsV0FBVztBQUNsQixZQUFNLG9CQUFvQixRQUFRLFVBQVU7QUFDNUMsWUFBTSxvQkFBb0IsU0FBUyxXQUFXO0FBQUEsSUFDaEQ7QUFDQSxVQUFNLGlCQUFpQixRQUFRLFVBQVU7QUFDekMsVUFBTSxpQkFBaUIsU0FBUyxXQUFXO0FBQzNDLFFBQUksS0FBSztBQUNQLFlBQU0sTUFBTTtBQUFBLElBQ2Q7QUFBQSxFQUNGLENBQUM7QUFDSDtBQU9PLFNBQVMsZUFBZSxPQUFPLEtBQUs7QUFDekMsTUFBSSxLQUFLO0FBQ1AsVUFBTSxNQUFNO0FBQUEsRUFDZDtBQUNBLFNBQU8sTUFBTSxPQUFPLGVBQ2hCLElBQUk7QUFBQSxJQUFRLENBQUMsU0FBUyxXQUNwQixNQUNHLE9BQU8sRUFDUCxLQUFLLE1BQU0sUUFBUSxLQUFLLENBQUMsRUFDekI7QUFBQSxNQUFNLENBQUMsTUFDTixNQUFNLFlBQVksTUFBTSxRQUFRLFFBQVEsS0FBSyxJQUFJLE9BQU8sQ0FBQztBQUFBLElBQzNEO0FBQUEsRUFDSixJQUNBLEtBQUssS0FBSztBQUNoQjtBQVdPLFNBQVMsT0FBTyxPQUFPLEtBQUs7QUFDakMsTUFBSSxLQUFLO0FBQ1AsVUFBTSxNQUFNO0FBQUEsRUFDZDtBQUNBLFNBQU8sTUFBTSxPQUFPLGdCQUFnQixzQkFDaEMsTUFDRyxPQUFPLEVBQ1AsS0FBSyxNQUFNLGtCQUFrQixLQUFLLENBQUMsRUFDbkMsTUFBTSxDQUFDLE1BQU07QUFDWixRQUFJLE1BQU0sWUFBWSxNQUFNLE9BQU87QUFDakMsYUFBTztBQUFBLElBQ1Q7QUFDQSxVQUFNO0FBQUEsRUFDUixDQUFDLElBQ0gsZUFBZSxLQUFLO0FBQzFCO0FBbFZBLElBMERNLGNBMFJDQztBQXBWUCxJQUFBQyxjQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrREEsSUFBTSxlQUFOLGNBQTJCLGVBQVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUXJDLFlBQVksUUFBUSxZQUFZLFlBQVksZUFBZTtBQUN6RCxjQUFNO0FBTU4sYUFBSyxTQUFTO0FBTWQsYUFBSyxjQUFjO0FBTW5CLGFBQUssYUFBYTtBQU1sQixhQUFLLFFBQ0gsT0FBTyxrQkFBa0IsYUFBYSxtQkFBVyxPQUFPO0FBTTFELGFBQUssU0FBUztBQU1kLGFBQUssU0FBUyxPQUFPLGtCQUFrQixhQUFhLGdCQUFnQjtBQUFBLE1BQ3RFO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxVQUFVO0FBQ1IsYUFBSyxjQUFjLGtCQUFVLE1BQU07QUFBQSxNQUNyQztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxnQkFBZ0I7QUFDZDtBQUFBO0FBQUEsVUFBOEIsS0FBSztBQUFBO0FBQUEsTUFDckM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxPQUFPO0FBQ0wsWUFBSSxLQUFLLFNBQVMsbUJBQVcsTUFBTTtBQUNqQyxjQUFJLEtBQUssUUFBUTtBQUNmLGlCQUFLLFFBQVEsbUJBQVc7QUFDeEIsaUJBQUssUUFBUTtBQUNiLGtCQUFNLGFBQWEsS0FBSyxjQUFjO0FBQ3RDLGtCQUFNLG9CQUFvQixNQUFNLFFBQVEsVUFBVSxJQUM5QyxXQUFXLENBQUMsSUFDWjtBQUNKO0FBQUEsY0FBVSxNQUNSLEtBQUs7QUFBQSxnQkFDSCxLQUFLLFVBQVU7QUFBQSxnQkFDZjtBQUFBLGdCQUNBLEtBQUssY0FBYztBQUFBLGNBQ3JCO0FBQUEsWUFDRixFQUNHLEtBQUssQ0FBQyxVQUFVO0FBQ2Ysa0JBQUksV0FBVyxPQUFPO0FBQ3BCLHFCQUFLLFNBQVMsTUFBTTtBQUFBLGNBQ3RCO0FBQ0Esa0JBQUksWUFBWSxPQUFPO0FBQ3JCLHFCQUFLLFNBQVMsTUFBTTtBQUFBLGNBQ3RCO0FBQ0Esa0JBQUksZ0JBQWdCLE9BQU87QUFDekIscUJBQUssYUFBYSxNQUFNO0FBQUEsY0FDMUI7QUFDQSxrQkFBSSxnQkFBZ0IsT0FBTztBQUN6QixxQkFBSyxjQUFjLE1BQU07QUFBQSxjQUMzQjtBQUNBLGtCQUNFLGlCQUFpQixvQkFDakIsaUJBQWlCLGVBQ2pCLGlCQUFpQixxQkFDakIsaUJBQWlCLGtCQUNqQjtBQUNBLHFCQUFLLFNBQVM7QUFBQSxjQUNoQjtBQUNBLG1CQUFLLFFBQVEsbUJBQVc7QUFBQSxZQUMxQixDQUFDLEVBQ0EsTUFBTSxDQUFDRixXQUFVO0FBQ2hCLG1CQUFLLFFBQVEsbUJBQVc7QUFDeEIsc0JBQVEsTUFBTUEsTUFBSztBQUFBLFlBQ3JCLENBQUMsRUFDQSxRQUFRLE1BQU0sS0FBSyxRQUFRLENBQUM7QUFBQSxVQUNqQztBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxTQUFTLE9BQU87QUFDZCxhQUFLLFNBQVM7QUFBQSxNQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsY0FBYyxZQUFZO0FBQ3hCLGFBQUssYUFBYTtBQUFBLE1BQ3BCO0FBQUEsSUFDRjtBQStIQSxJQUFPQyxpQkFBUTtBQUFBO0FBQUE7OztBQ2xNUixTQUFTLFlBQVksS0FBSyxhQUFhLE9BQU87QUFDbkQsUUFBTSxjQUFjLFFBQVEsUUFBUSxLQUFLLElBQUk7QUFDN0MsU0FBTyxjQUFjLE1BQU0sTUFBTSxNQUFNO0FBQ3pDO0FBckpBLElBV00sZ0JBNElDLHdCQU9NO0FBOUpiO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFNQSxJQUFNLGlCQUFOLE1BQXFCO0FBQUEsTUFDbkIsY0FBYztBQUtaLGFBQUssU0FBUyxDQUFDO0FBTWYsYUFBSyxnQkFBZ0IsQ0FBQztBQU10QixhQUFLLGFBQWE7QUFNbEIsYUFBSyxnQkFBZ0I7QUFBQSxNQUN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsUUFBUTtBQUNOLGFBQUssU0FBUyxDQUFDO0FBQ2YsYUFBSyxnQkFBZ0IsQ0FBQztBQUN0QixhQUFLLGFBQWE7QUFBQSxNQUNwQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLLGFBQWEsS0FBSztBQUFBLE1BQ2hDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxTQUFTO0FBQ1AsWUFBSSxLQUFLLGVBQWUsR0FBRztBQUN6QixjQUFJLElBQUk7QUFDUixxQkFBVyxPQUFPLEtBQUssUUFBUTtBQUM3QixrQkFBTSxZQUFZLEtBQUssT0FBTyxHQUFHO0FBQ2pDLGlCQUFLLE1BQU0sT0FBTyxLQUFLLENBQUMsVUFBVSxZQUFZLEdBQUc7QUFDL0MscUJBQU8sS0FBSyxPQUFPLEdBQUc7QUFDdEIscUJBQU8sS0FBSyxjQUFjLEdBQUc7QUFDN0IsZ0JBQUUsS0FBSztBQUFBLFlBQ1Q7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLElBQUksS0FBSyxhQUFhLE9BQU87QUFDM0IsY0FBTSxNQUFNLFlBQVksS0FBSyxhQUFhLEtBQUs7QUFDL0MsZUFBTyxPQUFPLEtBQUssU0FBUyxLQUFLLE9BQU8sR0FBRyxJQUFJO0FBQUEsTUFDakQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFdBQVcsS0FBSyxhQUFhLE9BQU87QUFDbEMsY0FBTSxNQUFNLFlBQVksS0FBSyxhQUFhLEtBQUs7QUFDL0MsZUFBTyxPQUFPLEtBQUssZ0JBQWdCLEtBQUssY0FBYyxHQUFHLElBQUk7QUFBQSxNQUMvRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxJQUFJLEtBQUssYUFBYSxPQUFPLFdBQVcsU0FBUztBQUMvQyxjQUFNLE1BQU0sWUFBWSxLQUFLLGFBQWEsS0FBSztBQUMvQyxjQUFNLFNBQVMsT0FBTyxLQUFLO0FBQzNCLGFBQUssT0FBTyxHQUFHLElBQUk7QUFDbkIsWUFBSSxTQUFTO0FBQ1gsY0FBSSxVQUFVLGNBQWMsTUFBTSxtQkFBVyxNQUFNO0FBQ2pELHNCQUFVLEtBQUs7QUFBQSxVQUNqQjtBQUNBLGNBQUksVUFBVSxjQUFjLE1BQU0sbUJBQVcsU0FBUztBQUNwRCxzQkFBVSxNQUFNLEVBQUUsS0FBSyxNQUFNO0FBQzNCLG1CQUFLLGNBQWMsR0FBRyxJQUFJLHlCQUF5QixFQUFFO0FBQUEsZ0JBQ25ELFVBQVUsU0FBUyxDQUFDO0FBQUEsZ0JBQ3BCO0FBQUEsY0FDRjtBQUFBLFlBQ0YsQ0FBQztBQUFBLFVBQ0gsT0FBTztBQUNMLGlCQUFLLGNBQWMsR0FBRyxJQUFJLHlCQUF5QixFQUFFO0FBQUEsY0FDbkQsVUFBVSxTQUFTLENBQUM7QUFBQSxjQUNwQjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUNBLFlBQUksQ0FBQyxRQUFRO0FBQ1gsWUFBRSxLQUFLO0FBQUEsUUFDVDtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsUUFBUSxjQUFjO0FBQ3BCLGFBQUssZ0JBQWdCO0FBQ3JCLGFBQUssT0FBTztBQUFBLE1BQ2Q7QUFBQSxJQUNGO0FBYUEsSUFBTyx5QkFBUTtBQU9SLElBQU0sU0FBUyxJQUFJLGVBQWU7QUFBQTtBQUFBOzs7QUNzSmxDLFNBQVNFLEtBQUksT0FBTyxVQUFVLGFBQWEsWUFBWSxPQUFPLFNBQVM7QUFDNUUsTUFBSSxZQUNGLGFBQWEsU0FDVCxTQUNBLE9BQWUsSUFBSSxVQUFVLGFBQWEsS0FBSztBQUNyRCxNQUFJLENBQUMsV0FBVztBQUNkLGdCQUFZLElBQUk7QUFBQSxNQUNkO0FBQUEsTUFDQSxTQUFTLFNBQVMsUUFBUSxNQUFNLE9BQU8sU0FBWTtBQUFBLE1BQ25EO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQ0EsV0FBZSxJQUFJLFVBQVUsYUFBYSxPQUFPLFdBQVcsT0FBTztBQUFBLEVBQ3JFO0FBQ0EsTUFDRSxXQUNBLGFBQ0EsQ0FBQyxPQUFlLFdBQVcsVUFBVSxhQUFhLEtBQUssR0FDdkQ7QUFDQSxXQUFlLElBQUksVUFBVSxhQUFhLE9BQU8sV0FBVyxPQUFPO0FBQUEsRUFDckU7QUFDQSxTQUFPO0FBQ1Q7QUEzVUEsSUFlSSxvQkFFRSxXQTRUQztBQTdVUDtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUFDO0FBQ0E7QUFLQSxJQUFJLHFCQUFxQjtBQUV6QixJQUFNLFlBQU4sY0FBd0IsZUFBWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRbEMsWUFBWSxPQUFPLEtBQUssYUFBYSxZQUFZLE9BQU87QUFDdEQsY0FBTTtBQU1OLGFBQUsscUJBQXFCO0FBTTFCLGFBQUssU0FBUztBQU1kLGFBQUssZUFBZTtBQU1wQixhQUFLLFVBQVUsQ0FBQztBQU1oQixhQUFLLFNBQVM7QUFNZCxhQUFLLGNBQWMsZUFBZSxTQUFZLG1CQUFXLE9BQU87QUFNaEUsYUFBSyxRQUNILFNBQVMsTUFBTSxTQUFTLE1BQU0sU0FBUyxDQUFDLE1BQU0sT0FBTyxNQUFNLE1BQU0sSUFBSTtBQU12RSxhQUFLLE9BQU87QUFLWixhQUFLO0FBTUwsYUFBSyxTQUFTO0FBQUEsTUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLG1CQUFtQjtBQUNqQixhQUFLLFNBQVMsSUFBSSxNQUFNO0FBQ3hCLFlBQUksS0FBSyxpQkFBaUIsTUFBTTtBQUM5QixlQUFLLE9BQU8sY0FBYyxLQUFLO0FBQUEsUUFDakM7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGFBQWE7QUFDWCxZQUFJLEtBQUssYUFBYSxVQUFhLEtBQUssZ0JBQWdCLG1CQUFXLFFBQVE7QUFDekUsY0FBSSxDQUFDLG9CQUFvQjtBQUN2QixpQ0FBcUIsc0JBQXNCLEdBQUcsR0FBRyxRQUFXO0FBQUEsY0FDMUQsb0JBQW9CO0FBQUEsWUFDdEIsQ0FBQztBQUFBLFVBQ0g7QUFDQSw2QkFBbUIsVUFBVSxLQUFLLFFBQVEsR0FBRyxDQUFDO0FBQzlDLGNBQUk7QUFDRiwrQkFBbUIsYUFBYSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQzFDLGlCQUFLLFdBQVc7QUFBQSxVQUNsQixTQUFTLEdBQUc7QUFDVixpQ0FBcUI7QUFDckIsaUJBQUssV0FBVztBQUFBLFVBQ2xCO0FBQUEsUUFDRjtBQUNBLGVBQU8sS0FBSyxhQUFhO0FBQUEsTUFDM0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLHVCQUF1QjtBQUNyQixhQUFLLGNBQWMsa0JBQVUsTUFBTTtBQUFBLE1BQ3JDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxvQkFBb0I7QUFDbEIsYUFBSyxjQUFjLG1CQUFXO0FBQzlCLGFBQUsscUJBQXFCO0FBQUEsTUFDNUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLG1CQUFtQjtBQUNqQixhQUFLLGNBQWMsbUJBQVc7QUFDOUIsYUFBSyxRQUFRLENBQUMsS0FBSyxPQUFPLE9BQU8sS0FBSyxPQUFPLE1BQU07QUFDbkQsYUFBSyxxQkFBcUI7QUFBQSxNQUM1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxTQUFTLFlBQVk7QUFDbkIsWUFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixlQUFLLGlCQUFpQjtBQUFBLFFBQ3hCO0FBQ0EsYUFBSyxjQUFjLFVBQVU7QUFDN0IsZUFBTyxLQUFLLFFBQVEsVUFBVSxJQUFJLEtBQUssUUFBUSxVQUFVLElBQUksS0FBSztBQUFBLE1BQ3BFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGNBQWMsWUFBWTtBQUN4QixhQUFLLGNBQWMsVUFBVTtBQUM3QixlQUFPLEtBQUssUUFBUSxVQUFVLElBQUksYUFBYTtBQUFBLE1BQ2pEO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSx1QkFBdUI7QUFDckIsWUFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixlQUFLLGlCQUFpQjtBQUFBLFFBQ3hCO0FBQ0EsWUFBSSxDQUFDLEtBQUssb0JBQW9CO0FBQzVCLGNBQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsa0JBQU0sUUFBUSxLQUFLLE1BQU0sQ0FBQztBQUMxQixrQkFBTSxTQUFTLEtBQUssTUFBTSxDQUFDO0FBQzNCLGtCQUFNLFVBQVUsc0JBQXNCLE9BQU8sTUFBTTtBQUNuRCxvQkFBUSxTQUFTLEdBQUcsR0FBRyxPQUFPLE1BQU07QUFDcEMsaUJBQUsscUJBQXFCLFFBQVE7QUFBQSxVQUNwQyxPQUFPO0FBQ0wsaUJBQUsscUJBQXFCLEtBQUs7QUFBQSxVQUNqQztBQUFBLFFBQ0Y7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFVBQVU7QUFDUixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxTQUFTO0FBQ1AsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsT0FBTztBQUNMLFlBQUksS0FBSyxnQkFBZ0IsbUJBQVcsTUFBTTtBQUN4QztBQUFBLFFBQ0Y7QUFDQSxZQUFJLENBQUMsS0FBSyxRQUFRO0FBQ2hCLGVBQUssaUJBQWlCO0FBQUEsUUFDeEI7QUFFQSxhQUFLLGNBQWMsbUJBQVc7QUFDOUIsWUFBSTtBQUNGLGNBQUksS0FBSyxTQUFTLFFBQVc7QUFDSyxZQUFDLEtBQUssT0FBUSxNQUFNLEtBQUs7QUFBQSxVQUMzRDtBQUFBLFFBQ0YsU0FBUyxHQUFHO0FBQ1YsZUFBSyxrQkFBa0I7QUFBQSxRQUN6QjtBQUNBLFlBQUksS0FBSyxrQkFBa0Isa0JBQWtCO0FBQzNDLHlCQUFlLEtBQUssUUFBUSxLQUFLLElBQUksRUFDbEMsS0FBSyxDQUFDLFVBQVU7QUFDZixpQkFBSyxTQUFTO0FBQ2QsaUJBQUssaUJBQWlCO0FBQUEsVUFDeEIsQ0FBQyxFQUNBLE1BQU0sS0FBSyxrQkFBa0IsS0FBSyxJQUFJLENBQUM7QUFBQSxRQUM1QztBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsY0FBYyxZQUFZO0FBQ3hCLFlBQ0UsQ0FBQyxLQUFLLFVBQ04sS0FBSyxRQUFRLFVBQVUsS0FDdkIsS0FBSyxnQkFBZ0IsbUJBQVcsUUFDaEM7QUFDQTtBQUFBLFFBQ0Y7QUFFQSxjQUFNLFFBQVEsS0FBSztBQUNuQixjQUFNLFNBQVMsU0FBUyxjQUFjLFFBQVE7QUFDOUMsZUFBTyxRQUFRLEtBQUssS0FBSyxNQUFNLFFBQVEsVUFBVTtBQUNqRCxlQUFPLFNBQVMsS0FBSyxLQUFLLE1BQU0sU0FBUyxVQUFVO0FBRW5ELGNBQU0sTUFBTSxPQUFPLFdBQVcsSUFBSTtBQUNsQyxZQUFJLE1BQU0sWUFBWSxVQUFVO0FBQ2hDLFlBQUksVUFBVSxPQUFPLEdBQUcsQ0FBQztBQUV6QixZQUFJLDJCQUEyQjtBQUMvQixZQUFJLFlBQVksU0FBUyxLQUFLLE1BQU07QUFDcEMsWUFBSSxTQUFTLEdBQUcsR0FBRyxPQUFPLFFBQVEsWUFBWSxPQUFPLFNBQVMsVUFBVTtBQUV4RSxZQUFJLDJCQUEyQjtBQUMvQixZQUFJLFVBQVUsT0FBTyxHQUFHLENBQUM7QUFFekIsYUFBSyxRQUFRLFVBQVUsSUFBSTtBQUFBLE1BQzdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxRQUFRO0FBQ04sWUFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixlQUFLLFNBQVMsSUFBSSxRQUFRLENBQUMsWUFBWTtBQUNyQyxnQkFDRSxLQUFLLGdCQUFnQixtQkFBVyxVQUNoQyxLQUFLLGdCQUFnQixtQkFBVyxPQUNoQztBQUNBLHNCQUFRO0FBQUEsWUFDVixPQUFPO0FBQ0wsbUJBQUssaUJBQWlCLGtCQUFVLFFBQVEsU0FBUyxXQUFXO0FBQzFELG9CQUNFLEtBQUssZ0JBQWdCLG1CQUFXLFVBQ2hDLEtBQUssZ0JBQWdCLG1CQUFXLE9BQ2hDO0FBQ0EsdUJBQUssb0JBQW9CLGtCQUFVLFFBQVEsUUFBUTtBQUNuRCwwQkFBUTtBQUFBLGdCQUNWO0FBQUEsY0FDRixDQUFDO0FBQUEsWUFDSDtBQUFBLFVBQ0YsQ0FBQztBQUFBLFFBQ0g7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUEsSUFDRjtBQW9DQSxJQUFPLG9CQUFRO0FBQUE7QUFBQTs7O0FDeFNSLFNBQVMsWUFBWSxPQUFPO0FBQ2pDLE1BQUksQ0FBQyxPQUFPO0FBQ1YsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDeEIsV0FBT0MsVUFBUyxLQUFLO0FBQUEsRUFDdkI7QUFDQSxNQUFJLE9BQU8sVUFBVSxZQUFZLFNBQVMsT0FBTztBQUMvQyxXQUFPLGdCQUFnQixLQUFLO0FBQUEsRUFDOUI7QUFDQSxTQUFPO0FBQ1Q7QUFPQSxTQUFTLGdCQUFnQixTQUFTO0FBQ2hDLE1BQUksQ0FBQyxRQUFRLFVBQVUsQ0FBQyxRQUFRLE1BQU07QUFDcEMsV0FBTyxPQUFVLFdBQVcsUUFBUSxLQUFLLGFBQWEsUUFBUSxLQUFLO0FBQUEsRUFDckU7QUFFQSxRQUFNLFdBQVcsUUFBUSxNQUFNLE1BQU0sUUFBUTtBQUU3QyxRQUFNLGdCQUFnQixPQUFVO0FBQUEsSUFDOUI7QUFBQSxJQUNBO0FBQUEsSUFDQSxRQUFRO0FBQUEsRUFDVjtBQUNBLE1BQUksZUFBZTtBQUNqQixXQUFPO0FBQUEsRUFDVDtBQUVBLFFBQU0sWUFBWSxPQUFVLElBQUksUUFBUSxLQUFLLGFBQWEsSUFBSTtBQUM5RCxNQUFJLFVBQVUsY0FBYyxNQUFNLG1CQUFXLFFBQVE7QUFDbkQsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLHVCQUF1QjtBQUFBLElBQzNCLFFBQVEsS0FBSyxDQUFDO0FBQUEsSUFDZCxRQUFRLEtBQUssQ0FBQztBQUFBLEVBQ2hCO0FBQ0EsdUJBQXFCO0FBQUEsSUFDbkIsVUFBVSxTQUFTLENBQUM7QUFBQSxJQUNwQixRQUFRLE9BQU8sQ0FBQztBQUFBLElBQ2hCLFFBQVEsT0FBTyxDQUFDO0FBQUEsSUFDaEIsUUFBUSxLQUFLLENBQUM7QUFBQSxJQUNkLFFBQVEsS0FBSyxDQUFDO0FBQUEsSUFDZDtBQUFBLElBQ0E7QUFBQSxJQUNBLFFBQVEsS0FBSyxDQUFDO0FBQUEsSUFDZCxRQUFRLEtBQUssQ0FBQztBQUFBLEVBQ2hCO0FBQ0EsRUFBQUM7QUFBQSxJQUNFLHFCQUFxQjtBQUFBLElBQ3JCO0FBQUEsSUFDQTtBQUFBLElBQ0EsbUJBQVc7QUFBQSxJQUNYLFFBQVE7QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUNBLFNBQU8sT0FBVSxXQUFXLFVBQVUsUUFBVyxRQUFRLEtBQUs7QUFDaEU7QUFuR0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7QUNQQSxJQXFCYSxjQVFBLGtCQVFBLG9CQVFBLG1CQVFBLGVBU0EsaUJBTVAsV0FhQSxxQkFlTztBQWhHYjtBQUFBO0FBcUJPLElBQU0sZUFBZTtBQVFyQixJQUFNLG1CQUFtQjtBQVF6QixJQUFNLHFCQUFxQjtBQVEzQixJQUFNLG9CQUFvQjtBQVExQixJQUFNLGdCQUFnQjtBQVN0QixJQUFNLGtCQUFrQjtBQU0vQixJQUFNLFlBQVksSUFBSTtBQUFBLE1BQ3BCO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0YsRUFBRSxLQUFLLEVBQUU7QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUVBLElBQU0sc0JBQXNCO0FBQUEsTUFDMUI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFRTyxJQUFNLG9CQUFvQixTQUFVLFVBQVU7QUFDbkQsWUFBTSxRQUFRLFNBQVMsTUFBTSxTQUFTO0FBQ3RDLFVBQUksQ0FBQyxPQUFPO0FBQ1YsZUFBTztBQUFBLE1BQ1Q7QUFDQSxZQUFNO0FBQUE7QUFBQSxRQUF1QztBQUFBLFVBQzNDLFlBQVk7QUFBQSxVQUNaLE1BQU07QUFBQSxVQUNOLE9BQU87QUFBQSxVQUNQLFFBQVE7QUFBQSxVQUNSLFNBQVM7QUFBQSxRQUNYO0FBQUE7QUFDQSxlQUFTLElBQUksR0FBRyxLQUFLLG9CQUFvQixRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDNUQsY0FBTSxRQUFRLE1BQU0sSUFBSSxDQUFDO0FBQ3pCLFlBQUksVUFBVSxRQUFXO0FBQ3ZCLGdCQUFNLG9CQUFvQixDQUFDLENBQUMsSUFBSTtBQUFBLFFBQ2xDO0FBQUEsTUFDRjtBQUNBLFlBQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxNQUFNO0FBQzFDLGFBQU87QUFBQSxJQUNUO0FBQUE7QUFBQTs7O0FDaU5BLFNBQVMsWUFBWSxNQUFNLE1BQU07QUFDL0IsTUFBSSxDQUFDLGdCQUFnQjtBQUNuQixxQkFBaUIsc0JBQXNCLEdBQUcsQ0FBQztBQUFBLEVBQzdDO0FBQ0EsTUFBSSxRQUFRLGFBQWE7QUFDdkIsbUJBQWUsT0FBTztBQUN0QixrQkFBYyxlQUFlO0FBQUEsRUFDL0I7QUFDQSxTQUFPLGVBQWUsWUFBWSxJQUFJO0FBQ3hDO0FBT08sU0FBUyxpQkFBaUIsTUFBTSxNQUFNO0FBQzNDLFNBQU8sWUFBWSxNQUFNLElBQUksRUFBRTtBQUNqQztBQVNPLFNBQVMseUJBQXlCLE1BQU0sTUFBTUMsUUFBTztBQUMxRCxNQUFJLFFBQVFBLFFBQU87QUFDakIsV0FBT0EsT0FBTSxJQUFJO0FBQUEsRUFDbkI7QUFDQSxRQUFNLFFBQVEsS0FDWCxNQUFNLElBQUksRUFDVixPQUFPLENBQUMsTUFBTSxTQUFTLEtBQUssSUFBSSxNQUFNLGlCQUFpQixNQUFNLElBQUksQ0FBQyxHQUFHLENBQUM7QUFDekUsRUFBQUEsT0FBTSxJQUFJLElBQUk7QUFDZCxTQUFPO0FBQ1Q7QUFPTyxTQUFTLGtCQUFrQixXQUFXLFFBQVE7QUFDbkQsUUFBTSxTQUFTLENBQUM7QUFDaEIsUUFBTSxVQUFVLENBQUM7QUFDakIsUUFBTSxhQUFhLENBQUM7QUFDcEIsTUFBSSxRQUFRO0FBQ1osTUFBSSxZQUFZO0FBQ2hCLE1BQUksU0FBUztBQUNiLE1BQUksYUFBYTtBQUNqQixXQUFTLElBQUksR0FBRyxLQUFLLE9BQU8sUUFBUSxLQUFLLElBQUksS0FBSyxHQUFHO0FBQ25ELFVBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsUUFBSSxTQUFTLFFBQVEsTUFBTSxJQUFJO0FBQzdCLGNBQVEsS0FBSyxJQUFJLE9BQU8sU0FBUztBQUNqQyxpQkFBVyxLQUFLLFNBQVM7QUFDekIsa0JBQVk7QUFDWixnQkFBVTtBQUNWLG1CQUFhO0FBQ2I7QUFBQSxJQUNGO0FBQ0EsVUFBTSxPQUFPLE9BQU8sSUFBSSxDQUFDLEtBQUssVUFBVTtBQUN4QyxVQUFNLGVBQWUsaUJBQWlCLE1BQU0sSUFBSTtBQUNoRCxXQUFPLEtBQUssWUFBWTtBQUN4QixpQkFBYTtBQUNiLFVBQU0sZ0JBQWdCLGtCQUFrQixJQUFJO0FBQzVDLFlBQVEsS0FBSyxhQUFhO0FBQzFCLGlCQUFhLEtBQUssSUFBSSxZQUFZLGFBQWE7QUFBQSxFQUNqRDtBQUNBLFNBQU8sRUFBQyxPQUFPLFFBQVEsUUFBUSxTQUFTLFdBQVU7QUFDcEQ7QUFRTyxTQUFTLGVBQWUsU0FBUyxVQUFVLFNBQVMsU0FBUztBQUNsRSxNQUFJLGFBQWEsR0FBRztBQUNsQixZQUFRLFVBQVUsU0FBUyxPQUFPO0FBQ2xDLFlBQVEsT0FBTyxRQUFRO0FBQ3ZCLFlBQVEsVUFBVSxDQUFDLFNBQVMsQ0FBQyxPQUFPO0FBQUEsRUFDdEM7QUFDRjtBQWVPLFNBQVMsaUJBQ2QsU0FDQUMsWUFDQSxTQUNBLGNBQ0EsU0FDQSxTQUNBLEdBQ0EsR0FDQSxHQUNBLEdBQ0FDLFFBQ0E7QUFDQSxVQUFRLEtBQUs7QUFFYixNQUFJLFlBQVksR0FBRztBQUNqQixRQUFJLFFBQVEsZ0JBQWdCLFFBQVc7QUFDckMsY0FBUSxjQUFjLENBQUNDLGFBQWFBLFNBQVEsZUFBZTtBQUFBLElBQzdELE9BQU87QUFDTCxjQUFRLGVBQWU7QUFBQSxJQUN6QjtBQUFBLEVBQ0Y7QUFDQSxNQUFJRixZQUFXO0FBQ2IsWUFBUSxVQUFVLE1BQU0sU0FBU0EsVUFBUztBQUFBLEVBQzVDO0FBRUE7QUFBQTtBQUFBLElBQXNCLGFBQWM7QUFBQSxJQUFxQjtBQUV2RCxZQUFRLFVBQVUsR0FBRyxDQUFDO0FBQ3RCLFlBQVEsTUFBTUMsT0FBTSxDQUFDLEdBQUdBLE9BQU0sQ0FBQyxDQUFDO0FBQ2hDO0FBQUE7QUFBQSxNQUErQztBQUFBLE1BQWU7QUFBQSxJQUFPO0FBQUEsRUFDdkUsV0FBV0EsT0FBTSxDQUFDLElBQUksS0FBS0EsT0FBTSxDQUFDLElBQUksR0FBRztBQUV2QyxZQUFRLFVBQVUsR0FBRyxDQUFDO0FBQ3RCLFlBQVEsTUFBTUEsT0FBTSxDQUFDLEdBQUdBLE9BQU0sQ0FBQyxDQUFDO0FBQ2hDLFlBQVE7QUFBQTtBQUFBLE1BRUo7QUFBQSxNQUVGO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGLE9BQU87QUFFTCxZQUFRO0FBQUE7QUFBQSxNQUVKO0FBQUEsTUFFRjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxJQUFJQSxPQUFNLENBQUM7QUFBQSxNQUNYLElBQUlBLE9BQU0sQ0FBQztBQUFBLElBQ2I7QUFBQSxFQUNGO0FBRUEsVUFBUSxRQUFRO0FBQ2xCO0FBTUEsU0FBUyx5QkFBeUIsT0FBTyxTQUFTO0FBQ2hELFFBQU0sc0JBQXNCLE1BQU07QUFDbEMsV0FBUyxJQUFJLEdBQUcsS0FBSyxvQkFBb0IsUUFBUSxJQUFJLElBQUksS0FBSyxHQUFHO0FBQy9ELFFBQUksTUFBTSxRQUFRLG9CQUFvQixJQUFJLENBQUMsQ0FBQyxHQUFHO0FBQzdDLGNBQVEsb0JBQW9CLENBQUMsQ0FBQyxFQUFFO0FBQUEsUUFDOUI7QUFBQSxRQUNBLG9CQUFvQixJQUFJLENBQUM7QUFBQSxNQUMzQjtBQUFBLElBQ0YsT0FBTztBQUNMLGNBQVEsb0JBQW9CLENBQUMsQ0FBQyxJQUFJLG9CQUFvQixJQUFJLENBQUM7QUFBQSxJQUM3RDtBQUFBLEVBQ0Y7QUFDRjtBQTVmQSxJQTRGYSxhQU1BLGtCQU1BLGdCQU1BLGlCQU1BLHVCQU1BLGlCQU1BLG1CQU1BLG9CQU1BLGtCQU1BLHFCQU1BLGdCQU1BLGtCQUtBLGNBS1QsZ0JBS0EsYUFLUyxhQU1BLGNBK0ZBO0FBdlJiO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcUZPLElBQU0sY0FBYztBQU1wQixJQUFNLG1CQUFtQjtBQU16QixJQUFNLGlCQUFpQjtBQU12QixJQUFNLGtCQUFrQixDQUFDO0FBTXpCLElBQU0sd0JBQXdCO0FBTTlCLElBQU0sa0JBQWtCO0FBTXhCLElBQU0sb0JBQW9CO0FBTTFCLElBQU0scUJBQXFCO0FBTTNCLElBQU0sbUJBQW1CO0FBTXpCLElBQU0sc0JBQXNCO0FBTTVCLElBQU0saUJBQWlCLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQU1sQyxJQUFNLG1CQUFtQjtBQUt6QixJQUFNLGVBQWUsSUFBSSxlQUFXO0FBSzNDLElBQUksaUJBQWlCO0FBVWQsSUFBTSxjQUFjLENBQUM7QUFNckIsSUFBTSxlQUFnQixXQUFZO0FBQ3ZDLFlBQU0sVUFBVTtBQUNoQixZQUFNLE9BQU87QUFDYixZQUFNLGlCQUFpQixDQUFDLGFBQWEsT0FBTztBQUM1QyxZQUFNLE1BQU0sZUFBZTtBQUMzQixZQUFNLE9BQU87QUFDYixVQUFJLFVBQVU7QUFRZCxlQUFTLFlBQVksV0FBVyxZQUFZLFlBQVk7QUFDdEQsWUFBSSxZQUFZO0FBQ2hCLGlCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQzVCLGdCQUFNLGdCQUFnQixlQUFlLENBQUM7QUFDdEMsMkJBQWlCO0FBQUEsWUFDZixZQUFZLE1BQU0sYUFBYSxNQUFNLE9BQU87QUFBQSxZQUM1QztBQUFBLFVBQ0Y7QUFDQSxjQUFJLGNBQWMsZUFBZTtBQUMvQixrQkFBTSxRQUFRO0FBQUEsY0FDWixZQUNFLE1BQ0EsYUFDQSxNQUNBLE9BQ0EsYUFDQSxNQUNBO0FBQUEsY0FDRjtBQUFBLFlBQ0Y7QUFHQSx3QkFBWSxhQUFhLFNBQVM7QUFBQSxVQUNwQztBQUFBLFFBQ0Y7QUFDQSxZQUFJLFdBQVc7QUFDYixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUVBLGVBQVMsUUFBUTtBQUNmLFlBQUksT0FBTztBQUNYLGNBQU0sUUFBUSxhQUFhLFFBQVE7QUFDbkMsaUJBQVMsSUFBSSxHQUFHLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDOUMsZ0JBQU0sT0FBTyxNQUFNLENBQUM7QUFDcEIsY0FBSSxhQUFhLElBQUksSUFBSSxJQUFJLFNBQVM7QUFDcEMsZ0JBQUksWUFBWSxNQUFNLE1BQU0sS0FBSyxNQUFNLElBQUksQ0FBQyxHQUFHO0FBQzdDLG9CQUFNLFdBQVc7QUFFakIsK0JBQWlCO0FBQ2pCLDRCQUFjO0FBQ2QsMkJBQWEsSUFBSSxNQUFNLE9BQU87QUFBQSxZQUNoQyxPQUFPO0FBQ0wsMkJBQWEsSUFBSSxNQUFNLGFBQWEsSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJO0FBQ3ZELHFCQUFPO0FBQUEsWUFDVDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQ0EsWUFBSSxNQUFNO0FBQ1Isd0JBQWMsUUFBUTtBQUN0QixxQkFBVztBQUFBLFFBQ2I7QUFBQSxNQUNGO0FBRUEsYUFBTyxTQUFVLFVBQVU7QUFDekIsY0FBTSxPQUFPLGtCQUFrQixRQUFRO0FBQ3ZDLFlBQUksQ0FBQyxNQUFNO0FBQ1Q7QUFBQSxRQUNGO0FBQ0EsY0FBTSxXQUFXLEtBQUs7QUFDdEIsaUJBQVMsSUFBSSxHQUFHLEtBQUssU0FBUyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDakQsZ0JBQU0sU0FBUyxTQUFTLENBQUM7QUFDekIsZ0JBQU0sTUFBTSxLQUFLLFFBQVEsT0FBTyxLQUFLLFNBQVMsT0FBTztBQUNyRCxjQUFJLGFBQWEsSUFBSSxHQUFHLE1BQU0sUUFBVztBQUN2Qyx5QkFBYSxJQUFJLEtBQUssU0FBUyxJQUFJO0FBQ25DLGdCQUFJLENBQUMsWUFBWSxLQUFLLE9BQU8sS0FBSyxRQUFRLE1BQU0sR0FBRztBQUNqRCwyQkFBYSxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQzdCLGtCQUFJLGFBQWEsUUFBVztBQUMxQiwyQkFBVyxZQUFZLE9BQU8sRUFBRTtBQUFBLGNBQ2xDO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0YsRUFBRztBQU1JLElBQU0sb0JBQXFCLDJCQUFZO0FBSTVDLFVBQUk7QUFDSixhQUFPLFNBQVUsVUFBVTtBQUN6QixZQUFJLFNBQVMsWUFBWSxRQUFRO0FBQ2pDLFlBQUksVUFBVSxRQUFXO0FBQ3ZCLGNBQUkseUJBQXlCO0FBQzNCLGtCQUFNLE9BQU8sa0JBQWtCLFFBQVE7QUFDdkMsa0JBQU0sVUFBVSxZQUFZLFVBQVUsU0FBSTtBQUMxQyxrQkFBTSxhQUFhLE1BQU0sT0FBTyxLQUFLLFVBQVUsQ0FBQyxJQUM1QyxNQUNBLE9BQU8sS0FBSyxVQUFVO0FBQzFCLHFCQUNFLGNBQ0MsUUFBUSwwQkFBMEIsUUFBUTtBQUFBLFVBQy9DLE9BQU87QUFDTCxnQkFBSSxDQUFDLGdCQUFnQjtBQUNuQiwrQkFBaUIsU0FBUyxjQUFjLEtBQUs7QUFDN0MsNkJBQWUsWUFBWTtBQUMzQiw2QkFBZSxNQUFNLFlBQVk7QUFDakMsNkJBQWUsTUFBTSxZQUFZO0FBQ2pDLDZCQUFlLE1BQU0sU0FBUztBQUM5Qiw2QkFBZSxNQUFNLFVBQVU7QUFDL0IsNkJBQWUsTUFBTSxTQUFTO0FBQzlCLDZCQUFlLE1BQU0sV0FBVztBQUNoQyw2QkFBZSxNQUFNLFVBQVU7QUFDL0IsNkJBQWUsTUFBTSxPQUFPO0FBQUEsWUFDOUI7QUFDQSwyQkFBZSxNQUFNLE9BQU87QUFDNUIscUJBQVMsS0FBSyxZQUFZLGNBQWM7QUFDeEMscUJBQVMsZUFBZTtBQUN4QixxQkFBUyxLQUFLLFlBQVksY0FBYztBQUFBLFVBQzFDO0FBQ0Esc0JBQVksUUFBUSxJQUFJO0FBQUEsUUFDMUI7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0YsRUFBRztBQUFBO0FBQUE7OztBQzlUSCxJQXdETSxjQStpQkM7QUF2bUJQO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUErQ0EsSUFBTSxlQUFOLE1BQU0sc0JBQXFCLGNBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUlwQyxZQUFZLFNBQVM7QUFDbkIsY0FBTTtBQUFBLFVBQ0osU0FBUztBQUFBLFVBQ1QsZ0JBQ0UsUUFBUSxtQkFBbUIsU0FBWSxRQUFRLGlCQUFpQjtBQUFBLFVBQ2xFLFVBQVUsUUFBUSxhQUFhLFNBQVksUUFBUSxXQUFXO0FBQUEsVUFDOUQsT0FBTyxRQUFRLFVBQVUsU0FBWSxRQUFRLFFBQVE7QUFBQSxVQUNyRCxjQUNFLFFBQVEsaUJBQWlCLFNBQVksUUFBUSxlQUFlLENBQUMsR0FBRyxDQUFDO0FBQUEsVUFDbkUsZUFBZSxRQUFRO0FBQUEsUUFDekIsQ0FBQztBQU1ELGFBQUs7QUFNTCxhQUFLLHNCQUFzQjtBQU0zQixhQUFLLFFBQVEsUUFBUSxTQUFTLFNBQVksUUFBUSxPQUFPO0FBTXpELGFBQUssVUFBVSxDQUFDLEdBQUcsQ0FBQztBQU1wQixhQUFLLFVBQVUsUUFBUTtBQU12QixhQUFLLFVBQVUsUUFBUTtBQU12QixhQUFLLFdBQVcsUUFBUTtBQU14QixhQUFLLFNBQVMsUUFBUSxVQUFVLFNBQVksUUFBUSxRQUFRO0FBTTVELGFBQUssVUFBVSxRQUFRLFdBQVcsU0FBWSxRQUFRLFNBQVM7QUFNL0QsYUFBSztBQU1MLGFBQUs7QUFFTCxhQUFLLGNBQ0gsS0FBSyxTQUFTLEtBQUssTUFBTSxRQUFRLElBQzdCLG1CQUFXLFVBQ1gsbUJBQVc7QUFDakIsWUFBSSxLQUFLLGdCQUFnQixtQkFBVyxTQUFTO0FBQzNDLGVBQUssTUFBTSxFQUFFLEtBQUssTUFBTyxLQUFLLGNBQWMsbUJBQVcsTUFBTztBQUFBLFFBQ2hFO0FBQ0EsYUFBSyxPQUFPO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixjQUFNRSxTQUFRLEtBQUssU0FBUztBQUM1QixjQUFNLFFBQVEsSUFBSSxjQUFhO0FBQUEsVUFDN0IsTUFBTSxLQUFLLFFBQVEsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNLElBQUk7QUFBQSxVQUNoRCxRQUFRLEtBQUssVUFBVTtBQUFBLFVBQ3ZCLFFBQVEsS0FBSyxVQUFVO0FBQUEsVUFDdkIsU0FBUyxLQUFLLFdBQVc7QUFBQSxVQUN6QixPQUFPLEtBQUssU0FBUztBQUFBLFVBQ3JCLFFBQVEsS0FBSyxVQUFVLElBQUksS0FBSyxVQUFVLEVBQUUsTUFBTSxJQUFJO0FBQUEsVUFDdEQsVUFBVSxLQUFLLFlBQVk7QUFBQSxVQUMzQixnQkFBZ0IsS0FBSyxrQkFBa0I7QUFBQSxVQUN2QyxPQUFPLE1BQU0sUUFBUUEsTUFBSyxJQUFJQSxPQUFNLE1BQU0sSUFBSUE7QUFBQSxVQUM5QyxjQUFjLEtBQUssZ0JBQWdCLEVBQUUsTUFBTTtBQUFBLFVBQzNDLGVBQWUsS0FBSyxpQkFBaUI7QUFBQSxRQUN2QyxDQUFDO0FBQ0QsY0FBTSxXQUFXLEtBQUssV0FBVyxDQUFDO0FBQ2xDLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxZQUFZO0FBQ1YsY0FBTSxPQUFPLEtBQUs7QUFDbEIsY0FBTSxlQUFlLEtBQUssZ0JBQWdCO0FBQzFDLGNBQU1BLFNBQVEsS0FBSyxjQUFjO0FBR2pDLGVBQU87QUFBQSxVQUNMLEtBQUssQ0FBQyxJQUFJLElBQUksYUFBYSxDQUFDLElBQUlBLE9BQU0sQ0FBQztBQUFBLFVBQ3ZDLEtBQUssQ0FBQyxJQUFJLElBQUksYUFBYSxDQUFDLElBQUlBLE9BQU0sQ0FBQztBQUFBLFFBQ3pDO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxRQUFRLE1BQU07QUFDWixhQUFLLFFBQVE7QUFDYixhQUFLLE9BQU87QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSx1QkFBdUI7QUFDckIsWUFBSSxDQUFDLEtBQUsscUJBQXFCO0FBQzdCLGVBQUssc0JBQXNCLEtBQUs7QUFBQSxZQUM5QixLQUFLO0FBQUEsVUFDUDtBQUFBLFFBQ0Y7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxTQUFTLFlBQVk7QUFDbkIsWUFBSSxRQUFRLEtBQUssVUFBVSxVQUFVO0FBQ3JDLFlBQUksQ0FBQyxPQUFPO0FBQ1YsZ0JBQU0sZ0JBQWdCLEtBQUs7QUFDM0IsZ0JBQU0sVUFBVTtBQUFBLFlBQ2QsY0FBYyxPQUFPO0FBQUEsWUFDckIsY0FBYyxPQUFPO0FBQUEsVUFDdkI7QUFDQSxlQUFLLE1BQU0sZUFBZSxTQUFTLFVBQVU7QUFFN0Msa0JBQVEsUUFBUTtBQUNoQixlQUFLLFVBQVUsVUFBVSxJQUFJO0FBQUEsUUFDL0I7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGNBQWMsWUFBWTtBQUN4QixlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsZUFBZTtBQUNiLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGdCQUFnQjtBQUNkLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZO0FBQ1YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFlBQVk7QUFDVixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxhQUFhO0FBQ1gsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFVBQVU7QUFDUixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxPQUFPO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0Esa0JBQWtCLFVBQVU7QUFBQSxNQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLN0IsT0FBTztBQUFBLE1BQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtSLG9CQUFvQixVQUFVO0FBQUEsTUFBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVUvQix1QkFBdUIsVUFBVSxhQUFhLFlBQVk7QUFDeEQsWUFDRSxnQkFBZ0IsS0FDaEIsS0FBSyxZQUFZLFlBQ2hCLGFBQWEsV0FBVyxhQUFhLFNBQ3RDO0FBQ0EsaUJBQU87QUFBQSxRQUNUO0FBdUJBLFlBQUksS0FBSyxLQUFLO0FBQ2QsWUFBSSxLQUFLLEtBQUssYUFBYSxTQUFZLEtBQUssS0FBSztBQUNqRCxZQUFJLEtBQUssSUFBSTtBQUNYLGdCQUFNLE1BQU07QUFDWixlQUFLO0FBQ0wsZUFBSztBQUFBLFFBQ1A7QUFDQSxjQUFNLFNBQ0osS0FBSyxhQUFhLFNBQVksS0FBSyxVQUFVLEtBQUssVUFBVTtBQUM5RCxjQUFNLFFBQVMsSUFBSSxLQUFLLEtBQU07QUFDOUIsY0FBTSxJQUFJLEtBQUssS0FBSyxJQUFJLEtBQUs7QUFDN0IsY0FBTSxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssSUFBSSxDQUFDO0FBQ25DLGNBQU0sSUFBSSxLQUFLO0FBQ2YsY0FBTSxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDO0FBQ2pDLGNBQU0sYUFBYSxJQUFJO0FBQ3ZCLFlBQUksYUFBYSxXQUFXLGNBQWMsWUFBWTtBQUNwRCxpQkFBTyxhQUFhO0FBQUEsUUFDdEI7QUFjQSxjQUFNLElBQUksY0FBYyxJQUFJO0FBQzVCLGNBQU0sSUFBSyxjQUFjLEtBQU0sSUFBSTtBQUNuQyxjQUFNLE9BQU8sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLEtBQUssSUFBSSxDQUFDO0FBQ2xELGNBQU0sV0FBVyxPQUFPO0FBQ3hCLFlBQUksS0FBSyxhQUFhLFVBQWEsYUFBYSxTQUFTO0FBQ3ZELGlCQUFPLFdBQVc7QUFBQSxRQUNwQjtBQUdBLGNBQU0sS0FBSyxLQUFLLEtBQUssSUFBSSxLQUFLO0FBQzlCLGNBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssRUFBRTtBQUN0QyxjQUFNLEtBQUssS0FBSztBQUNoQixjQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEVBQUU7QUFDdEMsY0FBTSxrQkFBa0IsS0FBSztBQUM3QixZQUFJLG1CQUFtQixZQUFZO0FBQ2pDLGdCQUFNLGNBQWUsa0JBQWtCLGNBQWUsSUFBSSxLQUFLO0FBQy9ELGlCQUFPLElBQUksS0FBSyxJQUFJLFVBQVUsV0FBVztBQUFBLFFBQzNDO0FBQ0EsZUFBTyxXQUFXO0FBQUEsTUFDcEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsc0JBQXNCO0FBQ3BCLFlBQUksVUFBVTtBQUNkLFlBQUksV0FBVztBQUNmLFlBQUksYUFBYTtBQUNqQixZQUFJLFdBQVc7QUFDZixZQUFJLGlCQUFpQjtBQUNyQixZQUFJO0FBQ0osWUFBSSxjQUFjO0FBRWxCLFlBQUksS0FBSyxTQUFTO0FBQ2hCLHdCQUFjLFlBQVksS0FBSyxRQUFRLFNBQVMsS0FBSyxrQkFBa0I7QUFDdkUsd0JBQWMsS0FBSyxRQUFRLFNBQVMsS0FBSztBQUN6QyxxQkFBVyxLQUFLLFFBQVEsWUFBWTtBQUNwQywyQkFBaUIsS0FBSyxRQUFRLGtCQUFrQixLQUFLO0FBQ3JELHFCQUFXLEtBQUssUUFBUSxZQUFZLEtBQUs7QUFDekMsb0JBQVUsS0FBSyxRQUFRLFdBQVcsS0FBSztBQUN2Qyx1QkFBYSxLQUFLLFFBQVEsY0FBYyxLQUFLO0FBQUEsUUFDL0M7QUFFQSxjQUFNQyxPQUFNLEtBQUssdUJBQXVCLFVBQVUsYUFBYSxVQUFVO0FBQ3pFLGNBQU0sWUFBWSxLQUFLLElBQUksS0FBSyxTQUFTLEtBQUssWUFBWSxDQUFDO0FBQzNELGNBQU0sT0FBTyxLQUFLLEtBQUssSUFBSSxZQUFZQSxJQUFHO0FBRTFDLGVBQU87QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxTQUFTO0FBQ1AsYUFBSyxpQkFBaUIsS0FBSyxvQkFBb0I7QUFDL0MsY0FBTSxPQUFPLEtBQUssZUFBZTtBQUNqQyxhQUFLLFlBQVksQ0FBQztBQUNsQixhQUFLLHNCQUFzQjtBQUMzQixhQUFLLFFBQVEsQ0FBQyxNQUFNLElBQUk7QUFBQSxNQUMxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsTUFBTSxlQUFlLFNBQVMsWUFBWTtBQUN4QyxnQkFBUSxNQUFNLFlBQVksVUFBVTtBQUVwQyxnQkFBUSxVQUFVLGNBQWMsT0FBTyxHQUFHLGNBQWMsT0FBTyxDQUFDO0FBRWhFLGFBQUssWUFBWSxPQUFPO0FBRXhCLFlBQUksS0FBSyxPQUFPO0FBQ2QsY0FBSSxRQUFRLEtBQUssTUFBTSxTQUFTO0FBQ2hDLGNBQUksVUFBVSxNQUFNO0FBQ2xCLG9CQUFRO0FBQUEsVUFDVjtBQUNBLGtCQUFRLFlBQVksWUFBWSxLQUFLO0FBQ3JDLGtCQUFRLEtBQUs7QUFBQSxRQUNmO0FBQ0EsWUFBSSxjQUFjLGFBQWE7QUFDN0Isa0JBQVEsY0FBYyxjQUFjO0FBQ3BDLGtCQUFRLFlBQVksY0FBYztBQUNsQyxjQUFJLGNBQWMsVUFBVTtBQUMxQixvQkFBUSxZQUFZLGNBQWMsUUFBUTtBQUMxQyxvQkFBUSxpQkFBaUIsY0FBYztBQUFBLFVBQ3pDO0FBQ0Esa0JBQVEsVUFBVSxjQUFjO0FBQ2hDLGtCQUFRLFdBQVcsY0FBYztBQUNqQyxrQkFBUSxhQUFhLGNBQWM7QUFDbkMsa0JBQVEsT0FBTztBQUFBLFFBQ2pCO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLDBCQUEwQixlQUFlO0FBQ3ZDLFlBQUk7QUFDSixZQUFJLEtBQUssT0FBTztBQUNkLGNBQUksUUFBUSxLQUFLLE1BQU0sU0FBUztBQUdoQyxjQUFJLFVBQVU7QUFDZCxjQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLG9CQUFRLFFBQVEsS0FBSztBQUFBLFVBQ3ZCO0FBQ0EsY0FBSSxVQUFVLE1BQU07QUFDbEIsc0JBQVU7QUFBQSxVQUNaLFdBQVcsTUFBTSxRQUFRLEtBQUssR0FBRztBQUMvQixzQkFBVSxNQUFNLFdBQVcsSUFBSSxNQUFNLENBQUMsSUFBSTtBQUFBLFVBQzVDO0FBQ0EsY0FBSSxZQUFZLEdBQUc7QUFHakIsc0JBQVUsc0JBQXNCLGNBQWMsTUFBTSxjQUFjLElBQUk7QUFDdEUsaUJBQUssd0JBQXdCLGVBQWUsT0FBTztBQUFBLFVBQ3JEO0FBQUEsUUFDRjtBQUNBLGVBQU8sVUFBVSxRQUFRLFNBQVMsS0FBSyxTQUFTLENBQUM7QUFBQSxNQUNuRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxZQUFZLFNBQVM7QUFDbkIsWUFBSSxTQUFTLEtBQUs7QUFDbEIsY0FBTSxTQUFTLEtBQUs7QUFDcEIsWUFBSSxXQUFXLFVBQVU7QUFDdkIsa0JBQVEsSUFBSSxHQUFHLEdBQUcsUUFBUSxHQUFHLElBQUksS0FBSyxFQUFFO0FBQUEsUUFDMUMsT0FBTztBQUNMLGdCQUFNLFVBQVUsS0FBSyxhQUFhLFNBQVksU0FBUyxLQUFLO0FBQzVELGNBQUksS0FBSyxhQUFhLFFBQVc7QUFDL0Isc0JBQVU7QUFBQSxVQUNaO0FBQ0EsZ0JBQU0sYUFBYSxLQUFLLFNBQVMsS0FBSyxLQUFLO0FBQzNDLGdCQUFNLE9BQVEsSUFBSSxLQUFLLEtBQU07QUFDN0IsbUJBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxLQUFLO0FBQy9CLGtCQUFNLFNBQVMsYUFBYSxJQUFJO0FBQ2hDLGtCQUFNLFVBQVUsSUFBSSxNQUFNLElBQUksU0FBUztBQUN2QyxvQkFBUSxPQUFPLFVBQVUsS0FBSyxJQUFJLE1BQU0sR0FBRyxVQUFVLEtBQUssSUFBSSxNQUFNLENBQUM7QUFBQSxVQUN2RTtBQUNBLGtCQUFRLFVBQVU7QUFBQSxRQUNwQjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSx3QkFBd0IsZUFBZSxTQUFTO0FBRTlDLGdCQUFRLFVBQVUsY0FBYyxPQUFPLEdBQUcsY0FBYyxPQUFPLENBQUM7QUFFaEUsYUFBSyxZQUFZLE9BQU87QUFFeEIsZ0JBQVEsWUFBWTtBQUNwQixnQkFBUSxLQUFLO0FBQ2IsWUFBSSxjQUFjLGFBQWE7QUFDN0Isa0JBQVEsY0FBYyxjQUFjO0FBQ3BDLGtCQUFRLFlBQVksY0FBYztBQUNsQyxjQUFJLGNBQWMsVUFBVTtBQUMxQixvQkFBUSxZQUFZLGNBQWMsUUFBUTtBQUMxQyxvQkFBUSxpQkFBaUIsY0FBYztBQUFBLFVBQ3pDO0FBQ0Esa0JBQVEsV0FBVyxjQUFjO0FBQ2pDLGtCQUFRLGFBQWEsY0FBYztBQUNuQyxrQkFBUSxPQUFPO0FBQUEsUUFDakI7QUFBQSxNQUNGO0FBQUEsTUFFQSxRQUFRO0FBQ04sZUFBTyxLQUFLLFFBQVEsS0FBSyxNQUFNLE1BQU0sSUFBSSxRQUFRLFFBQVE7QUFBQSxNQUMzRDtBQUFBLElBQ0Y7QUFFQSxJQUFPLHVCQUFRO0FBQUE7QUFBQTs7O0FDdm1CZixJQTBCTSxhQXVEQztBQWpGUDtBQUFBO0FBSUE7QUFzQkEsSUFBTSxjQUFOLE1BQU0scUJBQW9CLHFCQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJckMsWUFBWSxTQUFTO0FBQ25CLGtCQUFVLFVBQVUsVUFBVSxFQUFDLFFBQVEsRUFBQztBQUV4QyxjQUFNO0FBQUEsVUFDSixRQUFRO0FBQUEsVUFDUixNQUFNLFFBQVE7QUFBQSxVQUNkLFFBQVEsUUFBUTtBQUFBLFVBQ2hCLFFBQVEsUUFBUTtBQUFBLFVBQ2hCLE9BQU8sUUFBUSxVQUFVLFNBQVksUUFBUSxRQUFRO0FBQUEsVUFDckQsVUFBVSxRQUFRLGFBQWEsU0FBWSxRQUFRLFdBQVc7QUFBQSxVQUM5RCxnQkFDRSxRQUFRLG1CQUFtQixTQUFZLFFBQVEsaUJBQWlCO0FBQUEsVUFDbEUsY0FDRSxRQUFRLGlCQUFpQixTQUFZLFFBQVEsZUFBZSxDQUFDLEdBQUcsQ0FBQztBQUFBLFVBQ25FLGVBQWUsUUFBUTtBQUFBLFFBQ3pCLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsUUFBUTtBQUNOLGNBQU1DLFNBQVEsS0FBSyxTQUFTO0FBQzVCLGNBQU0sUUFBUSxJQUFJLGFBQVk7QUFBQSxVQUM1QixNQUFNLEtBQUssUUFBUSxJQUFJLEtBQUssUUFBUSxFQUFFLE1BQU0sSUFBSTtBQUFBLFVBQ2hELFFBQVEsS0FBSyxVQUFVLElBQUksS0FBSyxVQUFVLEVBQUUsTUFBTSxJQUFJO0FBQUEsVUFDdEQsUUFBUSxLQUFLLFVBQVU7QUFBQSxVQUN2QixPQUFPLE1BQU0sUUFBUUEsTUFBSyxJQUFJQSxPQUFNLE1BQU0sSUFBSUE7QUFBQSxVQUM5QyxVQUFVLEtBQUssWUFBWTtBQUFBLFVBQzNCLGdCQUFnQixLQUFLLGtCQUFrQjtBQUFBLFVBQ3ZDLGNBQWMsS0FBSyxnQkFBZ0IsRUFBRSxNQUFNO0FBQUEsVUFDM0MsZUFBZSxLQUFLLGlCQUFpQjtBQUFBLFFBQ3ZDLENBQUM7QUFDRCxjQUFNLFdBQVcsS0FBSyxXQUFXLENBQUM7QUFDbEMsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFVBQVUsUUFBUTtBQUNoQixhQUFLLFVBQVU7QUFDZixhQUFLLE9BQU87QUFBQSxNQUNkO0FBQUEsSUFDRjtBQUVBLElBQU8saUJBQVE7QUFBQTtBQUFBOzs7QUNqRmYsSUFxQk0sTUF3RkM7QUE3R1A7QUFBQTtBQUlBO0FBQ0E7QUFnQkEsSUFBTSxPQUFOLE1BQU0sTUFBSztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSVQsWUFBWSxTQUFTO0FBQ25CLGtCQUFVLFdBQVcsQ0FBQztBQU10QixhQUFLLGdCQUFnQjtBQU1yQixhQUFLLFNBQVM7QUFDZCxZQUFJLFFBQVEsVUFBVSxRQUFXO0FBQy9CLGVBQUssU0FBUyxRQUFRLEtBQUs7QUFBQSxRQUM3QjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxRQUFRO0FBQ04sY0FBTSxRQUFRLEtBQUssU0FBUztBQUM1QixlQUFPLElBQUksTUFBSztBQUFBLFVBQ2QsT0FBTyxNQUFNLFFBQVEsS0FBSyxJQUFJLE1BQU0sTUFBTSxJQUFJLFNBQVM7QUFBQSxRQUN6RCxDQUFDO0FBQUEsTUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxTQUFTLE9BQU87QUFDZCxZQUFJLFVBQVUsUUFBUSxPQUFPLFVBQVUsWUFBWSxTQUFTLE9BQU87QUFDakUsZ0JBQU0sZUFBZUM7QUFBQSxZQUNuQjtBQUFBLFlBQ0EsTUFBTTtBQUFBLFlBQ047QUFBQSxZQUNBO0FBQUEsWUFDQSxNQUFNLFNBQVMsT0FBTyxNQUFNLFFBQVEsTUFBTSxRQUFRO0FBQUEsWUFDbEQsRUFBRSxNQUFNLFVBQVUsTUFBTTtBQUFBLFVBQzFCO0FBQ0EsdUJBQWEsTUFBTSxFQUFFLEtBQUssTUFBTTtBQUM5QixpQkFBSyxnQkFBZ0I7QUFBQSxVQUN2QixDQUFDO0FBQ0QsY0FBSSxhQUFhLGNBQWMsTUFBTSxtQkFBVyxNQUFNO0FBQ3BELHlCQUFhLEtBQUs7QUFBQSxVQUNwQjtBQUNBLGNBQUksYUFBYSxjQUFjLE1BQU0sbUJBQVcsU0FBUztBQUN2RCxpQkFBSyxnQkFBZ0I7QUFBQSxVQUN2QjtBQUFBLFFBQ0Y7QUFDQSxhQUFLLFNBQVM7QUFBQSxNQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsVUFBVTtBQUNSLGVBQU8sQ0FBQyxDQUFDLEtBQUs7QUFBQSxNQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsUUFBUTtBQUNOLGVBQU8sS0FBSyxnQkFBZ0IsS0FBSyxjQUFjLE1BQU0sSUFBSSxRQUFRLFFBQVE7QUFBQSxNQUMzRTtBQUFBLElBQ0Y7QUFFQSxJQUFPLGVBQVE7QUFBQTtBQUFBOzs7QUM3R2YsSUF5Qk0sUUEwTUM7QUFuT1A7QUFBQTtBQXlCQSxJQUFNLFNBQU4sTUFBTSxRQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJWCxZQUFZLFNBQVM7QUFDbkIsa0JBQVUsV0FBVyxDQUFDO0FBTXRCLGFBQUssU0FBUyxRQUFRLFVBQVUsU0FBWSxRQUFRLFFBQVE7QUFNNUQsYUFBSyxXQUFXLFFBQVE7QUFNeEIsYUFBSyxZQUFZLFFBQVEsYUFBYSxTQUFZLFFBQVEsV0FBVztBQU1yRSxhQUFLLGtCQUFrQixRQUFRO0FBTS9CLGFBQUssWUFBWSxRQUFRO0FBTXpCLGFBQUssY0FBYyxRQUFRO0FBTTNCLGFBQUssU0FBUyxRQUFRO0FBQUEsTUFDeEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxRQUFRO0FBQ04sY0FBTSxRQUFRLEtBQUssU0FBUztBQUM1QixlQUFPLElBQUksUUFBTztBQUFBLFVBQ2hCLE9BQU8sTUFBTSxRQUFRLEtBQUssSUFBSSxNQUFNLE1BQU0sSUFBSSxTQUFTO0FBQUEsVUFDdkQsU0FBUyxLQUFLLFdBQVc7QUFBQSxVQUN6QixVQUFVLEtBQUssWUFBWSxJQUFJLEtBQUssWUFBWSxFQUFFLE1BQU0sSUFBSTtBQUFBLFVBQzVELGdCQUFnQixLQUFLLGtCQUFrQjtBQUFBLFVBQ3ZDLFVBQVUsS0FBSyxZQUFZO0FBQUEsVUFDM0IsWUFBWSxLQUFLLGNBQWM7QUFBQSxVQUMvQixPQUFPLEtBQUssU0FBUztBQUFBLFFBQ3ZCLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsV0FBVztBQUNULGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxhQUFhO0FBQ1gsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGNBQWM7QUFDWixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0Esb0JBQW9CO0FBQ2xCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxjQUFjO0FBQ1osZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGdCQUFnQjtBQUNkLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsU0FBUyxPQUFPO0FBQ2QsYUFBSyxTQUFTO0FBQUEsTUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFdBQVcsU0FBUztBQUNsQixhQUFLLFdBQVc7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWSxVQUFVO0FBQ3BCLGFBQUssWUFBWTtBQUFBLE1BQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxrQkFBa0IsZ0JBQWdCO0FBQ2hDLGFBQUssa0JBQWtCO0FBQUEsTUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFlBQVksVUFBVTtBQUNwQixhQUFLLFlBQVk7QUFBQSxNQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsY0FBYyxZQUFZO0FBQ3hCLGFBQUssY0FBYztBQUFBLE1BQ3JCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxTQUFTLE9BQU87QUFDZCxhQUFLLFNBQVM7QUFBQSxNQUNoQjtBQUFBLElBQ0Y7QUFFQSxJQUFPLGlCQUFRO0FBQUE7QUFBQTs7O0FDbk9mO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBeWJPLFNBQVMsV0FBVyxLQUFLO0FBQzlCLE1BQUk7QUFFSixNQUFJLE9BQU8sUUFBUSxZQUFZO0FBQzdCLG9CQUFnQjtBQUFBLEVBQ2xCLE9BQU87QUFJTCxRQUFJO0FBQ0osUUFBSSxNQUFNLFFBQVEsR0FBRyxHQUFHO0FBQ3RCLGVBQVM7QUFBQSxJQUNYLE9BQU87QUFDTDtBQUFBLFFBQ0U7QUFBQSxRQUEwQixJQUFLLGNBQWU7QUFBQSxRQUM5QztBQUFBLE1BQ0Y7QUFDQSxZQUFNO0FBQUE7QUFBQSxRQUE4QjtBQUFBO0FBQ3BDLGVBQVMsQ0FBQyxLQUFLO0FBQUEsSUFDakI7QUFDQSxvQkFBZ0IsV0FBWTtBQUMxQixhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFZTyxTQUFTLG1CQUFtQixTQUFTLFlBQVk7QUFNdEQsTUFBSSxDQUFDLGVBQWU7QUFDbEIsVUFBTSxPQUFPLElBQUksYUFBSztBQUFBLE1BQ3BCLE9BQU87QUFBQSxJQUNULENBQUM7QUFDRCxVQUFNLFNBQVMsSUFBSSxlQUFPO0FBQUEsTUFDeEIsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLElBQ1QsQ0FBQztBQUNELG9CQUFnQjtBQUFBLE1BQ2QsSUFBSSxNQUFNO0FBQUEsUUFDUixPQUFPLElBQUksZUFBWTtBQUFBLFVBQ3JCO0FBQUEsVUFDQTtBQUFBLFVBQ0EsUUFBUTtBQUFBLFFBQ1YsQ0FBQztBQUFBLFFBQ0Q7QUFBQSxRQUNBO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFNTyxTQUFTLHFCQUFxQjtBQUVuQyxRQUFNLFNBQVMsQ0FBQztBQUNoQixRQUFNLFFBQVEsQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDO0FBQy9CLFFBQU0sT0FBTyxDQUFDLEdBQUcsS0FBSyxLQUFLLENBQUM7QUFDNUIsUUFBTSxRQUFRO0FBQ2QsU0FBTyxTQUFTLElBQUk7QUFBQSxJQUNsQixJQUFJLE1BQU07QUFBQSxNQUNSLE1BQU0sSUFBSSxhQUFLO0FBQUEsUUFDYixPQUFPLENBQUMsS0FBSyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLENBQUM7QUFBQSxJQUNILENBQUM7QUFBQSxFQUNIO0FBQ0EsU0FBTyxjQUFjLElBQUksT0FBTyxTQUFTO0FBRXpDLFNBQU8sWUFBWSxJQUFJO0FBQUEsSUFDckIsSUFBSSxNQUFNO0FBQUEsTUFDUixRQUFRLElBQUksZUFBTztBQUFBLFFBQ2pCLE9BQU87QUFBQSxRQUNQLE9BQU8sUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNILENBQUM7QUFBQSxJQUNELElBQUksTUFBTTtBQUFBLE1BQ1IsUUFBUSxJQUFJLGVBQU87QUFBQSxRQUNqQixPQUFPO0FBQUEsUUFDUDtBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUFBLEVBQ0g7QUFDQSxTQUFPLGlCQUFpQixJQUFJLE9BQU8sWUFBWTtBQUUvQyxTQUFPLFFBQVEsSUFBSSxPQUFPLFNBQVMsRUFBRSxPQUFPLE9BQU8sWUFBWSxDQUFDO0FBRWhFLFNBQU8sT0FBTyxJQUFJO0FBQUEsSUFDaEIsSUFBSSxNQUFNO0FBQUEsTUFDUixPQUFPLElBQUksZUFBWTtBQUFBLFFBQ3JCLFFBQVEsUUFBUTtBQUFBLFFBQ2hCLE1BQU0sSUFBSSxhQUFLO0FBQUEsVUFDYixPQUFPO0FBQUEsUUFDVCxDQUFDO0FBQUEsUUFDRCxRQUFRLElBQUksZUFBTztBQUFBLFVBQ2pCLE9BQU87QUFBQSxVQUNQLE9BQU8sUUFBUTtBQUFBLFFBQ2pCLENBQUM7QUFBQSxNQUNILENBQUM7QUFBQSxNQUNELFFBQVE7QUFBQSxJQUNWLENBQUM7QUFBQSxFQUNIO0FBQ0EsU0FBTyxZQUFZLElBQUksT0FBTyxPQUFPO0FBRXJDLFNBQU8sb0JBQW9CLElBQUksT0FBTyxTQUFTLEVBQUU7QUFBQSxJQUMvQyxPQUFPLFlBQVk7QUFBQSxJQUNuQixPQUFPLE9BQU87QUFBQSxFQUNoQjtBQUVBLFNBQU87QUFDVDtBQU9BLFNBQVMsd0JBQXdCLFNBQVM7QUFDeEMsU0FBTyxRQUFRLFlBQVk7QUFDN0I7QUFoa0JBLElBaUtNLE9Bc1RGLGVBMkdHO0FBbGtCUDtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUEwSkEsSUFBTSxRQUFOLE1BQU0sT0FBTTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSVYsWUFBWSxTQUFTO0FBQ25CLGtCQUFVLFdBQVcsQ0FBQztBQU10QixhQUFLLFlBQVk7QUFNakIsYUFBSyxvQkFBb0I7QUFFekIsWUFBSSxRQUFRLGFBQWEsUUFBVztBQUNsQyxlQUFLLFlBQVksUUFBUSxRQUFRO0FBQUEsUUFDbkM7QUFNQSxhQUFLLFFBQVEsUUFBUSxTQUFTLFNBQVksUUFBUSxPQUFPO0FBTXpELGFBQUssU0FBUyxRQUFRLFVBQVUsU0FBWSxRQUFRLFFBQVE7QUFNNUQsYUFBSyxZQUFZLFFBQVEsYUFBYSxTQUFZLFFBQVEsV0FBVztBQU1yRSxhQUFLLHdCQUNILFFBQVEseUJBQXlCLFNBQzdCLFFBQVEsdUJBQ1I7QUFNTixhQUFLLFVBQVUsUUFBUSxXQUFXLFNBQVksUUFBUSxTQUFTO0FBTS9ELGFBQUssUUFBUSxRQUFRLFNBQVMsU0FBWSxRQUFRLE9BQU87QUFNekQsYUFBSyxVQUFVLFFBQVE7QUFBQSxNQUN6QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixZQUFJLFdBQVcsS0FBSyxZQUFZO0FBQ2hDLFlBQUksWUFBWSxPQUFPLGFBQWEsVUFBVTtBQUM1QztBQUFBLFVBQ0UsU0FDQSxNQUFNO0FBQUEsUUFDVjtBQUNBLGVBQU8sSUFBSSxPQUFNO0FBQUEsVUFDZixVQUFVLFlBQVk7QUFBQSxVQUN0QixNQUFNLEtBQUssUUFBUSxJQUFJLEtBQUssUUFBUSxFQUFFLE1BQU0sSUFBSTtBQUFBLFVBQ2hELE9BQU8sS0FBSyxTQUFTLElBQUksS0FBSyxTQUFTLEVBQUUsTUFBTSxJQUFJO0FBQUEsVUFDbkQsVUFBVSxLQUFLLFlBQVksS0FBSztBQUFBLFVBQ2hDLFFBQVEsS0FBSyxVQUFVLElBQUksS0FBSyxVQUFVLEVBQUUsTUFBTSxJQUFJO0FBQUEsVUFDdEQsTUFBTSxLQUFLLFFBQVEsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNLElBQUk7QUFBQSxVQUNoRCxRQUFRLEtBQUssVUFBVTtBQUFBLFFBQ3pCLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxjQUFjO0FBQ1osZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWSxVQUFVO0FBQ3BCLGFBQUssWUFBWTtBQUFBLE1BQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSx3QkFBd0IsVUFBVTtBQUNoQyxhQUFLLHdCQUF3QjtBQUFBLE1BQy9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSwwQkFBMEI7QUFDeEIsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxjQUFjO0FBQ1osZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsc0JBQXNCO0FBQ3BCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVEsTUFBTTtBQUNaLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFNBQVMsT0FBTztBQUNkLGFBQUssU0FBUztBQUFBLE1BQ2hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQUEsTUFDakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVEsTUFBTTtBQUNaLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZO0FBQ1YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLFlBQVksVUFBVTtBQUNwQixZQUFJLE9BQU8sYUFBYSxZQUFZO0FBQ2xDLGVBQUssb0JBQW9CO0FBQUEsUUFDM0IsV0FBVyxPQUFPLGFBQWEsVUFBVTtBQUN2QyxlQUFLLG9CQUFvQixTQUFVLFNBQVM7QUFDMUM7QUFBQTtBQUFBLGNBQ0UsUUFBUSxJQUFJLFFBQVE7QUFBQTtBQUFBLFVBRXhCO0FBQUEsUUFDRixXQUFXLENBQUMsVUFBVTtBQUNwQixlQUFLLG9CQUFvQjtBQUFBLFFBQzNCLFdBQVcsYUFBYSxRQUFXO0FBQ2pDLGVBQUssb0JBQW9CLFdBQVk7QUFDbkM7QUFBQTtBQUFBLGNBQTZEO0FBQUE7QUFBQSxVQUMvRDtBQUFBLFFBQ0Y7QUFDQSxhQUFLLFlBQVk7QUFBQSxNQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsVUFBVSxRQUFRO0FBQ2hCLGFBQUssVUFBVTtBQUFBLE1BQ2pCO0FBQUEsSUFDRjtBQXdDQSxJQUFJLGdCQUFnQjtBQTJHcEIsSUFBTyxnQkFBUTtBQUFBO0FBQUE7OztBQ2xrQmY7QUFBQTtBQUFBO0FBQUE7QUErREEsU0FBUyxlQUFlLE9BQU8sUUFBUSxhQUFhLGNBQWM7QUFDaEUsTUFBSSxnQkFBZ0IsVUFBYSxpQkFBaUIsUUFBVztBQUMzRCxXQUFPLENBQUMsY0FBYyxPQUFPLGVBQWUsTUFBTTtBQUFBLEVBQ3BEO0FBQ0EsTUFBSSxnQkFBZ0IsUUFBVztBQUM3QixXQUFPLGNBQWM7QUFBQSxFQUN2QjtBQUNBLE1BQUksaUJBQWlCLFFBQVc7QUFDOUIsV0FBTyxlQUFlO0FBQUEsRUFDeEI7QUFDQSxTQUFPO0FBQ1Q7QUExRUEsSUFpRk0sTUF3ZUM7QUF6akJQO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdFQSxJQUFNLE9BQU4sTUFBTSxjQUFhLGNBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUk1QixZQUFZLFNBQVM7QUFDbkIsa0JBQVUsV0FBVyxDQUFDO0FBS3RCLGNBQU0sVUFBVSxRQUFRLFlBQVksU0FBWSxRQUFRLFVBQVU7QUFLbEUsY0FBTSxXQUFXLFFBQVEsYUFBYSxTQUFZLFFBQVEsV0FBVztBQUtyRSxjQUFNQyxTQUFRLFFBQVEsVUFBVSxTQUFZLFFBQVEsUUFBUTtBQUs1RCxjQUFNLGlCQUNKLFFBQVEsbUJBQW1CLFNBQVksUUFBUSxpQkFBaUI7QUFFbEUsY0FBTTtBQUFBLFVBQ0o7QUFBQSxVQUNBO0FBQUEsVUFDQSxPQUFPQTtBQUFBLFVBQ1AsY0FDRSxRQUFRLGlCQUFpQixTQUFZLFFBQVEsZUFBZSxDQUFDLEdBQUcsQ0FBQztBQUFBLFVBQ25FO0FBQUEsVUFDQSxlQUFlLFFBQVE7QUFBQSxRQUN6QixDQUFDO0FBTUQsYUFBSyxVQUFVLFFBQVEsV0FBVyxTQUFZLFFBQVEsU0FBUyxDQUFDLEtBQUssR0FBRztBQU14RSxhQUFLLG9CQUFvQjtBQU16QixhQUFLLGdCQUNILFFBQVEsaUJBQWlCLFNBQVksUUFBUSxlQUFlO0FBTTlELGFBQUssZ0JBQ0gsUUFBUSxpQkFBaUIsU0FBWSxRQUFRLGVBQWU7QUFNOUQsYUFBSyxnQkFDSCxRQUFRLGlCQUFpQixTQUFZLFFBQVEsZUFBZTtBQU05RCxhQUFLLGVBQ0gsUUFBUSxnQkFBZ0IsU0FBWSxRQUFRLGNBQWM7QUFFNUQsY0FBTSxRQUFRLFFBQVEsUUFBUSxTQUFZLFFBQVEsTUFBTTtBQUV4RCxZQUFJLFdBQVcsUUFBUTtBQUV2QjtBQUFBLFVBQ0UsRUFBRSxhQUFhLFVBQWE7QUFBQSxVQUM1QjtBQUFBLFFBQ0Y7QUFFQSxhQUFLLGFBQWEsVUFBYSxTQUFTLFdBQVcsTUFBTSxPQUFPO0FBQzlEO0FBQUEsVUFBNEMsTUFBTyxPQUFPLE9BQU8sS0FBSztBQUFBLFFBQ3hFO0FBQ0E7QUFBQSxVQUNFLGFBQWEsVUFBYSxTQUFTLFNBQVM7QUFBQSxVQUM1QztBQUFBLFFBQ0Y7QUFFQTtBQUFBLFVBQ0UsR0FDRyxRQUFRLFVBQVUsVUFBYSxRQUFRLFdBQVcsV0FDbkQsUUFBUSxVQUFVO0FBQUEsVUFFcEI7QUFBQSxRQUNGO0FBRUEsWUFBSTtBQUNKLFlBQUksUUFBUSxRQUFRLFFBQVc7QUFDN0IsdUJBQWEsbUJBQVc7QUFBQSxRQUMxQixXQUFXLFVBQVUsUUFBVztBQUM5QixjQUFJLGNBQWMsT0FBTztBQUN2QixnQkFBSSxNQUFNLFVBQVU7QUFDbEIsMkJBQWEsTUFBTSxNQUFNLG1CQUFXLFNBQVMsbUJBQVc7QUFBQSxZQUMxRCxPQUFPO0FBQ0wsMkJBQWEsbUJBQVc7QUFBQSxZQUMxQjtBQUFBLFVBQ0YsT0FBTztBQUNMLHlCQUFhLG1CQUFXO0FBQUEsVUFDMUI7QUFBQSxRQUNGO0FBTUEsYUFBSyxTQUFTLFFBQVEsVUFBVSxTQUFZLFFBQVEsUUFBUSxLQUFLLElBQUk7QUFNckUsYUFBSyxhQUFhQztBQUFBLFVBQ2hCO0FBQUE7QUFBQSxVQUN1QjtBQUFBLFVBQ3ZCLEtBQUs7QUFBQSxVQUNMO0FBQUEsVUFDQSxLQUFLO0FBQUEsUUFDUDtBQU1BLGFBQUssVUFBVSxRQUFRLFdBQVcsU0FBWSxRQUFRLFNBQVMsQ0FBQyxHQUFHLENBQUM7QUFLcEUsYUFBSyxnQkFDSCxRQUFRLGlCQUFpQixTQUFZLFFBQVEsZUFBZTtBQU05RCxhQUFLLFVBQVU7QUFNZixhQUFLLFFBQVEsUUFBUSxTQUFTLFNBQVksUUFBUSxPQUFPO0FBS3pELFlBQUksUUFBUSxVQUFVLFVBQWEsUUFBUSxXQUFXLFFBQVc7QUFDL0QsY0FBSSxPQUFPO0FBQ1gsY0FBSSxRQUFRLE1BQU07QUFDaEIsYUFBQyxPQUFPLE1BQU0sSUFBSSxRQUFRO0FBQUEsVUFDNUIsT0FBTztBQUNMLGtCQUFNQyxTQUFRLEtBQUssU0FBUyxDQUFDO0FBQzdCLGdCQUFJQSxPQUFNLFNBQVNBLE9BQU0sUUFBUTtBQUMvQixzQkFBUUEsT0FBTTtBQUNkLHVCQUFTQSxPQUFNO0FBQUEsWUFDakIsV0FBV0Esa0JBQWlCLGtCQUFrQjtBQUM1QyxtQkFBSyxrQkFBa0I7QUFDdkIsb0JBQU0sU0FBUyxNQUFNO0FBQ25CLHFCQUFLLG9CQUFvQixNQUFNO0FBQy9CLG9CQUFJLENBQUMsS0FBSyxpQkFBaUI7QUFDekI7QUFBQSxnQkFDRjtBQUNBLHNCQUFNLFlBQVksS0FBSyxXQUFXLFFBQVE7QUFDMUMscUJBQUs7QUFBQSxrQkFDSDtBQUFBLG9CQUNFLFVBQVUsQ0FBQztBQUFBLG9CQUNYLFVBQVUsQ0FBQztBQUFBLG9CQUNYLFFBQVE7QUFBQSxvQkFDUixRQUFRO0FBQUEsa0JBQ1Y7QUFBQSxnQkFDRjtBQUFBLGNBQ0Y7QUFDQSxtQkFBSyxrQkFBa0IsTUFBTTtBQUM3QjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQ0EsY0FBSSxVQUFVLFFBQVc7QUFDdkIsaUJBQUs7QUFBQSxjQUNILGVBQWUsT0FBTyxRQUFRLFFBQVEsT0FBTyxRQUFRLE1BQU07QUFBQSxZQUM3RDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixZQUFJRixRQUFPLE9BQU87QUFDbEIsWUFBSSxLQUFLLGlCQUFpQjtBQUN4QixrQkFBUSxLQUFLLGdCQUFnQjtBQUM3QixtQkFBUyxLQUFLLGdCQUFnQjtBQUFBLFFBQ2hDLE9BQU87QUFDTCxVQUFBQSxTQUFRLEtBQUssU0FBUztBQUN0QixVQUFBQSxTQUFRLE1BQU0sUUFBUUEsTUFBSyxJQUFJQSxPQUFNLE1BQU0sSUFBSUE7QUFBQSxRQUNqRDtBQUNBLGVBQU8sSUFBSSxNQUFLO0FBQUEsVUFDZCxRQUFRLEtBQUssUUFBUSxNQUFNO0FBQUEsVUFDM0IsY0FBYyxLQUFLO0FBQUEsVUFDbkIsY0FBYyxLQUFLO0FBQUEsVUFDbkIsY0FBYyxLQUFLO0FBQUEsVUFDbkIsT0FDRSxLQUFLLFVBQVUsS0FBSyxPQUFPLFFBQ3ZCLEtBQUssT0FBTyxNQUFNLElBQ2xCLEtBQUssVUFBVTtBQUFBLFVBQ3JCLGFBQWEsS0FBSztBQUFBLFVBQ2xCLFFBQVEsS0FBSyxRQUFRLE1BQU07QUFBQSxVQUMzQixjQUFjLEtBQUs7QUFBQSxVQUNuQixTQUFTLEtBQUssV0FBVztBQUFBLFVBQ3pCLGdCQUFnQixLQUFLLGtCQUFrQjtBQUFBLFVBQ3ZDLFVBQVUsS0FBSyxZQUFZO0FBQUEsVUFDM0IsT0FBQUE7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0EsTUFBTSxLQUFLLFVBQVUsT0FBTyxLQUFLLE1BQU0sTUFBTSxJQUFJO0FBQUEsVUFDakQsS0FBSyxLQUFLLE9BQU87QUFBQSxVQUNqQixjQUFjLEtBQUssZ0JBQWdCLEVBQUUsTUFBTTtBQUFBLFVBQzNDLGVBQWUsS0FBSyxpQkFBaUI7QUFBQSxRQUN2QyxDQUFDO0FBQUEsTUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWTtBQUNWLFlBQUksU0FBUyxLQUFLO0FBQ2xCLFlBQUksQ0FBQyxRQUFRO0FBQ1gsbUJBQVMsS0FBSztBQUNkLGdCQUFNLE9BQU8sS0FBSyxRQUFRO0FBQzFCLGNBQ0UsS0FBSyxpQkFBaUIsY0FDdEIsS0FBSyxpQkFBaUIsWUFDdEI7QUFDQSxnQkFBSSxDQUFDLE1BQU07QUFDVCxxQkFBTztBQUFBLFlBQ1Q7QUFDQSxxQkFBUyxLQUFLLFFBQVEsTUFBTTtBQUM1QixnQkFBSSxLQUFLLGlCQUFpQixZQUFZO0FBQ3BDLHFCQUFPLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxZQUNyQjtBQUNBLGdCQUFJLEtBQUssaUJBQWlCLFlBQVk7QUFDcEMscUJBQU8sQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLFlBQ3JCO0FBQUEsVUFDRjtBQUVBLGNBQUksS0FBSyxpQkFBaUIsWUFBWTtBQUNwQyxnQkFBSSxDQUFDLE1BQU07QUFDVCxxQkFBTztBQUFBLFlBQ1Q7QUFDQSxnQkFBSSxXQUFXLEtBQUssU0FBUztBQUMzQix1QkFBUyxLQUFLLFFBQVEsTUFBTTtBQUFBLFlBQzlCO0FBQ0EsZ0JBQ0UsS0FBSyxpQkFBaUIsZUFDdEIsS0FBSyxpQkFBaUIsZ0JBQ3RCO0FBQ0EscUJBQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxDQUFDO0FBQUEsWUFDakM7QUFDQSxnQkFDRSxLQUFLLGlCQUFpQixpQkFDdEIsS0FBSyxpQkFBaUIsZ0JBQ3RCO0FBQ0EscUJBQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxDQUFDO0FBQUEsWUFDakM7QUFBQSxVQUNGO0FBQ0EsZUFBSyxvQkFBb0I7QUFBQSxRQUMzQjtBQUNBLGNBQU0sZUFBZSxLQUFLLGdCQUFnQjtBQUMxQyxjQUFNQSxTQUFRLEtBQUssY0FBYztBQUdqQyxlQUFPO0FBQUEsVUFDTCxPQUFPLENBQUMsSUFBSSxhQUFhLENBQUMsSUFBSUEsT0FBTSxDQUFDO0FBQUEsVUFDckMsT0FBTyxDQUFDLElBQUksYUFBYSxDQUFDLElBQUlBLE9BQU0sQ0FBQztBQUFBLFFBQ3ZDO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxvQkFBb0I7QUFBQSxNQUMzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLFNBQVMsWUFBWTtBQUNuQixlQUFPLEtBQUssV0FBVyxTQUFTLFVBQVU7QUFBQSxNQUM1QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsY0FBYyxZQUFZO0FBQ3hCLGVBQU8sS0FBSyxXQUFXLGNBQWMsVUFBVTtBQUFBLE1BQ2pEO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxlQUFlO0FBQ2IsZUFBTyxLQUFLLFdBQVcsUUFBUTtBQUFBLE1BQ2pDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUssV0FBVyxjQUFjO0FBQUEsTUFDdkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLHVCQUF1QjtBQUNyQixlQUFPLEtBQUssV0FBVyxxQkFBcUI7QUFBQSxNQUM5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFlBQVk7QUFDVixZQUFJLEtBQUssU0FBUztBQUNoQixpQkFBTyxLQUFLO0FBQUEsUUFDZDtBQUNBLFlBQUlHLFVBQVMsS0FBSztBQUVsQixZQUFJLEtBQUssaUJBQWlCLFlBQVk7QUFDcEMsZ0JBQU0sT0FBTyxLQUFLLFFBQVE7QUFDMUIsZ0JBQU0sZ0JBQWdCLEtBQUssV0FBVyxRQUFRO0FBQzlDLGNBQUksQ0FBQyxRQUFRLENBQUMsZUFBZTtBQUMzQixtQkFBTztBQUFBLFVBQ1Q7QUFDQSxVQUFBQSxVQUFTQSxRQUFPLE1BQU07QUFDdEIsY0FDRSxLQUFLLGlCQUFpQixlQUN0QixLQUFLLGlCQUFpQixnQkFDdEI7QUFDQSxZQUFBQSxRQUFPLENBQUMsSUFBSSxjQUFjLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSUEsUUFBTyxDQUFDO0FBQUEsVUFDbkQ7QUFDQSxjQUNFLEtBQUssaUJBQWlCLGlCQUN0QixLQUFLLGlCQUFpQixnQkFDdEI7QUFDQSxZQUFBQSxRQUFPLENBQUMsSUFBSSxjQUFjLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSUEsUUFBTyxDQUFDO0FBQUEsVUFDbkQ7QUFBQSxRQUNGO0FBQ0EsYUFBSyxVQUFVQTtBQUNmLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxTQUFTO0FBQ1AsZUFBTyxLQUFLLFdBQVcsT0FBTztBQUFBLE1BQ2hDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU8sQ0FBQyxLQUFLLFFBQVEsS0FBSyxXQUFXLFFBQVEsSUFBSSxLQUFLO0FBQUEsTUFDeEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXO0FBQ1QsY0FBTUgsU0FBUSxLQUFLLGNBQWM7QUFDakMsWUFBSSxLQUFLLE9BQU87QUFDZCxpQkFBTyxLQUFLLE1BQU0sQ0FBQyxJQUFJQSxPQUFNLENBQUM7QUFBQSxRQUNoQztBQUNBLFlBQUksS0FBSyxXQUFXLGNBQWMsS0FBSyxtQkFBVyxRQUFRO0FBQ3hELGlCQUFPLEtBQUssV0FBVyxRQUFRLEVBQUUsQ0FBQyxJQUFJQSxPQUFNLENBQUM7QUFBQSxRQUMvQztBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGNBQU1BLFNBQVEsS0FBSyxjQUFjO0FBQ2pDLFlBQUksS0FBSyxPQUFPO0FBQ2QsaUJBQU8sS0FBSyxNQUFNLENBQUMsSUFBSUEsT0FBTSxDQUFDO0FBQUEsUUFDaEM7QUFDQSxZQUFJLEtBQUssV0FBVyxjQUFjLEtBQUssbUJBQVcsUUFBUTtBQUN4RCxpQkFBTyxLQUFLLFdBQVcsUUFBUSxFQUFFLENBQUMsSUFBSUEsT0FBTSxDQUFDO0FBQUEsUUFDL0M7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsU0FBU0EsUUFBTztBQUNkLGVBQU8sS0FBSztBQUNaLGNBQU0sU0FBU0EsTUFBSztBQUFBLE1BQ3RCO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxrQkFBa0IsVUFBVTtBQUMxQixhQUFLLFdBQVcsaUJBQWlCLGtCQUFVLFFBQVEsUUFBUTtBQUFBLE1BQzdEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLE9BQU87QUFDTCxhQUFLLFdBQVcsS0FBSztBQUFBLE1BQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxvQkFBb0IsVUFBVTtBQUM1QixhQUFLLFdBQVcsb0JBQW9CLGtCQUFVLFFBQVEsUUFBUTtBQUFBLE1BQ2hFO0FBQUEsTUFFQSxRQUFRO0FBQ04sZUFBTyxLQUFLLFdBQVcsTUFBTTtBQUFBLE1BQy9CO0FBQUEsSUFDRjtBQUVBLElBQU8sZUFBUTtBQUFBO0FBQUE7OztBQ3pqQmYsSUF3Qk0sb0JBZ0RBLE1BNmlCQztBQXJuQlA7QUFBQTtBQUdBO0FBQ0E7QUFvQkEsSUFBTSxxQkFBcUI7QUFnRDNCLElBQU0sT0FBTixNQUFNLE1BQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUlULFlBQVksU0FBUztBQUNuQixrQkFBVSxXQUFXLENBQUM7QUFNdEIsYUFBSyxRQUFRLFFBQVE7QUFNckIsYUFBSyxZQUFZLFFBQVE7QUFNekIsYUFBSyxrQkFBa0IsUUFBUTtBQU0vQixhQUFLLFNBQVMsUUFBUTtBQU10QixhQUFLLGNBQWMsT0FBTyxRQUFRLFVBQVUsU0FBWSxRQUFRLFFBQVEsQ0FBQztBQU16RSxhQUFLLFFBQVEsUUFBUTtBQU1yQixhQUFLLGFBQWEsUUFBUTtBQU0xQixhQUFLLFdBQVcsUUFBUTtBQU14QixhQUFLLFVBQVUsUUFBUTtBQU12QixhQUFLLGdCQUFnQixRQUFRO0FBTTdCLGFBQUssUUFDSCxRQUFRLFNBQVMsU0FDYixRQUFRLE9BQ1IsSUFBSSxhQUFLLEVBQUMsT0FBTyxtQkFBa0IsQ0FBQztBQU0xQyxhQUFLLFlBQ0gsUUFBUSxhQUFhLFNBQVksUUFBUSxXQUFXLEtBQUssS0FBSztBQU1oRSxhQUFLLGFBQ0gsUUFBUSxjQUFjLFNBQVksUUFBUSxZQUFZO0FBTXhELGFBQUssWUFBWSxDQUFDLENBQUMsUUFBUTtBQU0zQixhQUFLLFVBQVUsUUFBUSxXQUFXLFNBQVksUUFBUSxTQUFTO0FBTS9ELGFBQUssV0FBVyxRQUFRLFlBQVksU0FBWSxRQUFRLFVBQVU7QUFNbEUsYUFBSyxXQUFXLFFBQVEsWUFBWSxTQUFZLFFBQVEsVUFBVTtBQU1sRSxhQUFLLGtCQUFrQixRQUFRLGlCQUMzQixRQUFRLGlCQUNSO0FBTUosYUFBSyxvQkFBb0IsUUFBUSxtQkFDN0IsUUFBUSxtQkFDUjtBQU1KLGFBQUssV0FBVyxRQUFRLFlBQVksU0FBWSxPQUFPLFFBQVE7QUFNL0QsYUFBSyxpQkFBaUIsUUFBUTtBQUFBLE1BQ2hDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsUUFBUTtBQUNOLGNBQU1JLFNBQVEsS0FBSyxTQUFTO0FBQzVCLGVBQU8sSUFBSSxNQUFLO0FBQUEsVUFDZCxNQUFNLEtBQUssUUFBUTtBQUFBLFVBQ25CLFdBQVcsS0FBSyxhQUFhO0FBQUEsVUFDN0IsUUFBUSxLQUFLLFVBQVU7QUFBQSxVQUN2QixVQUFVLEtBQUssWUFBWTtBQUFBLFVBQzNCLFVBQVUsS0FBSyxZQUFZO0FBQUEsVUFDM0IsVUFBVSxLQUFLLFlBQVk7QUFBQSxVQUMzQixnQkFBZ0IsS0FBSyxrQkFBa0I7QUFBQSxVQUN2QyxPQUFPLE1BQU0sUUFBUUEsTUFBSyxJQUFJQSxPQUFNLE1BQU0sSUFBSUE7QUFBQSxVQUM5QyxNQUFNLEtBQUssUUFBUTtBQUFBLFVBQ25CLFdBQVcsS0FBSyxhQUFhO0FBQUEsVUFDN0IsU0FBUyxLQUFLLFdBQVc7QUFBQSxVQUN6QixjQUFjLEtBQUssZ0JBQWdCO0FBQUEsVUFDbkMsTUFBTSxLQUFLLFFBQVEsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNLElBQUk7QUFBQSxVQUNoRCxRQUFRLEtBQUssVUFBVSxJQUFJLEtBQUssVUFBVSxFQUFFLE1BQU0sSUFBSTtBQUFBLFVBQ3RELFNBQVMsS0FBSyxXQUFXO0FBQUEsVUFDekIsU0FBUyxLQUFLLFdBQVc7QUFBQSxVQUN6QixnQkFBZ0IsS0FBSyxrQkFBa0IsSUFDbkMsS0FBSyxrQkFBa0IsRUFBRSxNQUFNLElBQy9CO0FBQUEsVUFDSixrQkFBa0IsS0FBSyxvQkFBb0IsSUFDdkMsS0FBSyxvQkFBb0IsRUFBRSxNQUFNLElBQ2pDO0FBQUEsVUFDSixTQUFTLEtBQUssV0FBVyxLQUFLO0FBQUEsVUFDOUIsZUFBZSxLQUFLLGlCQUFpQjtBQUFBLFFBQ3ZDLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsY0FBYztBQUNaLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGNBQWM7QUFDWixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsZUFBZTtBQUNiLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZO0FBQ1YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGFBQWE7QUFDWCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsYUFBYTtBQUNYLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG9CQUFvQjtBQUNsQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsY0FBYztBQUNaLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGVBQWU7QUFDYixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsYUFBYTtBQUNYLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxrQkFBa0I7QUFDaEIsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG9CQUFvQjtBQUNsQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0Esc0JBQXNCO0FBQ3BCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxhQUFhO0FBQ1gsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG1CQUFtQjtBQUNqQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxZQUFZLFVBQVU7QUFDcEIsYUFBSyxZQUFZO0FBQUEsTUFDbkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFFBQVEsTUFBTTtBQUNaLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFlBQVksVUFBVTtBQUNwQixhQUFLLFlBQVk7QUFBQSxNQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsV0FBVyxTQUFTO0FBQ2xCLGFBQUssV0FBVztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxXQUFXLFNBQVM7QUFDbEIsYUFBSyxXQUFXO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGFBQWEsV0FBVztBQUN0QixhQUFLLGFBQWE7QUFBQSxNQUNwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFVBQVUsUUFBUTtBQUNoQixhQUFLLFVBQVU7QUFBQSxNQUNqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsa0JBQWtCLGdCQUFnQjtBQUNoQyxhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxRQUFRLE1BQU07QUFDWixhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxZQUFZLFVBQVU7QUFDcEIsYUFBSyxZQUFZO0FBQUEsTUFDbkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFNBQVNBLFFBQU87QUFDZCxhQUFLLFNBQVNBO0FBQ2QsYUFBSyxjQUFjLE9BQU9BLFdBQVUsU0FBWUEsU0FBUSxDQUFDO0FBQUEsTUFDM0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFVBQVUsUUFBUTtBQUNoQixhQUFLLFVBQVU7QUFBQSxNQUNqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsUUFBUSxNQUFNO0FBQ1osYUFBSyxRQUFRO0FBQUEsTUFDZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsYUFBYSxXQUFXO0FBQ3RCLGFBQUssYUFBYTtBQUFBLE1BQ3BCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxXQUFXLFNBQVM7QUFDbEIsYUFBSyxXQUFXO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGdCQUFnQixjQUFjO0FBQzVCLGFBQUssZ0JBQWdCO0FBQUEsTUFDdkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGtCQUFrQixNQUFNO0FBQ3RCLGFBQUssa0JBQWtCO0FBQUEsTUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLG9CQUFvQixRQUFRO0FBQzFCLGFBQUssb0JBQW9CO0FBQUEsTUFDM0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFdBQVcsU0FBUztBQUNsQixhQUFLLFdBQVc7QUFBQSxNQUNsQjtBQUFBLElBQ0Y7QUFFQSxJQUFPLGVBQVE7QUFBQTtBQUFBOzs7QUMxZFIsU0FBUyxTQUFTLE1BQU07QUFDN0IsUUFBTUMsU0FBUSxDQUFDO0FBQ2YsYUFBVyxhQUFhLFlBQVk7QUFDbEMsUUFBSSxhQUFhLE1BQU0sU0FBUyxHQUFHO0FBQ2pDLE1BQUFBLE9BQU0sS0FBSyxVQUFVLFNBQVMsQ0FBQztBQUFBLElBQ2pDO0FBQUEsRUFDRjtBQUNBLE1BQUlBLE9BQU0sV0FBVyxHQUFHO0FBQ3RCLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSUEsT0FBTSxTQUFTLEdBQUc7QUFDcEIsV0FBT0EsT0FBTSxLQUFLLE1BQU07QUFBQSxFQUMxQjtBQUNBLFNBQU9BLE9BQU0sTUFBTSxHQUFHLEVBQUUsRUFBRSxLQUFLLElBQUksSUFBSSxVQUFVQSxPQUFNQSxPQUFNLFNBQVMsQ0FBQztBQUN6RTtBQU9PLFNBQVMsYUFBYSxPQUFPLFVBQVU7QUFDNUMsVUFBUSxRQUFRLGNBQWM7QUFDaEM7QUFPTyxTQUFTLGFBQWEsU0FBUyxXQUFXO0FBQy9DLFNBQU8sQ0FBQyxFQUFFLFVBQVU7QUFDdEI7QUFPTyxTQUFTLE9BQU8sTUFBTSxVQUFVO0FBQ3JDLFNBQU8sU0FBUztBQUNsQjtBQThDTyxTQUFTLG9CQUFvQjtBQUNsQyxTQUFPO0FBQUEsSUFDTCxXQUFXLG9CQUFJLElBQUk7QUFBQSxJQUNuQixZQUFZLG9CQUFJLElBQUk7QUFBQSxJQUNwQixXQUFXO0FBQUEsSUFDWCxjQUFjO0FBQUEsSUFDZCxPQUFPLENBQUM7QUFBQSxFQUNWO0FBQ0Y7QUFNQSxTQUFTLGdCQUFnQixVQUFVO0FBQ2pDLFVBQVEsVUFBVTtBQUFBLElBQ2hCLEtBQUs7QUFDSCxhQUFPO0FBQUEsSUFDVCxLQUFLO0FBQ0gsYUFBTztBQUFBLElBQ1QsS0FBSztBQUNILGFBQU87QUFBQSxJQUNULEtBQUs7QUFDSCxhQUFPO0FBQUEsSUFDVCxLQUFLO0FBQ0gsYUFBTztBQUFBLElBQ1Q7QUFDRSxZQUFNLElBQUksTUFBTSwyQkFBMkIsUUFBUSxFQUFFO0FBQUEsRUFDekQ7QUFDRjtBQVlPLFNBQVNDLE9BQU0sU0FBUyxTQUFTLFVBQVU7QUFDaEQsVUFBUSxPQUFPLFNBQVM7QUFBQSxJQUN0QixLQUFLLFdBQVc7QUFDZCxhQUFPLElBQUksa0JBQWtCLGFBQWEsT0FBTztBQUFBLElBQ25EO0FBQUEsSUFDQSxLQUFLLFVBQVU7QUFDYixhQUFPLElBQUk7QUFBQSxRQUNULGFBQWEsV0FBVyxXQUFXO0FBQUEsUUFDbkM7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLElBQ0EsS0FBSyxVQUFVO0FBQ2IsVUFBSUMsUUFBTztBQUNYLFVBQUksY0FBYyxPQUFPLEdBQUc7QUFDMUIsUUFBQUEsU0FBUTtBQUFBLE1BQ1Y7QUFFQSxVQUFJLENBQUMsT0FBT0EsUUFBTyxVQUFVLFFBQVEsR0FBRztBQUN0QyxRQUFBQSxTQUFRO0FBQUEsTUFDVjtBQUNBLGFBQU8sSUFBSSxrQkFBa0JBLE9BQU0sT0FBTztBQUFBLElBQzVDO0FBQUEsSUFDQSxTQUFTO0FBQUEsSUFFVDtBQUFBLEVBQ0Y7QUFFQSxNQUFJLENBQUMsTUFBTSxRQUFRLE9BQU8sR0FBRztBQUMzQixVQUFNLElBQUksTUFBTSxrREFBa0Q7QUFBQSxFQUNwRTtBQUVBLE1BQUksUUFBUSxXQUFXLEdBQUc7QUFDeEIsVUFBTSxJQUFJLE1BQU0sa0JBQWtCO0FBQUEsRUFDcEM7QUFFQSxNQUFJLE9BQU8sUUFBUSxDQUFDLE1BQU0sVUFBVTtBQUNsQyxXQUFPLG9CQUFvQixTQUFTLFNBQVMsUUFBUTtBQUFBLEVBQ3ZEO0FBRUEsYUFBVyxRQUFRLFNBQVM7QUFDMUIsUUFBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixZQUFNLElBQUksTUFBTSw4QkFBOEI7QUFBQSxJQUNoRDtBQUFBLEVBQ0Y7QUFFQSxNQUFJLE9BQU87QUFDWCxNQUFJLFFBQVEsV0FBVyxHQUFHO0FBQ3hCLFlBQVE7QUFBQSxFQUNWLFdBQVcsUUFBUSxXQUFXLEtBQUssUUFBUSxXQUFXLEdBQUc7QUFDdkQsWUFBUTtBQUFBLEVBQ1Y7QUFDQSxNQUFJLFVBQVU7QUFDWixZQUFRO0FBQUEsRUFDVjtBQUNBLFNBQU8sSUFBSSxrQkFBa0IsTUFBTSxPQUFPO0FBQzVDO0FBMlVBLFNBQVMsWUFBWSxTQUFTLFNBQVM7QUFDckMsUUFBTSxNQUFNRCxPQUFNLFFBQVEsQ0FBQyxHQUFHLE9BQU87QUFDckMsTUFBSSxFQUFFLGVBQWUsb0JBQW9CO0FBQ3ZDLFVBQU0sSUFBSSxNQUFNLCtDQUErQztBQUFBLEVBQ2pFO0FBQ0EsTUFBSSxPQUFPLElBQUksVUFBVSxVQUFVO0FBQ2pDLFVBQU0sSUFBSSxNQUFNLDhDQUE4QztBQUFBLEVBQ2hFO0FBQ0EsVUFBUSxXQUFXLElBQUksSUFBSSxLQUFLO0FBQ2hDLE1BQUksUUFBUSxXQUFXLEdBQUc7QUFDeEIsVUFBTSxPQUFPQSxPQUFNLFFBQVEsQ0FBQyxHQUFHLE9BQU87QUFDdEMsV0FBTyxDQUFDLEtBQUssSUFBSTtBQUFBLEVBQ25CO0FBQ0EsU0FBTyxDQUFDLEdBQUc7QUFDYjtBQUtBLFNBQVMsWUFBWSxTQUFTLFNBQVMsWUFBWSxVQUFVO0FBQzNELFFBQU0sVUFBVSxRQUFRLENBQUM7QUFDekIsTUFBSSxPQUFPLFlBQVksVUFBVTtBQUMvQixVQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFBQSxFQUNoRTtBQUNBLFVBQVEsVUFBVSxJQUFJLE9BQU87QUFDN0IsTUFDRSxFQUFFLGVBQWUsUUFBUSxVQUN6QixRQUFRLE1BQU0sVUFBVSxPQUFPLE1BQU0sUUFDckM7QUFDQSxXQUFPLENBQUMsSUFBSSxrQkFBa0IsU0FBUyxPQUFPLENBQUM7QUFBQSxFQUNqRDtBQUNBLFFBQU0sZUFBZSxRQUFRLE1BQU0sVUFBVSxPQUFPO0FBQ3BELFFBQU07QUFBQTtBQUFBLElBQXdDQSxPQUFNLGNBQWMsT0FBTztBQUFBO0FBQ3pFLE1BQUksUUFBUTtBQUNaLE1BQUksWUFBWSxDQUFDLGFBQWEsVUFBVSxJQUFJLElBQUksR0FBRztBQUNqRCxVQUFNLElBQUk7QUFBQSxNQUNSLGdCQUFnQixPQUFPLGFBQWE7QUFBQSxRQUNsQyxJQUFJO0FBQUEsTUFDTixDQUFDLHlDQUF5QyxTQUFTLFFBQVEsQ0FBQztBQUFBLElBQzlEO0FBQUEsRUFDRjtBQUNBLFNBQU8sQ0FBQyxHQUFHO0FBQ2I7QUFLQSxTQUFTLGNBQWMsU0FBUyxTQUFTO0FBQ3ZDLFVBQVEsWUFBWTtBQUN0QjtBQUtBLFNBQVMsaUJBQWlCLFNBQVMsU0FBUztBQUMxQyxVQUFRLGVBQWU7QUFDekI7QUFLQSxTQUFTLFdBQVcsU0FBUyxTQUFTO0FBQ3BDLFFBQU0sWUFBWSxRQUFRLENBQUM7QUFDM0IsTUFBSSxRQUFRLFdBQVcsR0FBRztBQUN4QixVQUFNLElBQUksTUFBTSw2QkFBNkIsU0FBUyxZQUFZO0FBQUEsRUFDcEU7QUFDQSxTQUFPLENBQUM7QUFDVjtBQU9BLFNBQVMsY0FBYyxTQUFTLFNBQVM7QUFDdkMsU0FBTyxTQUFVLFNBQVMsU0FBUztBQUNqQyxVQUFNLFlBQVksUUFBUSxDQUFDO0FBQzNCLFVBQU0sV0FBVyxRQUFRLFNBQVM7QUFDbEMsUUFBSSxZQUFZLFNBQVM7QUFDdkIsVUFBSSxhQUFhLFNBQVM7QUFDeEIsY0FBTSxTQUFTLFlBQVksSUFBSSxLQUFLO0FBQ3BDLGNBQU0sSUFBSTtBQUFBLFVBQ1IsWUFBWSxPQUFPLFlBQVksTUFBTSxRQUFRLFNBQVMsU0FBUyxRQUFRO0FBQUEsUUFDekU7QUFBQSxNQUNGO0FBQUEsSUFDRixXQUFXLFdBQVcsV0FBVyxXQUFXLFNBQVM7QUFDbkQsWUFBTSxRQUNKLFlBQVksV0FDUixHQUFHLE9BQU8sYUFDVixHQUFHLE9BQU8sT0FBTyxPQUFPO0FBQzlCLFlBQU0sSUFBSTtBQUFBLFFBQ1IsWUFBWSxLQUFLLGtCQUFrQixTQUFTLFNBQVMsUUFBUTtBQUFBLE1BQy9EO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjtBQU1BLFNBQVMsZ0JBQWdCLFNBQVM7QUFDaEMsU0FBTyxTQUFVLFNBQVMsU0FBUztBQUNqQyxVQUFNLFlBQVksUUFBUSxDQUFDO0FBQzNCLFVBQU0sV0FBVyxRQUFRLFNBQVM7QUFJbEMsVUFBTSxPQUFPLElBQUksTUFBTSxRQUFRO0FBQy9CLGFBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxFQUFFLEdBQUc7QUFDakMsWUFBTSxhQUFhQSxPQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsT0FBTztBQUNoRCxVQUFJLENBQUMsYUFBYSxTQUFTLFdBQVcsSUFBSSxHQUFHO0FBQzNDLGNBQU0sVUFBVSxTQUFTLE9BQU87QUFDaEMsY0FBTSxlQUFlLFNBQVMsV0FBVyxJQUFJO0FBQzdDLGNBQU0sSUFBSTtBQUFBLFVBQ1IsZ0NBQWdDLENBQUMsT0FBTyxTQUFTLG1CQUN0QyxPQUFPLGlCQUFpQixZQUFZO0FBQUEsUUFDakQ7QUFBQSxNQUNGO0FBQ0EsaUJBQVcsUUFBUTtBQUNuQixXQUFLLENBQUMsSUFBSTtBQUFBLElBQ1o7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBS0EsU0FBUyxlQUFlLFNBQVMsU0FBUyxZQUFZO0FBQ3BELFFBQU0sWUFBWSxRQUFRLENBQUM7QUFDM0IsUUFBTSxXQUFXLFFBQVEsU0FBUztBQUdsQyxNQUFJLFdBQVc7QUFDZixXQUFTLElBQUksR0FBRyxJQUFJLFdBQVcsUUFBUSxFQUFFLEdBQUc7QUFDMUMsZ0JBQVksV0FBVyxDQUFDLEVBQUU7QUFBQSxFQUM1QjtBQUVBLE1BQUksYUFBYSxVQUFVO0FBQ3pCLFVBQU0sSUFBSTtBQUFBLE1BQ1Isa0RBQWtELFNBQVM7QUFBQSxJQUM3RDtBQUFBLEVBQ0Y7QUFHQSxRQUFNLE9BQU8sSUFBSSxNQUFNLFFBQVE7QUFDL0IsV0FBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLEVBQUUsR0FBRztBQUNqQyxTQUFLLENBQUMsSUFBSUEsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLFNBQVMsUUFBUTtBQUFBLEVBQ25EO0FBQ0EsU0FBTztBQUNUO0FBS0EsU0FBUyxZQUFZLFNBQVMsU0FBUztBQUNyQyxRQUFNLFlBQVksUUFBUSxDQUFDO0FBQzNCLFFBQU0sV0FBVyxRQUFRLFNBQVM7QUFDbEMsTUFBSSxXQUFXLE1BQU0sR0FBRztBQUN0QixVQUFNLElBQUk7QUFBQSxNQUNSLHlEQUF5RCxTQUFTLFNBQVMsS0FBSztBQUFBLFFBQzlFO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFDRjtBQUtBLFNBQVMsYUFBYSxTQUFTLFNBQVM7QUFDdEMsUUFBTSxZQUFZLFFBQVEsQ0FBQztBQUMzQixRQUFNLFdBQVcsUUFBUSxTQUFTO0FBQ2xDLE1BQUksV0FBVyxNQUFNLEdBQUc7QUFDdEIsVUFBTSxJQUFJO0FBQUEsTUFDUiwwREFBMEQsU0FBUyxTQUFTLEtBQUs7QUFBQSxRQUMvRTtBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0g7QUFBQSxFQUNGO0FBQ0Y7QUFLQSxTQUFTLGVBQWUsU0FBUyxTQUFTLFlBQVksVUFBVTtBQUM5RCxRQUFNLFlBQVksUUFBUSxTQUFTO0FBRW5DLFFBQU0sUUFBUUEsT0FBTSxRQUFRLENBQUMsR0FBRyxPQUFPO0FBQ3ZDLE1BQUksWUFBWSxNQUFNO0FBQ3RCLFFBQU0sV0FBV0EsT0FBTSxRQUFRLFFBQVEsU0FBUyxDQUFDLEdBQUcsT0FBTztBQUMzRCxNQUFJLGFBQ0YsYUFBYSxTQUFZLFdBQVcsU0FBUyxPQUFPLFNBQVM7QUFHL0QsUUFBTSxPQUFPLElBQUksTUFBTSxZQUFZLENBQUM7QUFDcEMsV0FBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLEdBQUcsS0FBSyxHQUFHO0FBQ3pDLFVBQU0sUUFBUUEsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLE9BQU87QUFDM0MsVUFBTSxTQUFTQSxPQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsT0FBTztBQUM1QyxpQkFBYSxNQUFNO0FBQ25CLGtCQUFjLE9BQU87QUFDckIsU0FBSyxDQUFDLElBQUk7QUFDVixTQUFLLElBQUksQ0FBQyxJQUFJO0FBQUEsRUFDaEI7QUFHQSxRQUFNLG9CQUFvQixhQUFhLGFBQWE7QUFDcEQsTUFBSSxDQUFDLGFBQWEsbUJBQW1CLFNBQVMsR0FBRztBQUMvQyxVQUFNLElBQUk7QUFBQSxNQUNSLDZCQUE2QjtBQUFBLFFBQzNCO0FBQUEsTUFDRixDQUFDLHVDQUNVLFNBQVMsU0FBUyxDQUFDO0FBQUEsSUFDaEM7QUFBQSxFQUNGO0FBQ0EsZUFBYTtBQUNiLE1BQUksT0FBTyxZQUFZLFFBQVEsR0FBRztBQUNoQyxVQUFNLElBQUk7QUFBQSxNQUNSLDRFQUNFLEtBQUssVUFBVSxPQUFPO0FBQUEsSUFDMUI7QUFBQSxFQUNGO0FBR0EsV0FBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLEdBQUcsS0FBSyxHQUFHO0FBQ3pDLFVBQU0sUUFBUUEsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLFNBQVMsU0FBUztBQUN0RCxVQUFNLFNBQVNBLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxTQUFTLFVBQVU7QUFDeEQsU0FBSyxDQUFDLElBQUk7QUFDVixTQUFLLElBQUksQ0FBQyxJQUFJO0FBQUEsRUFDaEI7QUFFQSxTQUFPO0FBQUEsSUFDTEEsT0FBTSxRQUFRLENBQUMsR0FBRyxTQUFTLFNBQVM7QUFBQSxJQUNwQyxHQUFHO0FBQUEsSUFDSEEsT0FBTSxRQUFRLFFBQVEsU0FBUyxDQUFDLEdBQUcsU0FBUyxVQUFVO0FBQUEsRUFDeEQ7QUFDRjtBQUtBLFNBQVMscUJBQXFCLFNBQVMsU0FBUyxZQUFZLFVBQVU7QUFDcEUsUUFBTSxvQkFBb0IsUUFBUSxDQUFDO0FBQ25DLE1BQUk7QUFDSixVQUFRLGtCQUFrQixDQUFDLEdBQUc7QUFBQSxJQUM1QixLQUFLO0FBQ0gsc0JBQWdCO0FBQ2hCO0FBQUEsSUFDRixLQUFLO0FBQ0gsc0JBQWdCLGtCQUFrQixDQUFDO0FBQ25DLFVBQUksT0FBTyxrQkFBa0IsVUFBVTtBQUNyQyxjQUFNLElBQUk7QUFBQSxVQUNSLDZEQUNXLEtBQUssVUFBVSxhQUFhLENBQUM7QUFBQSxRQUMxQztBQUFBLE1BQ0Y7QUFDQTtBQUFBLElBQ0Y7QUFDRSxzQkFBZ0I7QUFBQSxFQUNwQjtBQUNBLE1BQUksQ0FBQyxlQUFlO0FBQ2xCLFVBQU0sSUFBSTtBQUFBLE1BQ1IsK0JBQStCLEtBQUssVUFBVSxpQkFBaUIsQ0FBQztBQUFBLElBQ2xFO0FBQUEsRUFDRjtBQUNBLGtCQUFnQkEsT0FBTSxlQUFlLE9BQU87QUFHNUMsTUFBSSxRQUFRQSxPQUFNLFFBQVEsQ0FBQyxHQUFHLE9BQU87QUFDckMsTUFBSSxDQUFDLGFBQWEsWUFBWSxNQUFNLElBQUksR0FBRztBQUN6QyxVQUFNLElBQUk7QUFBQSxNQUNSLHVFQUNXLFNBQVMsTUFBTSxJQUFJLENBQUM7QUFBQSxJQUNqQztBQUFBLEVBQ0Y7QUFDQSxVQUFRQSxPQUFNLFFBQVEsQ0FBQyxHQUFHLFNBQVMsVUFBVTtBQUU3QyxRQUFNLE9BQU8sSUFBSSxNQUFNLFFBQVEsU0FBUyxDQUFDO0FBQ3pDLFdBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUssR0FBRztBQUN2QyxRQUFJLE9BQU9BLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxPQUFPO0FBQ3hDLFFBQUksQ0FBQyxhQUFhLFlBQVksS0FBSyxJQUFJLEdBQUc7QUFDeEMsWUFBTSxJQUFJO0FBQUEsUUFDUix5RkFDVyxTQUFTLEtBQUssSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUM7QUFBQSxNQUNyRDtBQUFBLElBQ0Y7QUFDQSxRQUFJLFNBQVNBLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxPQUFPO0FBQzFDLFFBQUksQ0FBQyxhQUFhLGFBQWEsV0FBVyxPQUFPLElBQUksR0FBRztBQUN0RCxZQUFNLElBQUk7QUFBQSxRQUNSLDZGQUNXLFNBQVMsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQztBQUFBLE1BQ3ZEO0FBQUEsSUFDRjtBQUVBLFdBQU9BLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxTQUFTLFVBQVU7QUFDaEQsYUFBU0EsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLFNBQVMsYUFBYSxTQUFTO0FBQzlELFNBQUssQ0FBQyxJQUFJO0FBQ1YsU0FBSyxJQUFJLENBQUMsSUFBSTtBQUFBLEVBQ2hCO0FBRUEsU0FBTyxDQUFDLGVBQWUsT0FBTyxHQUFHLElBQUk7QUFDdkM7QUFLQSxTQUFTLGNBQWMsU0FBUyxTQUFTLFlBQVksVUFBVTtBQUM3RCxRQUFNLFdBQVdBLE9BQU0sUUFBUSxRQUFRLFNBQVMsQ0FBQyxHQUFHLFNBQVMsUUFBUTtBQUNyRSxNQUFJLGFBQ0YsYUFBYSxTQUFZLFdBQVcsU0FBUyxPQUFPLFNBQVM7QUFHL0QsUUFBTSxPQUFPLElBQUksTUFBTSxRQUFRLFNBQVMsQ0FBQztBQUN6QyxXQUFTLElBQUksR0FBRyxJQUFJLEtBQUssU0FBUyxHQUFHLEtBQUssR0FBRztBQUMzQyxVQUFNLFlBQVlBLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxPQUFPO0FBQy9DLFVBQU0sU0FBU0EsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLFNBQVMsUUFBUTtBQUN0RCxRQUFJLENBQUMsYUFBYSxhQUFhLFVBQVUsSUFBSSxHQUFHO0FBQzlDLFlBQU0sSUFBSTtBQUFBLFFBQ1IsNEVBQ1csU0FBUyxVQUFVLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztBQUFBLE1BQ3REO0FBQUEsSUFDRjtBQUNBLGtCQUFjLE9BQU87QUFDckIsU0FBSyxDQUFDLElBQUk7QUFDVixTQUFLLElBQUksQ0FBQyxJQUFJO0FBQUEsRUFDaEI7QUFFQSxNQUFJLE9BQU8sWUFBWSxRQUFRLEdBQUc7QUFDaEMsVUFBTSxJQUFJO0FBQUEsTUFDUiwyRUFDRSxLQUFLLFVBQVUsT0FBTztBQUFBLElBQzFCO0FBQUEsRUFDRjtBQUdBLFdBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxTQUFTLEdBQUcsS0FBSyxHQUFHO0FBQzNDLFNBQUssSUFBSSxDQUFDLElBQUlBLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxTQUFTLFVBQVU7QUFBQSxFQUN6RDtBQUNBLE9BQUssS0FBSyxTQUFTLENBQUMsSUFBSUE7QUFBQSxJQUN0QixRQUFRLFFBQVEsU0FBUyxDQUFDO0FBQUEsSUFDMUI7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUVBLFNBQU87QUFDVDtBQUtBLFNBQVMsWUFBWSxTQUFTLFNBQVM7QUFFckMsTUFBSTtBQUFBO0FBQUEsSUFBK0IsUUFBUSxDQUFDO0FBQUE7QUFDNUMsTUFBSSxDQUFDLE1BQU0sUUFBUSxRQUFRLEdBQUc7QUFDNUIsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsTUFBSSxPQUFPLFNBQVMsQ0FBQyxNQUFNLFVBQVU7QUFDbkMsUUFBSSxTQUFTLENBQUMsTUFBTSxXQUFXO0FBQzdCLFlBQU0sSUFBSTtBQUFBLFFBQ1I7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFFBQUksQ0FBQyxNQUFNLFFBQVEsU0FBUyxDQUFDLENBQUMsR0FBRztBQUMvQixZQUFNLElBQUk7QUFBQSxRQUNSO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxlQUFXLFNBQVMsQ0FBQztBQUFBLEVBQ3ZCO0FBRUEsTUFBSSxhQUFhLGFBQWE7QUFDOUIsUUFBTSxPQUFPLElBQUksTUFBTSxTQUFTLE1BQU07QUFDdEMsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxVQUFNLE1BQU1BLE9BQU0sU0FBUyxDQUFDLEdBQUcsT0FBTztBQUN0QyxrQkFBYyxJQUFJO0FBQ2xCLFNBQUssQ0FBQyxJQUFJO0FBQUEsRUFDWjtBQUNBLE1BQUksT0FBTyxZQUFZLFFBQVEsR0FBRztBQUNoQyxVQUFNLElBQUk7QUFBQSxNQUNSLGtFQUNFLEtBQUssVUFBVSxPQUFPO0FBQUEsSUFDMUI7QUFBQSxFQUNGO0FBRUEsUUFBTSxTQUFTQSxPQUFNLFFBQVEsQ0FBQyxHQUFHLFNBQVMsVUFBVTtBQUNwRCxTQUFPLENBQUMsUUFBUSxHQUFHLElBQUk7QUFDekI7QUFLQSxTQUFTLGlCQUFpQixTQUFTLFNBQVM7QUFDMUMsUUFBTSxRQUFRQSxPQUFNLFFBQVEsQ0FBQyxHQUFHLFNBQVMsVUFBVTtBQUNuRCxNQUFJLE1BQU0sU0FBUyxZQUFZO0FBQzdCLFVBQU0sSUFBSTtBQUFBLE1BQ1Isd0RBQXdEO0FBQUEsUUFDdEQsTUFBTTtBQUFBLE1BQ1IsQ0FBQztBQUFBLElBQ0g7QUFBQSxFQUNGO0FBQ0EsUUFBTSxTQUFTLFFBQVEsQ0FBQztBQUN4QixNQUFJLENBQUMsTUFBTSxRQUFRLE1BQU0sR0FBRztBQUMxQixVQUFNLElBQUksTUFBTSxpREFBaUQ7QUFBQSxFQUNuRTtBQUNBLFFBQU0sZUFBZSxJQUFJLE1BQU0sT0FBTyxNQUFNO0FBQzVDLFdBQVMsSUFBSSxHQUFHLElBQUksYUFBYSxRQUFRLEtBQUs7QUFDNUMsVUFBTSxRQUFRQSxPQUFNLE9BQU8sQ0FBQyxHQUFHLFNBQVMsU0FBUztBQUNqRCxRQUFJLEVBQUUsaUJBQWlCLG9CQUFvQjtBQUN6QyxZQUFNLElBQUk7QUFBQSxRQUNSLDhCQUE4QixDQUFDO0FBQUEsTUFDakM7QUFBQSxJQUNGO0FBQ0EsUUFBSSxDQUFDLGFBQWEsTUFBTSxNQUFNLFNBQVMsR0FBRztBQUN4QyxZQUFNLElBQUk7QUFBQSxRQUNSLDhCQUE4QixDQUFDLGlDQUFpQztBQUFBLFVBQzlELE1BQU07QUFBQSxRQUNSLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQUNBLGlCQUFhLENBQUMsSUFBSTtBQUFBLEVBQ3BCO0FBQ0EsU0FBTyxDQUFDLE9BQU8sR0FBRyxZQUFZO0FBQ2hDO0FBU0EsU0FBUyxhQUFhLGVBQWUsZUFBZTtBQUNsRCxTQUFPLFNBQVUsU0FBUyxTQUFTLFVBQVU7QUFDM0MsVUFBTSxXQUFXLFFBQVEsQ0FBQztBQUMxQixRQUFJLGFBQWEsQ0FBQztBQUNsQixhQUFTLElBQUksR0FBRyxJQUFJLGNBQWMsUUFBUSxLQUFLO0FBQzdDLG1CQUNFLGNBQWMsQ0FBQyxFQUFFLFNBQVMsU0FBUyxZQUFZLFFBQVEsS0FBSztBQUFBLElBQ2hFO0FBQ0EsUUFBSSxhQUNGLE9BQU8sZUFBZSxhQUFhLFdBQVcsVUFBVSxJQUFJO0FBQzlELFFBQUksYUFBYSxRQUFXO0FBQzFCLFVBQUksQ0FBQyxhQUFhLFlBQVksUUFBUSxHQUFHO0FBQ3ZDLGNBQU0sSUFBSTtBQUFBLFVBQ1IsbURBQW1EO0FBQUEsWUFDakQ7QUFBQSxVQUNGLENBQUMsaUJBQWlCLFNBQVMsVUFBVSxDQUFDLGFBQWEsS0FBSztBQUFBLFlBQ3REO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDSDtBQUFBLE1BQ0Y7QUFDQSxvQkFBYztBQUFBLElBQ2hCO0FBQ0EsUUFBSSxlQUFlLFVBQVU7QUFDM0IsWUFBTSxJQUFJO0FBQUEsUUFDUiw0REFBNEQsS0FBSztBQUFBLFVBQy9EO0FBQUEsUUFDRixDQUFDO0FBQUEsTUFDSDtBQUFBLElBQ0Y7QUFDQSxXQUFPLElBQUksZUFBZSxZQUFZLFVBQVUsR0FBRyxVQUFVO0FBQUEsRUFDL0Q7QUFDRjtBQVFBLFNBQVMsb0JBQW9CLFNBQVMsU0FBUyxVQUFVO0FBQ3ZELFFBQU0sV0FBVyxRQUFRLENBQUM7QUFFMUIsUUFBTSxTQUFTLFFBQVEsUUFBUTtBQUMvQixNQUFJLENBQUMsUUFBUTtBQUNYLFVBQU0sSUFBSSxNQUFNLHFCQUFxQixRQUFRLEVBQUU7QUFBQSxFQUNqRDtBQUNBLFNBQU8sT0FBTyxTQUFTLFNBQVMsUUFBUTtBQUMxQztBQU9PLFNBQVMsb0JBQW9CLFVBQVU7QUFDNUMsTUFBSSxDQUFDLFVBQVU7QUFDYixXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sT0FBTyxTQUFTLFFBQVE7QUFDOUIsVUFBUSxNQUFNO0FBQUEsSUFDWixLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQ0gsYUFBTztBQUFBLElBQ1QsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUNIO0FBQUE7QUFBQSxRQUFzRCxLQUFLLFVBQVUsQ0FBQztBQUFBO0FBQUEsSUFDeEUsS0FBSztBQUNILGFBQU87QUFBQSxJQUNULEtBQUs7QUFDSCxhQUFPO0FBQUE7QUFBQSxRQUVILFNBQ0EsY0FBYyxFQUFFLENBQUM7QUFBQSxNQUNyQjtBQUFBLElBQ0Y7QUFDRSxhQUFPO0FBQUEsRUFDWDtBQUNGO0FBOXBDQSxJQWlJSSxVQUNTLFVBQ0EsYUFDQSxZQUNBLFlBQ0EsV0FDQSxpQkFDQSxVQUNBLFNBRVAsV0FTQSxZQXNETyxtQkFXQSxnQkFrSUEsS0F3RFA7QUEvWU47QUFBQTtBQUdBO0FBQ0E7QUE2SEEsSUFBSSxXQUFXO0FBQ1IsSUFBTSxXQUFXO0FBQ2pCLElBQU0sY0FBYyxLQUFLO0FBQ3pCLElBQU0sYUFBYSxLQUFLO0FBQ3hCLElBQU0sYUFBYSxLQUFLO0FBQ3hCLElBQU0sWUFBWSxLQUFLO0FBQ3ZCLElBQU0sa0JBQWtCLEtBQUs7QUFDN0IsSUFBTSxXQUFXLEtBQUs7QUFDdEIsSUFBTSxVQUFVLEtBQUssSUFBSSxHQUFHLFFBQVEsSUFBSTtBQUUvQyxJQUFNLFlBQVk7QUFBQSxNQUNoQixDQUFDLFdBQVcsR0FBRztBQUFBLE1BQ2YsQ0FBQyxVQUFVLEdBQUc7QUFBQSxNQUNkLENBQUMsVUFBVSxHQUFHO0FBQUEsTUFDZCxDQUFDLFNBQVMsR0FBRztBQUFBLE1BQ2IsQ0FBQyxlQUFlLEdBQUc7QUFBQSxNQUNuQixDQUFDLFFBQVEsR0FBRztBQUFBLElBQ2Q7QUFFQSxJQUFNLGFBQWEsT0FBTyxLQUFLLFNBQVMsRUFBRSxJQUFJLE1BQU0sRUFBRSxLQUFLLFNBQVM7QUFzRDdELElBQU0sb0JBQU4sTUFBd0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSzdCLFlBQVksTUFBTSxPQUFPO0FBQ3ZCLGFBQUssT0FBTztBQUNaLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNGO0FBRU8sSUFBTSxpQkFBTixNQUFxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU0xQixZQUFZLE1BQU0sYUFBYSxNQUFNO0FBQ25DLGFBQUssT0FBTztBQUNaLGFBQUssV0FBVztBQUNoQixhQUFLLE9BQU87QUFBQSxNQUNkO0FBQUEsSUFDRjtBQXVITyxJQUFNLE1BQU07QUFBQSxNQUNqQixLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxRQUFRO0FBQUEsTUFDUixjQUFjO0FBQUEsTUFDZCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxZQUFZO0FBQUEsTUFDWixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxVQUFVO0FBQUEsTUFDVixhQUFhO0FBQUEsTUFDYixzQkFBc0I7QUFBQSxNQUN0QixVQUFVO0FBQUEsTUFDVixtQkFBbUI7QUFBQSxNQUNuQixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixLQUFLO0FBQUEsTUFDTCxVQUFVO0FBQUEsTUFDVixPQUFPO0FBQUEsTUFDUCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxPQUFPO0FBQUEsTUFDUCxNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxhQUFhO0FBQUEsTUFDYixVQUFVO0FBQUEsTUFDVixNQUFNO0FBQUEsTUFDTixJQUFJO0FBQUEsTUFDSixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsSUFDWjtBQVVBLElBQU0sVUFBVTtBQUFBLE1BQ2QsQ0FBQyxJQUFJLEdBQUcsR0FBRztBQUFBLFFBQ1QsQ0FBQyxDQUFDLEdBQUcsUUFBUSxNQUFNO0FBQ2pCLGNBQUksYUFBYSxRQUFXO0FBQzFCLG1CQUFPO0FBQUE7QUFBQTtBQUFBLGNBRStCLFNBQVU7QUFBQSxZQUVoRDtBQUFBLFVBQ0Y7QUFDQSxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxRQUNBLGNBQWMsR0FBRyxDQUFDO0FBQUEsUUFDbEI7QUFBQSxNQUNGO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVCxDQUFDLENBQUMsUUFBUSxNQUFNLFNBQVM7QUFBQSxRQUN6QixjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsQ0FBQyxJQUFJLEVBQUUsR0FBRyxhQUFhLGFBQWEsWUFBWSxZQUFZLGFBQWE7QUFBQSxNQUN6RSxDQUFDLElBQUksTUFBTSxHQUFHO0FBQUEsUUFDWjtBQUFBLFFBQ0EsY0FBYyxHQUFHLFFBQVE7QUFBQSxRQUN6QixnQkFBZ0IsT0FBTztBQUFBLE1BQ3pCO0FBQUEsTUFDQSxDQUFDLElBQUksWUFBWSxHQUFHLGFBQWEsWUFBWSxZQUFZLGdCQUFnQjtBQUFBLE1BQ3pFLENBQUMsSUFBSSxVQUFVLEdBQUcsYUFBYSxZQUFZLFVBQVU7QUFBQSxNQUNyRCxDQUFDLElBQUksSUFBSSxHQUFHLGFBQWEsWUFBWSxVQUFVO0FBQUEsTUFDL0MsQ0FBQyxJQUFJLElBQUksR0FBRyxhQUFhLFlBQVksVUFBVTtBQUFBLE1BQy9DLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsUUFBUTtBQUFBLFFBQ3pCLGdCQUFnQixXQUFXO0FBQUEsTUFDN0I7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsUUFBUTtBQUFBLFFBQ3pCLGdCQUFnQixXQUFXO0FBQUEsTUFDN0I7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixXQUFXO0FBQUEsTUFDN0I7QUFBQSxNQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxRQUNYO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixPQUFPO0FBQUEsUUFDdkI7QUFBQSxNQUNGO0FBQUEsTUFDQSxDQUFDLElBQUksUUFBUSxHQUFHO0FBQUEsUUFDZDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsT0FBTztBQUFBLFFBQ3ZCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsQ0FBQyxJQUFJLFdBQVcsR0FBRztBQUFBLFFBQ2pCO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixPQUFPO0FBQUEsUUFDdkI7QUFBQSxNQUNGO0FBQUEsTUFDQSxDQUFDLElBQUksb0JBQW9CLEdBQUc7QUFBQSxRQUMxQjtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsT0FBTztBQUFBLFFBQ3ZCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsQ0FBQyxJQUFJLFFBQVEsR0FBRztBQUFBLFFBQ2Q7QUFBQSxRQUNBLGNBQWMsR0FBRyxDQUFDO0FBQUEsUUFDbEIsZ0JBQWdCLE9BQU87QUFBQSxRQUN2QjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLENBQUMsSUFBSSxpQkFBaUIsR0FBRztBQUFBLFFBQ3ZCO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixPQUFPO0FBQUEsUUFDdkI7QUFBQSxNQUNGO0FBQUEsTUFDQSxDQUFDLElBQUksUUFBUSxHQUFHO0FBQUEsUUFDZCxDQUFDLGVBQWU7QUFDZCxjQUFJLGFBQWEsYUFBYTtBQUM5QixtQkFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsS0FBSztBQUMxQywwQkFBYyxXQUFXLENBQUMsRUFBRTtBQUFBLFVBQzlCO0FBQ0EsaUJBQU87QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsUUFBUTtBQUFBLFFBQ3pCLGdCQUFnQixhQUFhLFNBQVM7QUFBQSxRQUN0QztBQUFBLE1BQ0Y7QUFBQSxNQUNBLENBQUMsSUFBSSxRQUFRLEdBQUc7QUFBQSxRQUNkLENBQUMsZUFBZTtBQUNkLGNBQUksT0FBTztBQUNYLG1CQUFTLElBQUksR0FBRyxJQUFJLFdBQVcsUUFBUSxLQUFLLEdBQUc7QUFDN0Msb0JBQVEsV0FBVyxDQUFDLEVBQUU7QUFBQSxVQUN4QjtBQUNBLGtCQUFRLFdBQVcsV0FBVyxTQUFTLENBQUMsRUFBRTtBQUMxQyxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxRQUNBLGNBQWMsR0FBRyxRQUFRO0FBQUEsUUFDekIsZ0JBQWdCLE9BQU87QUFBQSxRQUN2QjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLENBQUMsSUFBSSxNQUFNLEdBQUc7QUFBQSxRQUNaO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsUUFBUTtBQUFBLFFBQ3pCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxRQUFRLEdBQUc7QUFBQSxRQUNkO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxRQUNYO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxRQUNYO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxJQUFJLEdBQUc7QUFBQSxRQUNWO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxRQUNYO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxJQUFJLEdBQUc7QUFBQSxRQUNWO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxJQUFJLEdBQUc7QUFBQSxRQUNWO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7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QUNQLFVBQVU7QUFBQSxFQUNkLENBQUM7QUFDRCxNQUFJLFdBQVcsUUFBUTtBQUN2QixNQUFJO0FBQ0EsYUFBUyxHQUFHLGlCQUFpQixTQUFTLEtBQVU7QUFDNUMsY0FBUSxJQUFJLEdBQUc7QUFDZixZQUFNLFVBQVUsSUFBSTtBQUNwQixZQUFNLGFBQWEsSUFBSTtBQUN2QixjQUFRLFNBQVMsSUFBSSxjQUFNO0FBQUEsUUFDdkIsT0FBTyxJQUFJLGFBQUs7QUFBQSxVQUNaLE9BQU87QUFBQSxVQUNQLGFBQWE7QUFBQSxVQUNiLEtBQUs7QUFBQSxVQUNMLE9BQU87QUFBQSxRQUNYLENBQUM7QUFBQSxNQUNMLENBQUMsQ0FBQztBQUVGLFdBQUssVUFBVSxXQUFXLENBQUMsV0FBVyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7QUFBQSxJQUN6RSxDQUFDO0FBQUEsRUFDTCxTQUFTLEdBQUc7QUFDUixZQUFRLE1BQU0sQ0FBQztBQUFBLEVBQ25CO0FBRUEsV0FBUyxlQUFlO0FBRXBCLFVBQU0sQ0FBQ0MsTUFBS0MsSUFBRyxJQUFJLElBQUksUUFBUSxFQUFFLFVBQVU7QUFFM0MsVUFBTSxZQUFZLEVBQUUsZUFBZSxDQUFDRCxNQUFLQyxJQUFHLENBQUM7QUFBQSxFQUNqRDtBQUVBLE1BQUk7QUFDQSxRQUFJLEdBQUcsYUFBYSxZQUFZO0FBQ2hDLFFBQUksR0FBRyxXQUFXLFlBQVk7QUFBQSxFQUNsQyxTQUFTLEdBQUc7QUFDUixZQUFRLEtBQUssQ0FBQztBQUFBLEVBQ2xCO0FBQ0EsU0FBTyxVQUFVLElBQUksVUFBVTtBQUMvQixTQUFPLElBQUksT0FBTyxNQUFNLFVBQVU7QUFDdEM7QUFFQSxPQUFPLGNBQWMsRUFBRSxjQUFjOyIsCiAgIm5hbWVzIjogWyJFdmVudFR5cGVfZGVmYXVsdCIsICJpbml0X0V2ZW50VHlwZSIsICJSQURJVVMiLCAiRVhURU5UIiwgIk1FVEVSU19QRVJfVU5JVCIsICJQUk9KRUNUSU9OUyIsICJjbGVhciIsICJjbGVhciIsICJhZGQiLCAicmVtb3ZlIiwgInRyYW5zZm9ybSIsICJnZXQiLCAiY29vcmRpbmF0ZXMiLCAib2Zmc2V0IiwgImVxdWFscyIsICJleHRlbmQiLCAiaXNFbXB0eSIsICJpbnRlcnNlY3RzIiwgImFkZCIsICJlcXVhbHMiLCAic2NhbGUiLCAic3F1YXJlZERpc3RhbmNlIiwgIndyYXBYIiwgImNvb3JkaW5hdGVzIiwgImdldEFyZWEiLCAiZGlzdGFuY2UiLCAiZ2V0IiwgImRpc2FibGUiLCAiYWRkIiwgInRvRVBTRzQzMjYiLCAiY2xlYXIiLCAiZXF1YWxzIiwgInRyYW5zZm9ybSIsICJQUk9KRUNUSU9OUyIsICJvZmZzZXQiLCAibm9uZSIsICJ0cmFuc2Zvcm0iLCAicm90YXRlIiwgInNjYWxlIiwgIm9mZnNldCIsICJ0cmFuc2Zvcm0iLCAicm90YXRlIiwgInNjYWxlIiwgInRyYW5zbGF0ZSIsICJpbml0X3RyYW5zZm9ybSIsICJpbml0X3RyYW5zZm9ybSIsICJ0cmFuc2Zvcm0iLCAiY2xvbmUiLCAiZXh0ZW50IiwgImdldCIsICJzY2FsZSIsICJ0cmFuc2Zvcm0iLCAiaW5pdF90cmFuc2Zvcm0iLCAiY29vcmRpbmF0ZXMiLCAicm90YXRlIiwgInNjYWxlIiwgInRyYW5zbGF0ZSIsICJvZmZzZXQiLCAic3F1YXJlZERpc3RhbmNlIiwgIm9mZnNldCIsICJjb29yZGluYXRlcyIsICJvZmZzZXQiLCAic3F1YXJlZERpc3RhbmNlIiwgIm9mZnNldCIsICJjb29yZGluYXRlcyIsICJvZmZzZXQiLCAiY29vcmRpbmF0ZXMiLCAiY29vcmRpbmF0ZXMiLCAic3F1YXJlZERpc3RhbmNlIiwgIm9mZnNldCIsICJvZmZzZXQiLCAib2Zmc2V0IiwgIm9mZnNldCIsICJvZmZzZXQiLCAib2Zmc2V0IiwgImlzRW1wdHkiLCAib2Zmc2V0IiwgImFuZ2xlIiwgImNvb3JkaW5hdGVzIiwgImxpbmVhclJpbmciLCAibGluZWFyUmluZ3MiLCAibm9uZSIsICJlcXVhbHMiLCAiYWRkIiwgIm9mZnNldCIsICJpc0VtcHR5IiwgInVzZXJQcm9qZWN0aW9uIiwgImluaXRfRXZlbnRUeXBlIiwgImxheWVyU3RhdGUiLCAiRXZlbnRUeXBlX2RlZmF1bHQiLCAiZXh0ZW5kIiwgImludGVyc2VjdHMiLCAiYmJveCIsICJsZXZlbCIsICJidWZmZXIiLCAic2NhbGUiLCAic2NhbGUiLCAibmFtZXMiLCAidG9TdHJpbmciLCAiY2FjaGUiLCAiZXJyb3IiLCAiY2FudmFzUG9vbCIsICJlcnJvciIsICJJbWFnZV9kZWZhdWx0IiwgImluaXRfSW1hZ2UiLCAiZ2V0IiwgImluaXRfSW1hZ2UiLCAidG9TdHJpbmciLCAiZ2V0IiwgImNhY2hlIiwgInRyYW5zZm9ybSIsICJzY2FsZSIsICJjb250ZXh0IiwgInNjYWxlIiwgImFkZCIsICJzY2FsZSIsICJnZXQiLCAic2NhbGUiLCAiZ2V0IiwgImltYWdlIiwgIm9mZnNldCIsICJzY2FsZSIsICJuYW1lcyIsICJwYXJzZSIsICJ0eXBlIiwgInBhcnNlIiwgImNvbnRleHQiLCAidG9TdHJpbmciLCAiY29udGV4dCIsICJvZmZzZXQiLCAiUHJvcGVydHkiLCAiRXZlbnRfZGVmYXVsdCIsICJpbml0X0V2ZW50IiwgImdldCIsICJzZWxmIiwgIkxheWVyX2RlZmF1bHQiLCAiaW5pdF9MYXllciIsICJ0aWxlIiwgInJlbmRlciIsICJjYW52YXNQb29sIiwgIkxheWVyX2RlZmF1bHQiLCAiaW5pdF9MYXllciIsICJpbml0X0V2ZW50IiwgImluaXRfRXZlbnRUeXBlIiwgInRyYW5zZm9ybSIsICJFdmVudF9kZWZhdWx0IiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgImNsb25lIiwgIm9mZnNldCIsICJvZmZzZXQiLCAiY29vcmRpbmF0ZXMiLCAiY29vcmRpbmF0ZXMiLCAib2Zmc2V0IiwgImZpbGxJbnN0cnVjdGlvbiIsICJvZmZzZXQiLCAib2Zmc2V0IiwgImNvb3JkaW5hdGVzIiwgIm9mZnNldCIsICJvZmZzZXQiLCAiY29vcmRpbmF0ZXMiLCAicDEiLCAicDIiLCAicDMiLCAic2NhbGUiLCAib2Zmc2V0IiwgInNjYWxlIiwgIm1lYXN1cmVBbmRDYWNoZVRleHRXaWR0aCIsICJjYWNoZSIsICJyb3RhdGUiLCAiaW5pdF90cmFuc2Zvcm0iLCAiaW5pdF90cmFuc2Zvcm0iLCAic2NhbGUiLCAidGV4dCIsICJwMSIsICJwMiIsICJwMyIsICJwNCIsICJmaWxsSW5zdHJ1Y3Rpb24iLCAic3Ryb2tlSW5zdHJ1Y3Rpb24iLCAidHJhbnNmb3JtIiwgImludGVyc2VjdHMiLCAicmVuZGVyIiwgImkiLCAiaWkiLCAiZGlzdGFuY2UiLCAiaW5pdF90cmFuc2Zvcm0iLCAidHJhbnNmb3JtIiwgImkiLCAicmVzdWx0IiwgImNvbnRleHQiLCAiaW5pdF90cmFuc2Zvcm0iLCAidHJhbnNmb3JtIiwgIm9mZnNldCIsICJpbml0X3N0eWxlIiwgInRyYW5zZm9ybXMiLCAiaSIsICJnZW9tZXRyeSIsICJpbml0X3N0eWxlIiwgInRyYW5zZm9ybSIsICJsb2FkaW5nIiwgImluaXRfTGF5ZXIiLCAiaW5pdF9FdmVudFR5cGUiLCAiTGF5ZXJfZGVmYXVsdCIsICJ0cmFuc2Zvcm0iLCAiY2FudmFzUG9vbCIsICJyZW5kZXIiLCAiRXZlbnRUeXBlX2RlZmF1bHQiLCAidHJhbnNmb3JtcyIsICJ1c2VyUHJvamVjdGlvbiIsICJ3cmFwWCIsICJleHRlbnQiLCAidXNlckV4dGVudCIsICJSQnVzaCIsICJiYm94IiwgImVxdWFscyIsICJDaXJjbGVfZGVmYXVsdCIsICJpbml0X0NpcmNsZSIsICJpbml0X3RyYW5zZm9ybSIsICJzcXVhcmVkRGlzdGFuY2UiLCAib2Zmc2V0IiwgImNvb3JkaW5hdGVzIiwgInJvdGF0ZSIsICJjb29yZGluYXRlcyIsICJlbmRzIiwgImxheW91dCIsICJvZmZzZXQiLCAiY29vcmRpbmF0ZXMiLCAic3F1YXJlZERpc3RhbmNlIiwgImxpbmVhclJpbmdzcyIsICJvZmZzZXQiLCAiY29vcmRpbmF0ZXMiLCAib2Zmc2V0IiwgImxpbmVhclJpbmdzcyIsICJpbml0X0NpcmNsZSIsICJyZW5kZXJGZWF0dXJlIiwgInRtcFRyYW5zZm9ybSIsICJGZWF0dXJlX2RlZmF1bHQiLCAiaW5pdF9GZWF0dXJlIiwgImluaXRfdHJhbnNmb3JtIiwgImxpbmVhclJpbmdzcyIsICJvZmZzZXQiLCAidHJhbnNmb3JtIiwgImdldCIsICJzY2FsZSIsICJhbGwiLCAiZm9ybWF0IiwgInhociIsICJWZWN0b3JfZXhwb3J0cyIsICJWZWN0b3JfZGVmYXVsdCIsICJpbml0X1ZlY3RvciIsICJpbml0X0ZlYXR1cmUiLCAiYWxsIiwgIkZlYXR1cmVfZGVmYXVsdCIsICJlcXVhbHMiLCAiVkFSUyIsICJFVkVOVF9UWVBFIiwgIkNPTlRST0xfVFlQRSIsICJUQVJHRVRfVFlQRSIsICJQUk9WSURFUlMiLCAiREVGQVVMVF9PUFRJT05TIiwgInByb3ZpZGVyIiwgImxhYmVsIiwgInBsYWNlaG9sZGVyIiwgImZlYXR1cmVTdHlsZSIsICJ0YXJnZXRUeXBlIiwgImxhbmciLCAibGltaXQiLCAia2VlcE9wZW4iLCAicHJldmVudERlZmF1bHQiLCAicHJldmVudFBhbm5pbmciLCAicHJldmVudE1hcmtlciIsICJkZWZhdWx0Rmx5UmVzb2x1dGlvbiIsICJkZWJ1ZyIsICJhc3NlcnQiLCAiY29uZGl0aW9uIiwgIm1lc3NhZ2UiLCAiRXJyb3IiLCAicmFuZG9tSWQiLCAicHJlZml4IiwgImlkIiwgIndpbmRvdyIsICJwZXJmb3JtYW5jZSIsICJub3dPZmZzZXQiLCAiRGF0ZSIsICJub3ciLCAidGltaW5nIiwgIm5hdmlnYXRpb25TdGFydCIsICJ0b1N0cmluZyIsICJpc051bWVyaWMiLCAic3RyIiwgInRlc3QiLCAiYWRkQ2xhc3MiLCAiZWxlbWVudCIsICJjbGFzc25hbWUiLCAidGltZW91dCIsICJBcnJheSIsICJpc0FycmF5IiwgImZvckVhY2giLCAiZWFjaCIsICJhcnJheSIsICJzcGxpdCIsICJpIiwgImxlbmd0aCIsICJoYXNDbGFzcyIsICJfYWRkQ2xhc3MiLCAicmVtb3ZlQ2xhc3MiLCAiX3JlbW92ZUNsYXNzIiwgImMiLCAiY2xhc3NMaXN0IiwgImNvbnRhaW5zIiwgImNsYXNzUmVnZXgiLCAiY2xhc3NOYW1lIiwgInRlbXBsYXRlIiwgImh0bWwiLCAicm93IiwgInJlcGxhY2UiLCAiaHRtIiwgImtleSIsICJ2YWx1ZSIsICJTdHJpbmciLCAicmVwbGFjZUFsbCIsICJjcmVhdGVFbGVtZW50IiwgIm5vZGUiLCAiZWxlbSIsICJkb2N1bWVudCIsICJhdHRyIiwgInNldEF0dHJpYnV0ZSIsICJuYW1lIiwgImlubmVySFRNTCIsICJmcmFnIiwgImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCAiY2hpbGROb2RlcyIsICJhcHBlbmQiLCAiUmVnRXhwIiwgImVsIiwgImtsYXNzIiwgImFkZCIsICJ0cmltIiwgInNldFRpbWVvdXQiLCAicmVtb3ZlIiwgImtsYXNzZXMiLCAiY3NzQ2xhc3NlcyIsICJIdG1sIiwgIm9wdGlvbnMiLCAidGhpcyIsICJlbHMiLCAiY3JlYXRlQ29udHJvbCIsICJjb250YWluZXIiLCAiY29udGFpbmVyQ2xhc3MiLCAiZWxlbWVudHMiLCAibmFtZXNwYWNlIiwgImlucHV0VGV4dCIsICJjb250YWluZXJJZCIsICJpbnB1dCIsICJjb250cm9sIiwgInF1ZXJ5U2VsZWN0b3IiLCAic2VhcmNoIiwgInJlc3VsdCIsICJnbGFzcyIsICJidXR0b24iLCAianNvbiIsICJvYmoiLCAiUHJvbWlzZSIsICJyZXNvbHZlIiwgInJlamVjdCIsICJ1cmwiLCAiZGF0YSIsICJ0b1F1ZXJ5U3RyaW5nIiwgImNvbmZpZyIsICJtZXRob2QiLCAibW9kZSIsICJjcmVkZW50aWFscyIsICJqc29ucCIsICJjYWxsYmFjayIsICJoZWFkIiwgInNjcmlwdCIsICJjYWxsYmFja05hbWUiLCAiTWF0aCIsICJyb3VuZCIsICJyYW5kb20iLCAiaW5kZXhPZiIsICJyZW1vdmVDaGlsZCIsICJmZXRjaCIsICJ0aGVuIiwgInIiLCAiY2F0Y2giLCAiT2JqZWN0IiwgImtleXMiLCAicmVkdWNlIiwgImFjYyIsICJrIiwgInB1c2giLCAiZW5jb2RlVVJJQ29tcG9uZW50IiwgImpvaW4iLCAib2xDb250cm9sIiwgImJ1dHRvbkNvbnRyb2xJZCIsICJpbnB1dFF1ZXJ5SWQiLCAiaW5wdXRTZWFyY2hJZCIsICJoaWRkZW4iLCAiaWNvbiIsICJQaG90b24iLCAiY29uc3RydWN0b3IiLCAic2V0dGluZ3MiLCAicGFyYW1zIiwgInEiLCAibGFuZ3MiLCAidG9Mb3dlckNhc2UiLCAicXVlcnkiLCAiaW5jbHVkZXMiLCAicmVzdWx0cyIsICJmZWF0dXJlcyIsICJtYXAiLCAibG9uIiwgImdlb21ldHJ5IiwgImNvb3JkaW5hdGVzIiwgImxhdCIsICJhZGRyZXNzIiwgInByb3BlcnRpZXMiLCAicG9zdGNvZGUiLCAiY2l0eSIsICJzdGF0ZSIsICJjb3VudHJ5IiwgIm9yaWdpbmFsIiwgImZvcm1hdHRlZCIsICJkZXRhaWxzIiwgIk9wZW5TdHJlZXQiLCAiZm9ybWF0IiwgImFkZHJlc3NkZXRhaWxzIiwgImNvdW50cnljb2RlcyIsICJ2aWV3Ym94IiwgIm9wdCIsICJiYm94IiwgImJvdW5kaW5nYm94IiwgImRpc3BsYXlfbmFtZSIsICJyb2FkIiwgImhvdXNlTnVtYmVyIiwgImhvdXNlX251bWJlciIsICJ0b3duIiwgIk1hcFF1ZXN0IiwgIm5laWdoYm91cmhvb2QiLCAiQmluZyIsICJpbmNsdWRlTmVpZ2hib3Job29kIiwgIm1heFJlc3VsdHMiLCAicmVzb3VyY2VzIiwgInJlc291cmNlU2V0cyIsICJwb2ludCIsICJmb3JtYXR0ZWRBZGRyZXNzIiwgIk9wZW5DYWdlIiwgImNvdW50cnljb2RlIiwgInByZXR0eSIsICJub19hbm5vdGF0aW9ucyIsICJsbmciLCAiY29tcG9uZW50cyIsICJOb21pbmF0aW0iLCAiYmFzZSIsICJCYXNlIiwgImxheWVyTmFtZSIsICJsYXllciIsICJMYXllclZlY3RvciIsICJzb3VyY2UiLCAiU291cmNlVmVjdG9yIiwgImRpc3BsYXlJbkxheWVyU3dpdGNoZXIiLCAibmV3UHJvdmlkZXIiLCAibGFzdFF1ZXJ5IiwgInJlZ2lzdGVyZWRMaXN0ZW5lcnMiLCAibWFwQ2xpY2siLCAic2V0TGlzdGVuZXJzIiwgIm9wZW5TZWFyY2giLCAiZXZ0IiwgInN0b3BQcm9wYWdhdGlvbiIsICJleHBhbmRlZCIsICJjb2xsYXBzZSIsICJleHBhbmQiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJ0YXJnZXQiLCAid2hpY2giLCAia2V5Q29kZSIsICJmb2N1cyIsICJwYXJhbWV0ZXJzIiwgImdldFBhcmFtZXRlcnMiLCAiZmlyc3RDaGlsZCIsICJjbGVhclJlc3VsdHMiLCAic3BpbiIsICJhamF4IiwgInJlcyIsICJjb25zb2xlIiwgImluZm8iLCAicmVzXyIsICJoYW5kbGVSZXNwb25zZSIsICJjcmVhdGVMaXN0IiwgImxpc3Rlbk1hcENsaWNrIiwgImxpIiwgInJlc3BvbnNlIiwgInVsIiwgImFkZHJlc3NIdG1sIiwgImFkZHJlc3NUZW1wbGF0ZSIsICJjaG9zZW4iLCAicGxhY2UiLCAiYWRkcmVzc09iaiIsICJhZGRyZXNzT3JpZ2luYWwiLCAiZ2V0TWFwIiwgImNvb3JkXyIsICJOdW1iZXIiLCAicGFyc2VGbG9hdCIsICJwcm9qZWN0aW9uIiwgImdldFZpZXciLCAiZ2V0UHJvamVjdGlvbiIsICJjb29yZCIsICJwcm9qIiwgInRyYW5zZm9ybSIsICJ0cmFuc2Zvcm1FeHRlbnQiLCAiZGlzcGF0Y2hFdmVudCIsICJ0eXBlIiwgImNvb3JkaW5hdGUiLCAiZmVhdHVyZSIsICJjcmVhdGVGZWF0dXJlIiwgImZpdCIsICJkdXJhdGlvbiIsICJhbmltYXRlIiwgImNlbnRlciIsICJyZXNvbHV0aW9uIiwgIkZlYXR1cmUiLCAiUG9pbnQiLCAiYWRkTGF5ZXIiLCAic2V0U3R5bGUiLCAic2V0SWQiLCAiZ2V0U291cmNlIiwgImFkZEZlYXR1cmUiLCAiYnVpbGRpbmciLCAidmlsbGFnZSIsICJibHVyIiwgInRoYXQiLCAibWFwRWxlbWVudCIsICJnZXRUYXJnZXRFbGVtZW50IiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAiZm91bmQiLCAiZ2V0TGF5ZXJzIiwgIkNvbnRyb2wiLCAiU3R5bGUiLCAiaW1hZ2UiLCAiSWNvbiIsICJzY2FsZSIsICJzcmMiLCAiJG5vbWluYXRpbSIsICIkaHRtbCIsICJzdXBlciIsICJnZXRMYXllciIsICJ3cmFwWCIsICJjb29yZGluYXRlcyIsICJjYWxsYmFjayIsICJpbml0X0V2ZW50IiwgImluaXRfRXZlbnRUeXBlIiwgIkV2ZW50X2RlZmF1bHQiLCAiRXZlbnRUeXBlX2RlZmF1bHQiLCAiUHJvcGVydHkiLCAiRXZlbnRUeXBlX2RlZmF1bHQiLCAiRXZlbnRUeXBlX2RlZmF1bHQiLCAibmV3RXZlbnQiLCAidGlsZSIsICJ0cmFuc2Zvcm0iLCAiY29udGFpbnMiLCAiUHJvcGVydHlfZGVmYXVsdCIsICJQcm9wZXJ0eV9kZWZhdWx0IiwgImFsd2F5cyIsICJjZW50cm9pZCIsICJtYXAiLCAiZGlzdGFuY2UiLCAib2Zmc2V0IiwgImNvb3JkaW5hdGVzIiwgImFsd2F5cyIsICJkaXN0YW5jZSIsICJkZWZhdWx0cyIsICJpbml0X0V2ZW50VHlwZSIsICJkZWZhdWx0cyIsICJ0aWxlIiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgImlzRW1wdHkiLCAiZXF1YWxzIiwgIk1hcF9kZWZhdWx0IiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgImZvcm1hdCIsICJnZXQiLCAidXNlclByb2plY3Rpb24iLCAid3JhcFgiLCAidGlsZSIsICJpbml0X0ltYWdlIiwgIm9mZnNldCIsICJleHRlbmQiLCAid2lkdGgiLCAiaGVpZ2h0IiwgInhQb3MiLCAieVBvcyIsICJzb3VyY2UiLCAidGlsZSIsICJvZmZzZXQiLCAic3RhdGUiLCAiVGlsZV9kZWZhdWx0IiwgImNyZWF0ZU9yVXBkYXRlIiwgInRpbGUiLCAiY3JlYXRlT3JVcGRhdGUiLCAiY3JlYXRlT3JVcGRhdGUiLCAic2NhbGUiLCAid3JhcFgiLCAiZ2V0IiwgInRpbGUiLCAic2NhbGUiLCAid3JhcFgiLCAiVGlsZV9kZWZhdWx0IiwgIlRpbGVfZGVmYXVsdCIsICJ0aWxlIiwgInRpbGUiLCAiY2FjaGUiLCAiVGlsZV9kZWZhdWx0IiwgInoiLCAieCIsICJ5IiwgInBpeGVsUmF0aW8iLCAicmVuZGVyIiwgImdldCIsICJpbml0X0xheWVyIiwgIkxheWVyX2RlZmF1bHQiLCAidGlsZSIsICJUaWxlX2RlZmF1bHQiLCAidG1wRXh0ZW50IiwgImR4IiwgImR5IiwgImkiLCAiZXF1YWxzIiwgInRpbGVTb3VyY2UiLCAiZnJhbWVTdGF0ZSIsICJUaWxlX2RlZmF1bHQiLCAiaW5pdF9JbWFnZSIsICJpbml0X1ZlY3RvciIsICJpbml0X3N0eWxlIiwgIlZlY3Rvcl9kZWZhdWx0IiwgIlRpbGVfZGVmYXVsdCIsICJNYXBfZGVmYXVsdCIsICJHZW9jb2RlciIsICJsYXQiLCAibG9uIl0KfQo=
